
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>AbstractQueuedSynchronizer.Java · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="莫显辉">
        
        
    
    <link rel="stylesheet" href="../../../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../../../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../../../../gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../../../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../../../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../../../../styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Condition.java.html" />
    
    
    <link rel="prev" href="AbstractOwnableSynchronizer.java.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Doc</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../../../">
            
                <a href="../../../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Util
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../../AbstractMap.java.html">
            
                <a href="../../AbstractMap.java.html">
            
                    
                    AbstractMap.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../../Map.java.html">
            
                <a href="../../Map.java.html">
            
                    
                    Map.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" >
            
                <span>
            
                    
                    Concurrent
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.3.1" data-path="../AbstractExecutorService.java.html">
            
                <a href="../AbstractExecutorService.java.html">
            
                    
                    AbstractExecutorService.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.2" data-path="../Callable.java.html">
            
                <a href="../Callable.java.html">
            
                    
                    Callable.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.3" data-path="../ConcurrentHashMap.java.html">
            
                <a href="../ConcurrentHashMap.java.html">
            
                    
                    ConcurrentHashMap.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.4" data-path="../ConcurrentMap.java.html">
            
                <a href="../ConcurrentMap.java.html">
            
                    
                    ConcurrentMap.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.5" data-path="../Executor.java.html">
            
                <a href="../Executor.java.html">
            
                    
                    Executor.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.6" data-path="../ExecutorCompletionService.java.html">
            
                <a href="../ExecutorCompletionService.java.html">
            
                    
                    ExecutorCompletionService.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.7" data-path="../ExecutorService.java.html">
            
                <a href="../ExecutorService.java.html">
            
                    
                    ExecutorService.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.8" data-path="../Future.java.html">
            
                <a href="../Future.java.html">
            
                    
                    Future.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.9" data-path="../FutureTask.java.html">
            
                <a href="../FutureTask.java.html">
            
                    
                    FutureTask.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.10" data-path="../RunnableFuture.java.html">
            
                <a href="../RunnableFuture.java.html">
            
                    
                    RunnableFuture.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.11" data-path="../ThreadPoolExecutor.java.html">
            
                <a href="../ThreadPoolExecutor.java.html">
            
                    
                    ThreadPoolExecutor.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.12" >
            
                <span>
            
                    
                    Locks
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.3.12.1" data-path="AbstractOwnableSynchronizer.java.html">
            
                <a href="AbstractOwnableSynchronizer.java.html">
            
                    
                    AbstractOwnableSynchronizer.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.3.12.2" data-path="AbstractQueuedSynchronizer.java.html">
            
                <a href="AbstractQueuedSynchronizer.java.html">
            
                    
                    AbstractQueuedSynchronizer.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.12.3" data-path="Condition.java.html">
            
                <a href="Condition.java.html">
            
                    
                    Condition.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.12.4" data-path="Lock.java.html">
            
                <a href="Lock.java.html">
            
                    
                    Lock.Java
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3.12.5" data-path="ReentrantLock.java.html">
            
                <a href="ReentrantLock.java.html">
            
                    
                    ReentrantLock.Java
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../../../日志.html">
            
                <a href="../../../日志.html">
            
                    
                    日志
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../../.." >AbstractQueuedSynchronizer.Java</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="abstractqueuedsynchronizer">AbstractQueuedSynchronizer</h1>
<pre><code class="lang-java"><span class="hljs-comment">/*
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */</span>

<span class="hljs-comment">/*
 *
 *
 *
 *
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166 // assistance &#x534F;&#x52A9;
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */</span>

<span class="hljs-keyword">package</span> java.util.concurrent.locks;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;

<span class="hljs-comment">// &#x8FD9;&#x91CC;&#x5F15;&#x5165;&#x4E86;&#x4E00;&#x4E2A;Unsafe&#xFF0C;&#x662F;&#x4EE5;&#x524D;&#x6CA1;&#x770B;&#x8FC7;&#x7684;&#xFF0C;&#x7B49;&#x770B;&#x5B8C;&#x8FD9;&#x4E2A;&#x518D;&#x770B;</span>

<span class="hljs-comment">/**
 * Provides a framework for implementing blocking locks and related
 * synchronizers (semaphores, events, etc) that rely on
 * first-in-first-out (FIFO) wait queues.  This class is designed to
 * be a useful basis for most kinds of synchronizers that rely on a
 * single atomic {<span class="hljs-doctag">@code</span> int} value to represent state. Subclasses
 * must define the protected methods that change this state, and which
 * define what that state means in terms of this object being acquired
 * or released.  Given these, the other methods in this class carry
 * out all queuing and blocking mechanics. Subclasses can maintain
 * other state fields, but only the atomically updated {<span class="hljs-doctag">@code</span> int}
 * value manipulated using methods {<span class="hljs-doctag">@link</span> #getState}, {<span class="hljs-doctag">@link</span>
 * #setState} and {<span class="hljs-doctag">@link</span> #compareAndSetState} is tracked with respect
 * to synchronization.
 * &#x63D0;&#x4F9B;&#x4E00;&#x4E2A;&#x6846;&#x67B6;&#xFF0C;&#x7528;&#x4E8E;&#x5B9E;&#x73B0;&#x4F9D;&#x8D56;FIFO&#x7B49;&#x5F85;&#x961F;&#x5217;&#x7684;&#x963B;&#x585E;&#x9501;&#x548C;&#x76F8;&#x5173;&#xFF08;related&#xFF09;&#x540C;&#x6B65;&#x5668;&#xFF08;semaphores&#x3001;events&#x7B49;&#xFF09;&#x3002;
 * &#x8FD9;&#x4E2A;&#x7C7B;&#x88AB;&#x8BBE;&#x8BA1;&#x6210;&#x4E00;&#x4E2A;&#x6709;&#x7528;&#x7684;&#x57FA;&#x672C;&#x7C7B;&#xFF0C;&#x5BF9;&#x4E8E;&#x5927;&#x591A;&#x6570;&#x4F9D;&#x8D56;&#x5355;&#x4E2A;&#x539F;&#x5B50;int&#x503C;&#x4EE3;&#x8868;&#x72B6;&#x6001;&#x7684;&#x540C;&#x6B65;&#x5668;&#x3002;
 * &#x5B50;&#x7C7B;&#x5FC5;&#x987B;&#x5B9A;&#x4E49;&#x7528;&#x6765;&#x6539;&#x53D8;&#x72B6;&#x6001;&#x7684;&#x53D7;&#x4FDD;&#x62A4;&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x5B9A;&#x4E49;&#x8BE5;&#x72B6;&#x6001;&#x5728;&#x83B7;&#x53D6;/&#x91CA;&#x653E;&#x8FD9;&#x4E2A;&#x5BF9;&#x8C61;&#x65F6;&#x7684;&#x542B;&#x4E49;&#x3002;
 * &#x9274;&#x4E8E;&#x8FD9;&#x4E9B;&#xFF0C;&#x6B64;&#x7C7B;&#x4E2D;&#x7684;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#xFF08;carry out&#xFF09;&#x6240;&#x6709;&#x6392;&#x961F;&#x548C;&#x963B;&#x585E;&#x673A;&#x5236;&#x3002;
 * &#x5B50;&#x7C7B;&#x53EF;&#x4EE5;&#x7EF4;&#x62A4;&#xFF08;maintain&#xFF09;&#x5176;&#x4ED6;&#x72B6;&#x6001;&#x5B57;&#x6BB5;&#xFF0C;&#x4F46;&#x662F;&#x53EA;&#x6709;&#x4F7F;&#x7528;getState&#x3001;setState&#x548C;compareAndSetState&#x65B9;&#x6CD5;&#x6765;&#x64CD;&#x7EB5;&#xFF08;manipulated&#xFF09;&#x539F;&#x5B50;&#x6027;&#x7684;&#x66F4;&#x65B0;int&#x503C;&#xFF0C;&#x624D;&#x4F1A;&#x5728;&#x540C;&#x6B65;&#x65B9;&#x9762;&#x8FDB;&#x884C;&#x8DDF;&#x8E2A;
 *
 * &lt;p&gt;Subclasses should be defined as non-public internal helper
 * classes that are used to implement the synchronization properties
 * of their enclosing class.  Class
 * {<span class="hljs-doctag">@code</span> AbstractQueuedSynchronizer} does not implement any
 * synchronization interface.  Instead it defines methods such as
 * {<span class="hljs-doctag">@link</span> #acquireInterruptibly} that can be invoked as
 * appropriate by concrete locks and related synchronizers to
 * implement their public methods.
 * &#x5B50;&#x7C7B;&#x5E94;&#x8BE5;&#x88AB;&#x5B9A;&#x4E49;&#x4E3A;&#x975E;&#x516C;&#x5171;&#x7684;&#x5185;&#x90E8;&#x5E2E;&#x52A9;&#x7C7B;&#xFF0C;&#x7528;&#x4E8E;&#x5B9E;&#x73B0;&#x5176;&#x5C01;&#x95ED;&#x7C7B;&#x7684;&#x540C;&#x6B65;&#x5C5E;&#x6027;&#x3002;&#xFF08;&#x5C31;&#x662F;AQS&#x7684;&#x5B50;&#x7C7B;&#x90FD;&#x5E94;&#x8BE5;&#x4F5C;&#x4E3A;[&#x60F3;&#x8981;FIFO&#x540C;&#x6B65;&#x5C5E;&#x6027;&#x7684;]&#x7C7B;&#x7684;&#x5185;&#x90E8;&#x7C7B;&#x4F7F;&#x7528;&#xFF0C;&#x5C31;&#x50CF;ReentrantLock&#x91CC;&#x9762;&#x7684;Sync&#x7C7B;&#xFF09;
 * AbstractQueuedSynchronizer&#x7C7B;&#x6CA1;&#x6709;&#x5B9E;&#x73B0;&#x4EFB;&#x4F55;&#x540C;&#x6B65;&#x63A5;&#x53E3;&#x3002;
 * &#x76F8;&#x53CD;&#xFF0C;&#x5B83;&#x5B9A;&#x4E49;&#x4E86;&#x4F8B;&#x5982;acquireInterruptibly&#x7B49;&#x65B9;&#x6CD5;&#xFF0C;&#x53EF;&#x4EE5;&#x88AB;&#x6709;&#x5173;&#xFF08;concrete&#xFF09;&#x9501;&#x4E0E;&#x76F8;&#x5173;&#x540C;&#x6B65;&#x5668;&#x9002;&#x5F53;&#x8C03;&#x7528;&#x6765;&#x5B9E;&#x73B0;&#x4ED6;&#x4EEC;&#x7684;&#x516C;&#x5171;&#x65B9;&#x6CD5;&#x3002;
 *
 * &lt;p&gt;This class supports either or both a default &lt;em&gt;exclusive&lt;/em&gt;
 * mode and a &lt;em&gt;shared&lt;/em&gt; mode. When acquired in exclusive mode,
 * attempted acquires by other threads cannot succeed. Shared mode
 * acquires by multiple threads may (but need not) succeed. This class
 * does not &amp;quot;understand&amp;quot; these differences except in the
 * mechanical sense that when a shared mode acquire succeeds, the next
 * waiting thread (if one exists) must also determine whether it can
 * acquire as well. Threads waiting in the different modes share the
 * same FIFO queue. Usually, implementation subclasses support only
 * one of these modes, but both can come into play for example in a
 * {<span class="hljs-doctag">@link</span> ReadWriteLock}. Subclasses that support only exclusive or
 * only shared modes need not define the methods supporting the unused mode.
 * &#x8FD9;&#x4E2A;&#x7C7B;&#x652F;&#x6301;&#x72EC;&#x5360;&#xFF08;exclusive&#xFF09;&#x6A21;&#x5F0F;&#x4E0E;&#x5171;&#x4EAB;&#xFF08;shared&#xFF09;&#x6A21;&#x5F0F;&#x4E2D;&#x7684;&#x4E00;&#x79CD;&#x6216;&#x8005;&#x4E24;&#x79CD;&#x3002;
 * &#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E2D;&#x83B7;&#x53D6;&#xFF08;&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x52A0;&#x9501;&#xFF09;&#x65F6;&#xFF0C;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x83B7;&#x53D6;&#x4E0D;&#x4F1A;&#x6210;&#x529F;&#x3002;
 * &#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E2D;&#x591A;&#x4E2A;&#x7EBF;&#x7A0B;&#x83B7;&#x53D6;&#x53EF;&#x80FD;&#xFF08;&#x4F46;&#x662F;&#x4E0D;&#x4E00;&#x5B9A;&#xFF09;&#x6210;&#x529F;&#x3002;
 * &#x8BE5;&#x7C7B;&#x4E0D;&#x7406;&#x89E3;&#x8FD9;&#x4E9B;&#x4E0D;&#x540C;&#x70B9;&#xFF0C;&#x9664;&#x4E86;&#x5728;&#x673A;&#x68B0;&#x610F;&#x4E49;&#x4E0A;&#x8BF4;&#xFF0C;&#x5F53;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x83B7;&#x53D6;&#x6210;&#x529F;&#x65F6;&#xFF0C;&#x4E0B;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#xFF08;&#x5982;&#x679C;&#x6709;&#x4E00;&#x4E2A;&#x7684;&#x8BDD;&#xFF09;&#x5FC5;&#x987B;&#x786E;&#x5B9A;&#x5B83;&#x662F;&#x5426;&#x4E5F;&#x53EF;&#x4EE5;&#x83B7;&#x53D6;&#x3002;
 * &#x5728;&#x4E0D;&#x540C;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x4EEC;&#x5171;&#x4EAB;&#x540C;&#x4E00;&#x4E2A;FIFO&#x961F;&#x5217;&#x3002;&#xFF08;&#x610F;&#x5473;&#x7740;&#x4E00;&#x4E2A;AQS&#x53EF;&#x4EE5;&#x540C;&#x65F6;&#x5B9E;&#x73B0;&#x4E24;&#x79CD;&#x6A21;&#x5F0F;&#xFF0C;&#x5C31;&#x5F00;&#x5934;&#x7B2C;&#x4E00;&#x53E5;&#x8BDD;&#xFF09;&#x3002;
 * &#x901A;&#x5E38;&#xFF0C;&#x5B50;&#x7C7B;&#x5B9E;&#x73B0;&#x65F6;&#x53EA;&#x652F;&#x6301;&#x5176;&#x4E2D;&#x4E00;&#x79CD;&#x6A21;&#x5F0F;&#xFF0C;&#x4F46;&#x662F;&#x4E24;&#x79CD;&#x90FD;&#x53EF;&#x4EE5;&#x8D77;&#x5230;&#x4F5C;&#x7528;&#xFF0C;&#x4F8B;&#x5982;&#x5728;ReadWriteLock&#x3002;
 * &#x4EC5;&#x652F;&#x6301;&#x72EC;&#x5360;&#x6216;&#x8005;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x7684;&#x5B50;&#x7EBF;&#x7A0B;&#x4E0D;&#x9700;&#x8981;&#x5B9E;&#x73B0;&#x652F;&#x6301;&#x672A;&#x4F7F;&#x7528;&#x6A21;&#x5F0F;&#x7684;&#x65B9;&#x6CD5;&#xFF08;&#x5C31;&#x662F;&#x4E24;&#x79CD;&#x6A21;&#x5F0F;&#x4F1A;&#x6709;&#x4E24;&#x5957;&#x65B9;&#x6CD5;&#xFF0C;&#x5982;&#x679C;&#x53EA;&#x5B9E;&#x73B0;&#x4E00;&#x79CD;&#x6A21;&#x5F0F;&#xFF0C;&#x53EA;&#x9009;&#x62E9;&#x4E00;&#x5957;&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x5C31;&#x884C;&#xFF09;&#xFF08;&#x8FD9;&#x91CC;&#x4E5F;&#x53EF;&#x4EE5;&#x89E3;&#x91CA;&#x4E3A;&#x4EC0;&#x4E48;&#x4E24;&#x5957;&#x65B9;&#x6CD5;&#x90FD;&#x4E0D;&#x662F;abstract&#x65B9;&#x6CD5;&#xFF09;&#x3002;
 *
 * &lt;p&gt;This class defines a nested {<span class="hljs-doctag">@link</span> ConditionObject} class that
 * can be used as a {<span class="hljs-doctag">@link</span> Condition} implementation by subclasses
 * supporting exclusive mode for which method {<span class="hljs-doctag">@link</span>
 * #isHeldExclusively} reports whether synchronization is exclusively
 * held with respect to the current thread, method {<span class="hljs-doctag">@link</span> #release}
 * invoked with the current {<span class="hljs-doctag">@link</span> #getState} value fully releases
 * this object, and {<span class="hljs-doctag">@link</span> #acquire}, given this saved state value,
 * eventually restores this object to its previous acquired state.  No
 * {<span class="hljs-doctag">@code</span> AbstractQueuedSynchronizer} method otherwise creates such a
 * condition, so if this constraint cannot be met, do not use it.  The
 * behavior of {<span class="hljs-doctag">@link</span> ConditionObject} depends of course on the
 * semantics of its synchronizer implementation.
 * &#x8BE5;&#x7C7B;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;&#x5D4C;&#x5957;&#xFF08;nest&#xFF09;&#x7684;ConditionObject&#x5BF9;&#x8C61;&#xFF0C;&#x53EF;&#x4EE5;&#x88AB;&#x652F;&#x6301;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x7684;&#x5B50;&#x7C7B;&#x7528;&#x6765;&#x4F5C;&#x4E3A;Condition&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x5176;&#x4E2D;&#xFF1A;
 * isHeldExclusively&#x65B9;&#x6CD5;&#x62A5;&#x544A;&#x662F;&#x5426;&#x9488;&#x5BF9;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x72EC;&#x5360;&#x540C;&#x6B65;&#xFF0C;
 * &#x4F7F;&#x7528;&#x5F53;&#x524D;getState&#x503C;&#x8C03;&#x7528;release&#x65B9;&#x6CD5;&#x5B8C;&#x5168;&#x91CA;&#x653E;&#x8FD9;&#x4E2A;&#x5BF9;&#x8C61;&#xFF1F;&#xFF1F;&#xFF1F;
 * &#x548C;acquire&#xFF0C;&#x7ED9;&#x5B9A;&#x4FDD;&#x5B58;&#x72B6;&#x6001;&#x503C;&#xFF0C;&#x6700;&#x7EC8;&#x5C06;&#x8FD9;&#x4E2A;&#x5BF9;&#x8C61;&#x6062;&#x590D;&#x5230;&#x5B83;&#x4E4B;&#x524D;&#x83B7;&#x53D6;&#x7684;&#x72B6;&#x6001;&#x3002;&#xFF08;&#x770B;&#x4E0D;&#x61C2;&#xFF0C;&#x7B49;&#x4E0B;&#x770B;&#x6E90;&#x7801;&#x518D;&#x770B;&#x770B;&#x662F;&#x5565;&#x610F;&#x601D;&#xFF09;
 * &#x6CA1;&#x6709;AbstractQueuedSynchronizer&#x65B9;&#x6CD5;&#x5426;&#x5219;&#x521B;&#x5EFA;&#x8FD9;&#x6837;&#x7684;condition&#xFF0C;&#x6240;&#x4EE5;&#x5982;&#x679C;&#x8FD9;&#x4E9B;&#x7EA6;&#x675F;&#x4E0D;&#x80FD;&#x88AB;&#x6EE1;&#x8DB3;&#xFF0C;&#x4E0D;&#x8981;&#x4F7F;&#x7528;&#x5B83;&#x3002;
 * ConditionObject&#x7684;&#x884C;&#x4E3A;&#x5F53;&#x7136;&#x53D6;&#x51B3;&#x4E8E;&#x5176;&#x540C;&#x6B65;&#x5668;&#x5B9E;&#x73B0;&#x7684;&#x8BED;&#x4E49;&#x3002;
 *
 * &lt;p&gt;This class provides inspection, instrumentation, and monitoring
 * methods for the internal queue, as well as similar methods for
 * condition objects. These can be exported as desired into classes
 * using an {<span class="hljs-doctag">@code</span> AbstractQueuedSynchronizer} for their
 * synchronization mechanics.
 * &#x8BE5;&#x7C7B;&#x63D0;&#x4F9B;&#x5BF9;&#x5185;&#x90E8;&#x961F;&#x5217;&#x7684;&#x68C0;&#x67E5;&#x3001;&#x76D1;&#x6D4B;&#x548C;&#x76D1;&#x63A7;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x5BF9;condition&#x5BF9;&#x8C61;&#x4E5F;&#x6709;&#x540C;&#x6837;&#x7684;&#x65B9;&#x6CD5;&#x3002;
 * &#x53EF;&#x4EE5;&#x6839;&#x636E;&#x9700;&#x8981;&#x5BFC;&#x51FA;&#x5230;&#x7C7B;&#x4E2D;&#xFF0C;&#x4F7F;&#x7528;AQS&#x4F5C;&#x4E3A;&#x4ED6;&#x4EEC;&#x7684;&#x540C;&#x6B65;&#x673A;&#x5236;&#x3002;
 *
 * &lt;p&gt;Serialization of this class stores only the underlying atomic
 * integer maintaining state, so deserialized objects have empty
 * thread queues. Typical subclasses requiring serializability will
 * define a {<span class="hljs-doctag">@code</span> readObject} method that restores this to a known
 * initial state upon deserialization.
 * &#x8BE5;&#x7C7B;&#x7684;&#x5E8F;&#x5217;&#x5316;&#x53EA;&#x5B58;&#x50A8;&#x5E95;&#x5C42;&#x7684;&#x7528;&#x539F;&#x5B50;interger&#x7EF4;&#x62A4;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x6240;&#x4EE5;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x5BF9;&#x8C61;&#x6709;&#x7A7A;&#x7684;&#x7EBF;&#x7A0B;&#x961F;&#x5217;&#xFF08;&#x6216;&#x8005;&#x7FFB;&#x8BD1;&#x4E3A;&#x7EBF;&#x7A0B;&#x961F;&#x5217;&#x4E3A;&#x7A7A;&#xFF09;&#x3002;
 * &#x9700;&#x8981;&#x5E8F;&#x5217;&#x5316;&#x7684;&#x5178;&#x578B;&#x5B50;&#x7C7B;&#x5C06;&#x5B9A;&#x4E49;readObject&#x65B9;&#x6CD5;&#xFF0C;&#x5728;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x65F6;&#x5C06;&#x5176;&#x6062;&#x590D;&#xFF08;restores&#xFF09;&#x5230;&#x5DF2;&#x77E5;&#xFF08;known&#xFF09;&#x7684;&#x521D;&#x59CB;&#x5316;&#x72B6;&#x6001;&#x3002;
 *
 * &lt;h3&gt;Usage&lt;/h3&gt;
 * &#x7528;&#x6CD5;
 *
 * &lt;p&gt;To use this class as the basis of a synchronizer, redefine the
 * following methods, as applicable, by inspecting and/or modifying
 * the synchronization state using {<span class="hljs-doctag">@link</span> #getState}, {<span class="hljs-doctag">@link</span>
 * #setState} and/or {<span class="hljs-doctag">@link</span> #compareAndSetState}:
 * &#x4F7F;&#x7528;&#x8BE5;&#x7C7B;&#x4F5C;&#x4E3A;&#x540C;&#x6B65;&#x5668;&#x57FA;&#x7840;&#xFF0C;&#x6839;&#x636E;&#x9002;&#x5E94;&#x6027;&#xFF08;applicable&#xFF09;&#x60C5;&#x51B5;&#x91CD;&#x65B0;&#x5B9A;&#x4E49;&#x4E0B;&#x9762;&#x51E0;&#x4E2A;&#x65B9;&#x6CD5;&#xFF08;5&#x4E2A;&#x65B9;&#x6CD5;&#xFF09;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;getState&#x3001;setState&#x4E0E;compareAndSetState&#x6765;&#x68C0;&#x67E5;&#xFF08;inspect&#xFF09;&#x548C;&#x4FEE;&#x6539;&#x540C;&#x6B65;&#x5668;&#x72B6;&#x6001;&#x3002;
 *
 * &#x4E0B;&#x9762;&#x8FD9;&#x51E0;&#x4E2A;&#x65B9;&#x6CD5;&#x5F88;&#x5173;&#x952E;&#xFF0C;&#x662F;&#x5B9E;&#x73B0;&#x7C7B;&#x552F;&#x4E00;&#x80FD;&#x6539;&#x7684;5&#x4E2A;&#x65B9;&#x6CD5;
 * &lt;ul&gt;
 * &lt;li&gt; {<span class="hljs-doctag">@link</span> #tryAcquire}
 * &lt;li&gt; {<span class="hljs-doctag">@link</span> #tryRelease}
 * &lt;li&gt; {<span class="hljs-doctag">@link</span> #tryAcquireShared}
 * &lt;li&gt; {<span class="hljs-doctag">@link</span> #tryReleaseShared}
 * &lt;li&gt; {<span class="hljs-doctag">@link</span> #isHeldExclusively}
 * &lt;/ul&gt;
 *
 * Each of these methods by default throws {<span class="hljs-doctag">@link</span>
 * UnsupportedOperationException}.  Implementations of these methods
 * must be internally thread-safe, and should in general be short and
 * not block. Defining these methods is the &lt;em&gt;only&lt;/em&gt; supported
 * means of using this class. All other methods are declared
 * {<span class="hljs-doctag">@code</span> final} because they cannot be independently varied.
 * &#x4E0A;&#x9762;&#x7684;&#x6BCF;&#x4E2A;&#x65B9;&#x6CD5;&#x9ED8;&#x8BA4;&#x629B;&#x51FA;UnsupportedOperationException&#x5F02;&#x5E38;&#x3002;
 * &#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x73B0;&#x5FC5;&#x987B;&#x662F;&#x5185;&#x90E8;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x7684;&#xFF0C;&#x901A;&#x5E38;&#x5E94;&#x8BE5;&#x662F;&#x7B80;&#x77ED;&#x5E76;&#x4E14;&#x4E0D;&#x4F1A;&#x963B;&#x585E;&#x7684;&#x3002;
 * &#x5B9A;&#x4E49;&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#xFF0C;&#x662F;&#x4F7F;&#x7528;&#x8BE5;&#x7C7B;&#x552F;&#x4E00;&#x652F;&#x6301;&#x7684;&#x65B9;&#x6CD5;&#xFF08;means&#xFF09;&#xFF08;mean&#x662F;&#x610F;&#x5473;&#x7740;&#xFF09;
 * &#x6240;&#x6709;&#x7684;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x90FD;&#x58F0;&#x660E;&#x4E3A;final&#xFF0C;&#x56E0;&#x4E3A;&#x4ED6;&#x4EEC;&#x4E0D;&#x80FD;&#x72EC;&#x7ACB;&#x53D8;&#x5316;&#xFF08;varied&#xFF09;
 * &#xFF08;&#x5C31;&#x662F;&#x9664;&#x4E86;&#x4E0A;&#x9762;&#x8FD9;&#x4E94;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x91CD;&#x65B0;&#x5B9A;&#x4E49;&#xFF0C;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x90FD;&#x6539;&#x4E0D;&#x4E86;&#xFF09;
 *
 * &lt;p&gt;You may also find the inherited methods from {<span class="hljs-doctag">@link</span>
 * AbstractOwnableSynchronizer} useful to keep track of the thread
 * owning an exclusive synchronizer.  You are encouraged to use them
 * -- this enables monitoring and diagnostic tools to assist users in
 * determining which threads hold locks.
 * &#x4ECE;AbstractOwnableSynchronizer&#x7EE7;&#x627F;&#x7684;&#x65B9;&#x6CD5;&#x5BF9;&#x8FFD;&#x8E2A;&#x72EC;&#x5360;&#x540C;&#x6B65;&#x5668;&#x7684;&#x7EBF;&#x7A0B;&#x5F88;&#x6709;&#x7528;&#x3002;
 * &#x9F13;&#x52B1;&#x4F7F;&#x7528;&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5; -- &#x76D1;&#x63A7;&#x548C;&#x8BCA;&#x65AD;&#x5DE5;&#x5177;&#x80FD;&#x591F;&#x53BB;&#x5E2E;&#x52A9;&#x4F7F;&#x7528;&#x8005;&#x786E;&#x5B9A;&#x54EA;&#x4E9B;&#x7EBF;&#x7A0B;&#x6301;&#x6709;&#x9501;
 *
 * &lt;p&gt;Even though this class is based on an internal FIFO queue, it
 * does not automatically enforce FIFO acquisition policies.  The core
 * of exclusive synchronization takes the form:
 * &#x5373;&#x4F7F;&#x8BE5;&#x7C7B;&#x57FA;&#x4E8E;&#x5185;&#x90E8;&#x7684;FIFO&#x961F;&#x5217;&#xFF0C;&#x5B83;&#x4E5F;&#x4E0D;&#x4F1A;&#x81EA;&#x52A8;&#x6267;&#x884C;FIFO&#x83B7;&#x53D6;&#x7B56;&#x7565;&#x3002;
 * &#x72EC;&#x5360;&#x540C;&#x6B65;&#x7684;&#x6838;&#x5FC3;&#x5F62;&#x5F0F;&#x4E3A;&#xFF1A;
 *
 * &lt;pre&gt;
 * Acquire:
 *     while (!tryAcquire(arg)) { // &#x83B7;&#x53D6;&#x5931;&#x8D25;&#x4F1A;&#x5FAA;&#x73AF;
 *        &lt;em&gt;enqueue thread if it is not already queued&lt;/em&gt;; // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x6392;&#x961F;&#xFF0C;&#x5219;&#x7EBF;&#x7A0B;&#x6392;&#x961F;
 *        &lt;em&gt;possibly block current thread&lt;/em&gt;; // &#x53EF;&#x80FD;&#x963B;&#x585E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;
 *     }
 *
 * Release:
 *     if (tryRelease(arg)) // &#x91CA;&#x653E;&#x6210;&#x529F;
 *        &lt;em&gt;unblock the first queued thread&lt;/em&gt;; // &#x7B2C;&#x4E00;&#x4E2A;&#x961F;&#x5217;&#x7EBF;&#x7A0B;&#x88AB;&#x5524;&#x9192;
 * &lt;/pre&gt;
 *
 * (Shared mode is similar but may involve cascading signals.)
 * &#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x7C7B;&#x4F3C;&#xFF0C;&#x4E0D;&#x8FC7;&#x53EF;&#x80FD;&#x4F1A;&#x6D89;&#x53CA;&#x7EA7;&#x8054;&#x4FE1;&#x53F7;
 *
 * &#x975E;&#x516C;&#x5E73;&#x9501;&#x4E0E;&#x516C;&#x5E73;&#x9501;&#x7684;&#x5927;&#x81F4;&#x5B9E;&#x73B0;
 * &lt;p id=&quot;barging&quot;&gt;Because checks in acquire are invoked before
 * enqueuing, a newly acquiring thread may &lt;em&gt;barge&lt;/em&gt; ahead of
 * others that are blocked and queued.  However, you can, if desired,
 * define {<span class="hljs-doctag">@code</span> tryAcquire} and/or {<span class="hljs-doctag">@code</span> tryAcquireShared} to
 * disable barging by internally invoking one or more of the inspection
 * methods, thereby providing a &lt;em&gt;fair&lt;/em&gt; FIFO acquisition order.
 * In particular, most fair synchronizers can define {<span class="hljs-doctag">@code</span> tryAcquire}
 * to return {<span class="hljs-doctag">@code</span> false} if {<span class="hljs-doctag">@link</span> #hasQueuedPredecessors} (a method
 * specifically designed to be used by fair synchronizers) returns
 * {<span class="hljs-doctag">@code</span> true}.  Other variations are possible.
 * &#x56E0;&#x4E3A;&#x5728;&#x5165;&#x961F;&#x4E4B;&#x524D;&#x4F1A;&#x8C03;&#x7528;acquire&#x8FDB;&#x884C;&#x68C0;&#x67E5;&#xFF0C;&#x65B0;&#x7684;&#x53D1;&#x8D77;acquire&#x7684;&#x7EBF;&#x7A0B;&#x53EF;&#x80FD;&#x62A2;&#xFF08;barge ahead of&#x62A2;&#x5148;&#xFF09;&#x5728;&#x5176;&#x5B83;&#x963B;&#x585E;&#x548C;&#x5728;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7EBF;&#x7A0B;&#x4E4B;&#x524D;&#xFF08;&#x62FF;&#x5230;&#x9501;&#xFF09;&#x3002;
 * &#x4F46;&#x662F;&#xFF0C;&#x5982;&#x679C;&#x9700;&#x8981;&#xFF0C;&#x5B9A;&#x4E49;tryAcquire&#x548C;/&#x6216;tryAcquireShared&#x4EE5;&#x901A;&#x8FC7;&#x5185;&#x90E8;&#x8C03;&#x7528;&#x4E00;&#x4E2A;&#x6216;&#x591A;&#x4E2A;&#x68C0;&#x67E5;&#x65B9;&#x5F0F;&#x6765;&#x7981;&#x6B62;&#x62A2;&#x5360;&#xFF08;&#x63D2;&#x961F;&#xFF09;&#xFF0C;&#x4ECE;&#x800C;&#x63D0;&#x4F9B;&#x516C;&#x5E73;&#xFF08;fair&#xFF09;&#x7684;FIFO&#x83B7;&#x53D6;&#x987A;&#x5E8F;&#x3002;
 * &#x7279;&#x522B;&#x7684;&#xFF0C;&#x5982;&#x679C;hasQueuePredecessors&#xFF08;&#x4E00;&#x4E2A;&#x5728;&#x516C;&#x5E73;&#x540C;&#x6B65;&#x5668;&#x4E2D;&#x4F7F;&#x7528;&#x7684;&#x7279;&#x5B9A;&#x8BBE;&#x8BA1;&#x7684;&#x65B9;&#x6CD5;&#xFF09;&#x8FD4;&#x56DE;true&#xFF0C;&#x5927;&#x591A;&#x6570;&#x516C;&#x5E73;&#x540C;&#x6B65;&#x5668;&#x53EF;&#x4EE5;&#x5B9A;&#x4E49;tryAcquire&#x8FD4;&#x56DE;false&#x3002;&#xFF08;&#x5C31;&#x662F;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5C31;&#x4E0D;&#x5141;&#x8BB8;&#x63D2;&#x961F;&#xFF09;
 * &#x5176;&#x4ED6;&#x53D8;&#x5316;&#xFF08;variations&#xFF09;&#x4E5F;&#x662F;&#x53EF;&#x80FD;&#x7684;&#x3002;
 *
 * &lt;p&gt;Throughput and scalability are generally highest for the
 * default barging (also known as &lt;em&gt;greedy&lt;/em&gt;,
 * &lt;em&gt;renouncement&lt;/em&gt;, and &lt;em&gt;convoy-avoidance&lt;/em&gt;) strategy.
 * While this is not guaranteed to be fair or starvation-free, earlier
 * queued threads are allowed to recontend before later queued
 * threads, and each recontention has an unbiased chance to succeed
 * against incoming threads.  Also, while acquires do not
 * &amp;quot;spin&amp;quot; in the usual sense, they may perform multiple
 * invocations of {<span class="hljs-doctag">@code</span> tryAcquire} interspersed with other
 * computations before blocking.  This gives most of the benefits of
 * spins when exclusive synchronization is only briefly held, without
 * most of the liabilities when it isn&apos;t. If so desired, you can
 * augment this by preceding calls to acquire methods with
 * &quot;fast-path&quot; checks, possibly prechecking {<span class="hljs-doctag">@link</span> #hasContended}
 * and/or {<span class="hljs-doctag">@link</span> #hasQueuedThreads} to only do so if the synchronizer
 * is likely not to be contended.
 * &#x5728;&#x9ED8;&#x8BA4;&#x62A2;&#x5360;&#x7B56;&#x7565;&#xFF08;&#x53C8;&#x79F0;greedy&#xFF0C;renouncement&#x548C;convoy-avoidance&#xFF09;&#x4E0B;&#xFF0C;&#x541E;&#x5410;&#x91CF;&#xFF08;throughput&#xFF09;&#x548C;&#x53EF;&#x6269;&#x5C55;&#x6027;&#xFF08;scalability&#xFF09;&#x6700;&#x9AD8;&#x3002;
 * &#x867D;&#x7136;&#x8FD9;&#x6837;&#x4E0D;&#x80FD;&#x4FDD;&#x8BC1;&#x516C;&#x5E73;&#x6216;&#x8005;&#x6CA1;&#x6709;&#x9965;&#x997F;&#xFF0C;&#x4F46;&#x662F;&#x5141;&#x8BB8;&#x8F83;&#x65E9;&#x7684;&#x6392;&#x961F;&#x8FDB;&#x7A0B;&#x5728;&#x8F83;&#x665A;&#x7684;&#x6392;&#x961F;&#x7EBF;&#x7A0B;&#x4E4B;&#x524D;&#x91CD;&#x65B0;&#x7ADE;&#x4E89;&#xFF08;recontend&#xFF09;&#xFF0C;&#x5E76;&#x4E14;&#x6BCF;&#x6B21;&#x91CD;&#x65B0;&#x7ADE;&#x4E89;&#x90FD;&#x6709;&#x5E73;&#x7B49;&#x7684;&#x673A;&#x4F1A;&#x6210;&#x529F;&#x5BF9;&#x6297;&#x65B0;&#x6765;&#x7684;&#x7EBF;&#x7A0B;&#x3002;
 *&#xFF08;&#x610F;&#x601D;&#x5C31;&#x662F;&#x6392;&#x5728;&#x961F;&#x9996;&#x7684;&#x7EBF;&#x7A0B;&#x4E00;&#x5B9A;&#x5728;&#x961F;&#x5217;&#x91CC;&#x7684;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x4E4B;&#x524D;&#x8FDB;&#x884C;&#x9501;&#x7ADE;&#x4E89;&#xFF0C;&#x5E76;&#x4E14;&#x961F;&#x9996;&#x7EBF;&#x7A0B;&#x4E0E;&#x65B0;&#x6765;&#x7684;&#x8FD8;&#x672A;&#x5165;&#x961F;&#x7684;&#x7EBF;&#x7A0B;&#x7ADE;&#x4E89;&#x9501;&#x5177;&#x6709;&#x5E73;&#x7B49;&#x7684;&#x6982;&#x7387;&#xFF09;
 * &#x867D;&#x7136;acquires&#x5728;&#x901A;&#x5E38;&#x610F;&#x4E49;&#x4E0A;&#x4E0D;&#x4F1A;&#x81EA;&#x65CB;&#xFF08;&#x81EA;&#x65CB;&#x5C31;&#x662F;&#x91CD;&#x590D;&#x64CD;&#x4F5C;&#x76F4;&#x5230;&#x67D0;&#x4E2A;&#x72B6;&#x6001;&#x9000;&#x51FA;&#xFF0C;&#x7C7B;&#x4F3C;&#x4E8E;while(cond){...}&#xFF09;&#xFF0C;&#x4F46;&#x4ED6;&#x4EEC;&#x53EF;&#x80FD;&#x4F1A;&#x5728;&#x963B;&#x585E;&#x4E4B;&#x524D;&#x6267;&#x884C;&#x591A;&#x6B21;&#x8C03;&#x7528;tryAcquire&#x5E76;&#x7A7F;&#x63D2;&#x5176;&#x4ED6;&#x8BA1;&#x7B97;&#x3002;
 * &#x5728;&#x72EC;&#x5360;&#x540C;&#x6B65;&#x53EA;&#x77ED;&#x6682;&#x6301;&#x6709;&#x65F6;&#xFF0C;&#x63D0;&#x4F9B;&#x7684;&#x8FD9;&#x79CD;&#x81EA;&#x65CB;&#x7684;&#x65B9;&#x5F0F;&#x5177;&#x6709;&#x5F88;&#x5927;&#x7684;&#x597D;&#x5904;&#xFF1B;&#x5982;&#x679C;&#x4E0D;&#x662F;&#xFF0C;&#x4E5F;&#x6CA1;&#x6709;&#x591A;&#x5927;&#x7684;&#x574F;&#x5904;&#x3002;&#xFF08;&#x5982;&#x679C;&#x9501;&#x5360;&#x6709;&#x65F6;&#x95F4;&#x77ED;&#x6682;&#xFF0C;&#x53EF;&#x80FD;&#x5728;&#x81EA;&#x65CB;&#x8FC7;&#x7A0B;&#x4E2D;&#x5C31;&#x80FD;&#x62FF;&#x5230;&#x9501;&#xFF0C;&#x51CF;&#x5C11;&#x4E86;&#x963B;&#x585E;&#x518D;&#x5524;&#x9192;&#x7684;&#x6D88;&#x8017;&#xFF09;
 * &#x5982;&#x679C;&#x6709;&#x9700;&#x6C42;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4F7F;&#x7528;&#x201C;&#x5FEB;&#x901F;&#x8DEF;&#x5F84;&#x201D;&#x68C0;&#x67E5;&#x6765;&#x9884;&#x5148;&#x8C03;&#x7528;acquire&#x65B9;&#x6CD5;&#x4EE5;&#x589E;&#x5F3A;&#x8FD9;&#x4E00;&#x70B9;&#xFF0C;&#x53EF;&#x80FD;&#x9884;&#x5148;&#x68C0;&#x67E5;hasContended &#x548C;/&#x6216;hasQueuedThreads&#x65B9;&#x6CD5;&#xFF0C;&#x4EE5;&#x4EC5;&#x5728;&#x5982;&#x679C;&#x540C;&#x6B65;&#x5668;&#x5F88;&#x53EF;&#x80FD;&#x6CA1;&#x6709;&#x7ADE;&#x4E89;&#x65F6;&#x624D;&#x8FD9;&#x6837;&#x505A;&#x3002;
 * &#xFF08;&#x9884;&#x5148;&#x68C0;&#x67E5;&#x6709;&#x6CA1;&#x6709;&#x7ADE;&#x4E89;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x4E0D;&#x7ADE;&#x4E89;&#x7684;&#x53EF;&#x80FD;&#x6027;&#xFF0C;&#x5C31;&#x901A;&#x8FC7;&#x81EA;&#x65CB;&#x7684;&#x65B9;&#x5F0F;&#x6765;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x9501;&#xFF09;
 *
 * &lt;p&gt;This class provides an efficient and scalable basis for
 * synchronization in part by specializing its range of use to
 * synchronizers that can rely on {<span class="hljs-doctag">@code</span> int} state, acquire, and
 * release parameters, and an internal FIFO wait queue. When this does
 * not suffice, you can build synchronizers from a lower level using
 * {<span class="hljs-doctag">@link</span> java.util.concurrent.atomic atomic} classes, your own custom
 * {<span class="hljs-doctag">@link</span> java.util.Queue} classes, and {<span class="hljs-doctag">@link</span> LockSupport} blocking
 * support.
 * &#x8BE5;&#x7C7B;&#x5BF9;&#x4E8E;&#x90E8;&#x5206;&#x662F;&#x901A;&#x8FC7;&#x5C06;&#x5176;&#x4F7F;&#x7528;&#x8303;&#x56F4;&#x4E13;&#x95E8;&#x7528;&#x4E8E;&#x4F9D;&#x8D56;int&#x72B6;&#x6001;&#x3001;&#x83B7;&#x53D6;&#x548C;&#x91CA;&#x653E;&#x53C2;&#x6570;&#x4EE5;&#x53CA;&#x5185;&#x90E8;FIFO&#x7B49;&#x5F85;&#x961F;&#x5217;&#x7684;&#x540C;&#x6B65;&#x5668;&#xFF0C;&#x4ECE;&#x800C;&#x4E3A;&#x540C;&#x6B65;&#x63D0;&#x4F9B;&#x6709;&#x6548;&#xFF08;efficient&#xFF09;&#x548C;&#x53EF;&#x6269;&#x5C55;&#x7684;&#x57FA;&#x7840;&#x3002;
 * &#x5982;&#x679C;&#x8FD9;&#x4E0D;&#x80FD;&#x6EE1;&#x8DB3;&#xFF08;suffice&#xFF09;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4F7F;&#x7528;atomic&#x7C7B;&#x3001;&#x81EA;&#x5B9A;&#x4E49;Queue&#x7C7B;&#x548C;LockSupprot&#x963B;&#x585E;&#x652F;&#x6301;&#x4ECE;&#x8F83;&#x4F4E;&#x7EA7;&#x522B;&#x6784;&#x5EFA;&#x540C;&#x6B65;&#x5668;
 *
 * &lt;h3&gt;Usage Examples&lt;/h3&gt;
 * &#x4F7F;&#x7528;&#x6837;&#x4F8B;
 *
 * &lt;p&gt;Here is a non-reentrant mutual exclusion lock class that uses
 * the value zero to represent the unlocked state, and one to
 * represent the locked state. While a non-reentrant lock
 * does not strictly require recording of the current owner
 * thread, this class does so anyway to make usage easier to monitor.
 * It also supports conditions and exposes
 * one of the instrumentation methods:
 * &#x8FD9;&#x91CC;&#x662F;&#x4E00;&#x4E2A;&#x4E0D;&#x53EF;&#x91CD;&#x5165;&#x7684;&#x4E92;&#x65A5;&#x9501;class&#xFF0C;&#x7528;0&#x4EE3;&#x8868;&#x89E3;&#x9501;&#x72B6;&#x6001;&#xFF0C;&#x7528;1&#x4EE3;&#x8868;&#x52A0;&#x9501;&#x72B6;&#x6001;&#x3002;
 * &#x867D;&#x7136;&#x4E0D;&#x53EF;&#x91CD;&#x5165;&#x9501;&#x4E0D;&#x4E25;&#x683C;&#x8981;&#x6C42;&#x8BB0;&#x5F55;&#x5F53;&#x524D;&#x7528;&#x6709;&#x9501;&#x7684;&#x7EBF;&#x7A0B;&#xFF0C;&#x4F46;&#x8FD9;&#x4E2A;&#x7C7B;&#x65E0;&#x8BBA;&#x5982;&#x4F55;&#x8FD9;&#x6837;&#x505A;&#x662F;&#x4E3A;&#x4E86;&#x8BA9;&#x4F7F;&#x7528;&#x66F4;&#x5BB9;&#x6613;&#x76D1;&#x63A7;&#x3002;
 * &#x5B83;&#x8FD8;&#x652F;&#x6301;&#x6761;&#x4EF6;&#x5E76;&#x516C;&#x5F00;&#x4E00;&#x79CD;&#x68C0;&#x6D4B;&#x65B9;&#x6CD5;&#xFF1A;
 *
 *  &lt;pre&gt; {<span class="hljs-doctag">@code</span>
 * class Mutex implements Lock, java.io.Serializable { // mutex &#x662F;&#x4FE1;&#x53F7;&#x91CF;
 *
 *   // Our internal helper class
 *   private static class Sync extends AbstractQueuedSynchronizer {
 *     // &#x7EE7;&#x627F;AQS&#x7684;&#xFF0C;&#x72EC;&#x5360;&#x9501;&#xFF0C;&#x5F97;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x4E24;&#x4E2A;try&#x65B9;&#x6CD5;&#xFF08;tryAcquire&#x4E0E;tryRelease&#xFF09;&#x4E0E;isHeldExclusively&#x65B9;&#x6CD5;&#xFF0C;&#x56E0;&#x4E3A;AQS&#x6CA1;&#x6709;&#x5B9A;&#x4E49;&#x8FD9;&#x4EE8;&#x5B9E;&#x9645;&#x64CD;&#x4F5C;&#x3002;&#xFF01;&#xFF01;&#xFF01;&#xFF01;&#xFF01;&#xFF01;
 *     // Reports whether in locked state
 *     protected boolean isHeldExclusively() { // &#x5F53;&#x524D;&#x540C;&#x6B65;&#x5668;&#x662F;&#x5426;&#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x88AB;&#x7EBF;&#x7A0B;&#x5360;&#x7528;&#xFF0C;&#x4E00;&#x822C;&#x8BE5;&#x65B9;&#x6CD5;&#x8868;&#x793A;&#x662F;&#x5426;&#x88AB;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6240;&#x72EC;&#x5360;
 *       return getState() == 1;
 *     }
 *
 *     // Acquires the lock if state is zero
 *     public boolean tryAcquire(int acquires) {
 *       assert acquires == 1; // Otherwise unused // assert&#x662F;java&#x7684;&#x5173;&#x952E;&#x5B57;--&#x65AD;&#x8A00;&#xFF0C;&#x5982;&#x679C;&#x8868;&#x8FBE;&#x5F0F;&#x6210;&#x7ACB;&#xFF0C;&#x5219;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#xFF0C;&#x5426;&#x5219;&#x629B;&#x51FA;AssertionError&#xFF0C;&#x5E76;&#x7EC8;&#x6B62;&#x6267;&#x884C;&#x3002;
 *       if (compareAndSetState(0, 1)) { // &#x4F7F;&#x7528;CAS&#x6765;&#x8BBE;&#x7F6E;&#x52A0;&#x9501;
 *         setExclusiveOwnerThread(Thread.currentThread());
 *         return true;
 *       }
 *       return false;
 *     }
 *
 *     // Releases the lock by setting state to zero
 *     protected boolean tryRelease(int releases) {
 *       assert releases == 1; // Otherwise unused
 *       if (getState() == 0) throw new IllegalMonitorStateException();
 *       setExclusiveOwnerThread(null);
 *       setState(0); // &#x4E0D;&#x4F7F;&#x7528;CAS&#xFF0C;&#x76F4;&#x63A5;&#x89E3;&#x9501;
 *       return true;
 *     }
 *
 *     // Provides a Condition
 *     // &#x9700;&#x8981;&#x7528;&#x5230;Conditionobject&#x7684;&#xFF0C;&#x5F97;&#x81EA;&#x5DF1;&#x5199;newCondition&#x65B9;&#x6CD5;&#xFF0C;AQS&#x4E0D;&#x63D0;&#x4F9B;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF0C;&#x53EA;&#x63D0;&#x4F9B;ConditionObject&#x8FD9;&#x4E2A;&#x5185;&#x90E8;&#x7C7B;
 *     Condition newCondition() { return new ConditionObject(); }
 *
 *     // Deserializes properly // &#x6B63;&#x786E;&#x53CD;&#x5E8F;&#x5217;&#x5316;
 *     private void readObject(ObjectInputStream s)
 *         throws IOException, ClassNotFoundException {
 *       s.defaultReadObject();
 *       setState(0); // reset to unlocked state // &#x91CD;&#x7F6E;&#x4E3A;&#x4E0D;&#x52A0;&#x9501;&#x72B6;&#x6001;
 *     }
 *   }
 *
 *   // The sync object does all the hard work. We just forward to it.
 *   private final Sync sync = new Sync();
 *
 *   // &#x901A;&#x8FC7;Sync&#x5B9E;&#x73B0;Lock&#x63A5;&#x53E3;&#x7684;&#x4E00;&#x4E9B;&#x529F;&#x80FD;
 *   public void lock()                { sync.acquire(1); }
 *   public boolean tryLock()          { return sync.tryAcquire(1); }
 *   public void unlock()              { sync.release(1); }
 *   public Condition newCondition()   { return sync.newCondition(); }
 *   public boolean isLocked()         { return sync.isHeldExclusively(); }
 *   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
 *   public void lockInterruptibly() throws InterruptedException {
 *     sync.acquireInterruptibly(1);
 *   }
 *   public boolean tryLock(long timeout, TimeUnit unit)
 *       throws InterruptedException {
 *     return sync.tryAcquireNanos(1, unit.toNanos(timeout));
 *   }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;Here is a latch class that is like a
 * {<span class="hljs-doctag">@link</span> java.util.concurrent.CountDownLatch CountDownLatch}
 * except that it only requires a single {<span class="hljs-doctag">@code</span> signal} to
 * fire. Because a latch is non-exclusive, it uses the {<span class="hljs-doctag">@code</span> shared}
 * acquire and release methods.
 * &#x8FD9;&#x91CC;&#x662F;&#x4E00;&#x4E2A;&#x7C7B;&#x4F3C;&#x4E8E;CountDownLatch&#x7684;&#x95E9;&#x9501;&#x7C7B;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x5355;&#x4FE1;&#x53F7;&#x91CF;&#x5C31;&#x53EF;&#x4EE5;&#x89E6;&#x53D1;&#x3002;
 * &#x56E0;&#x4E3A;latch&#x662F;&#x4E2A;&#x975E;&#x72EC;&#x5360;&#x7684;&#xFF0C;&#x5B83;&#x4F7F;&#x7528;&#x5171;&#x4EAB;&#x7684;acquire&#x4E0E;release&#x65B9;&#x6CD5;
 *
 *  &lt;pre&gt; {<span class="hljs-doctag">@code</span>
 * class BooleanLatch {
 *
 *   private static class Sync extends AbstractQueuedSynchronizer {
 *     // &#x7528;AQS&#x5B9E;&#x73B0;&#x5171;&#x4EAB;&#x9501;&#xFF0C;&#x5F97;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;tryAcquireShared&#x548C;tryReleaseShared&#x65B9;&#x6CD5;
 *     boolean isSignalled() { return getState() != 0; } // &#x662F;&#x5426;&#x6709;&#x4FE1;&#x53F7;&#xFF0C;state&#x521D;&#x59CB;&#x5316;&#x4E3A;0
 *
 *     protected int tryAcquireShared(int ignore) {
 *       return isSignalled() ? 1 : -1;
 *     }
 *
 *     protected boolean tryReleaseShared(int ignore) {
 *       setState(1);
 *       return true;
 *     }
 *   }
 *
 *   private final Sync sync = new Sync();
 *   public boolean isSignalled() { return sync.isSignalled(); }
 *   public void signal()         { sync.releaseShared(1); } // 
 *   public void await() throws InterruptedException {  // &#x5982;&#x679C;&#x4E0A;&#x6765;&#x5C31;&#x8C03;&#x7528;await&#xFF0C;&#x90A3;&#x4E48;&#x56E0;&#x4E3A;state=0&#x4E0D;&#x6EE1;&#x8DB3;&#x6761;&#x4EF6;&#xFF0C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x3002;&#x5982;&#x679C;&#x73B0;&#x5728;state=1&#x4E86;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x4E0D;&#x4F1A;&#x963B;&#x585E;&#x76F4;&#x63A5;&#x6267;&#x884C;
 *     sync.acquireSharedInterruptibly(1);
 *   }
 * }}&lt;/pre&gt;
 *
 * <span class="hljs-doctag">@since</span> 1.5
 * <span class="hljs-doctag">@author</span> Doug Lea
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span>
    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> // &#x7528;&#x6765;&#x8BB0;&#x5F55;&#x5F53;&#x524D;&#x72EC;&#x5360;&#x9501;&#x7684;&#x62E5;&#x6709;&#x8005;&#xFF08;&#x62E5;&#x6709;&#x8005;&#x662F;&#x4E2A;<span class="hljs-title">Thread</span>&#x5BF9;&#x8C61;&#xFF09;
    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7373984972572414691L</span>;

    <span class="hljs-comment">/**
     * Creates a new {<span class="hljs-doctag">@code</span> AbstractQueuedSynchronizer} instance
     * with initial synchronization state of zero.
     * &#x521D;&#x59CB;&#x5316;&#x65F6;&#xFF0C;&#x8868;&#x793A;&#x72B6;&#x6001;&#x7684;state&#x4E3A;0
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractQueuedSynchronizer</span><span class="hljs-params">()</span> </span>{ }

    <span class="hljs-comment">/**
     * Wait queue node class.
     * &#x7B49;&#x5F85;&#x961F;&#x5217;&#x8282;&#x70B9;&#x7C7B;
     *
     * &lt;p&gt;The wait queue is a variant of a &quot;CLH&quot; (Craig, Landin, and
     * Hagersten) lock queue. CLH locks are normally used for
     * spinlocks.  We instead use them for blocking synchronizers, but
     * use the same basic tactic of holding some of the control
     * information about a thread in the predecessor of its node.  A
     * &quot;status&quot; field in each node keeps track of whether a thread
     * should block.  A node is signalled when its predecessor
     * releases.  Each node of the queue otherwise serves as a
     * specific-notification-style monitor holding a single waiting
     * thread. The status field does NOT control whether threads are
     * granted locks etc though.  A thread may try to acquire if it is
     * first in the queue. But being first does not guarantee success;
     * it only gives the right to contend.  So the currently released
     * contender thread may need to rewait.
     * &#x7B49;&#x5F85;&#x961F;&#x5217;&#x662F;CLH&#x9501;&#x961F;&#x5217;&#x7684;&#x53D8;&#x79CD;&#xFF08;variant&#xFF09;&#x3002;CLH&#x9501;&#x901A;&#x5E38;&#x7528;&#x4E8E;&#x81EA;&#x65CB;&#x9501;&#xFF08;spinlock&#xFF09;&#x3002;
     * &#x6211;&#x4EEC;&#x6539;&#x4E3A;&#x5C06;&#x5B83;&#x7528;&#x4E8E;&#x963B;&#x585E;&#x540C;&#x6B65;&#x5668;&#xFF0C;&#x4F46;&#x4E5F;&#x7528;&#x76F8;&#x540C;&#x7684;&#x57FA;&#x672C;&#x7B56;&#x7565;&#xFF08;tactic&#xFF09;&#xFF0C;&#x5373;&#x5728;node&#x7684;&#x524D;&#x9A71;&#xFF08;predecessor&#xFF09;&#x4E2D;&#x4FDD;&#x5B58;&#x6709;&#x5173;&#x7EBF;&#x7A0B;&#x7684;&#x4E00;&#x4E9B;&#x63A7;&#x5236;&#x4FE1;&#x606F;
     * &#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x4E2D;&#x7684;&#x201C;state&#x201D;&#x5B57;&#x6BB5;&#x4FDD;&#x6301;&#x8DDF;&#x8E2A;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x5E94;&#x8BE5;&#x88AB;&#x963B;&#x585E;&#x3002;
     * &#x8282;&#x70B9;&#x5728;&#x5176;&#x524D;&#x9A71;&#x89E3;&#x9501;&#xFF08;releases&#xFF09;&#x7684;&#x65F6;&#x5019;&#x6536;&#x5230;&#x4FE1;&#x53F7;&#xFF08;&#x7406;&#x89E3;&#x4E3A;&#x5524;&#x9192;&#xFF09;&#x3002;
     * &#x961F;&#x5217;&#x4E2D;&#x7684;&#x6BCF;&#x4E2A;node&#x90FD;&#x5145;&#x5F53;&#x4E00;&#x4E2A;&#x7279;&#x5B9A;&#x901A;&#x77E5;&#x5F0F;&#x76D1;&#x89C6;&#x5668;&#xFF0C;&#x6301;&#x6709;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#x3002;&#xFF08;&#x4E00;&#x4E2A;node&#x91CC;&#x9762;&#x5305;&#x542B;&#x4E86;&#x4E00;&#x4E2A;waiting&#x7EBF;&#x7A0B;&#x5BF9;&#x8C61;&#xFF09;
     * &#x5C3D;&#x7BA1;status&#x5C5E;&#x6027;&#x4E0D;&#x4F1A;&#x63A7;&#x5236;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x88AB;&#x6388;&#x4E88;&#x9501;&#x3002;&#xFF08;status&#x5C5E;&#x6027;&#x53EA;&#x662F;&#x7528;&#x6765;&#x8868;&#x540D;&#x53EF;&#x4EE5;&#x53BB;&#x7ADE;&#x4E89;&#x9501;&#xFF0C;&#x4E0D;&#x7BA1;&#x4F1A;&#x4E0D;&#x4F1A;&#x52A0;&#x9501;&#x6210;&#x529F;&#xFF09;
     * &#x5982;&#x679C;&#x7EBF;&#x7A0B;&#x662F;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#xFF0C;&#x5B83;&#x53EF;&#x80FD;&#x5C1D;&#x8BD5;&#x53BB;&#x52A0;&#x9501;&#xFF08;acquire&#xFF09;
     * &#x4F46;&#x662F;&#x4F5C;&#x4E3A;&#x7B2C;&#x4E00;&#x4E2A;&#x4E0D;&#x4F1A;&#x4FDD;&#x8BC1;&#x4E00;&#x5B9A;&#x80FD;&#x52A0;&#x9501;&#x6210;&#x529F;&#xFF1B;&#x5B83;&#x53EA;&#x662F;&#x88AB;&#x7ED9;&#x4E88;&#x4E86;&#x53BB;&#x7ADE;&#x4E89;&#x7684;&#x6743;&#x5229;&#x3002;&#xFF08;&#x5728;unfair&#x975E;&#x516C;&#x5E73;&#x9501;&#x91CC;&#xFF0C;&#x961F;&#x5217;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#x8981;&#x8DDF;&#x5C1A;&#x672A;&#x5165;&#x961F;&#x7684;&#x7ADE;&#x4E89;&#x7EBF;&#x7A0B;&#x4E00;&#x8D77;&#x7ADE;&#x4E89;&#x9501;&#xFF09;
     * &#x6240;&#x4EE5;&#x5F53;&#x524D;&#x91CA;&#x653E;&#x7684;&#x7ADE;&#x4E89;&#x8005;&#x7EBF;&#x7A0B;&#xFF08;&#x4E5F;&#x5C31;&#x662F;&#x88AB;&#x5524;&#x9192;&#x7684;&#x7EBF;&#x7A0B;&#x6216;&#x8005;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#xFF09;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x7B49;&#x5F85;&#x3002;
     *
     * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new
     * tail. To dequeue, you just set the head field.
     * CLH&#x9501;&#x8FDB;&#x961F;&#xFF0C;&#x9700;&#x8981;&#x539F;&#x5B50;&#x6027;&#x7684;&#x5C06;&#x5B83;&#x62FC;&#x63A5;&#x4E3A;&#x65B0;&#x7684;&#x5C3E;&#x90E8;&#xFF08;tail&#xFF09;&#x3002;
     * &#x51FA;&#x961F;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x8BBE;&#x7F6E;&#x5B83;&#x7684;&#x5934;&#x90E8;&#xFF08;head&#xFF09;&#x5B57;&#x6BB5;&#x3002;
     * &lt;pre&gt;
     *      +------+  prev +-----+       +-----+
     * head |      | &lt;---- |     | &lt;---- |     |  tail
     *      +------+       +-----+       +-----+
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Insertion into a CLH queue requires only a single atomic
     * operation on &quot;tail&quot;, so there is a simple atomic point of
     * demarcation from unqueued to queued. Similarly, dequeuing
     * involves only updating the &quot;head&quot;. However, it takes a bit
     * more work for nodes to determine who their successors are,
     * in part to deal with possible cancellation due to timeouts
     * and interrupts.
     * &#x63D2;&#x5165;CLH&#x961F;&#x5217;&#x53EA;&#x9700;&#x8981;&#x5BF9;&#x201C;tail&#x201D;&#x8FDB;&#x884C;&#x4E00;&#x6B21;&#x539F;&#x5B50;&#x6027;&#x64CD;&#x4F5C;&#xFF0C;&#x6240;&#x4EE5;&#x4ECE;&#x672A;&#x5165;&#x961F;&#x5230;&#x5165;&#x961F;&#x6709;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x539F;&#x5B50;&#x5206;&#x754C;&#x70B9;&#x3002;&#xFF08;&#x5165;&#x961F;&#x4EC5;&#x7ECF;&#x8FC7;&#x4E00;&#x4E2A;&#x539F;&#x5B50;&#x6027;&#x64CD;&#x4F5C;&#xFF09;
     * &#x7C7B;&#x4F3C;&#x7684;&#xFF0C;&#x51FA;&#x961F;&#x6D89;&#x53CA;&#x53EA;&#x66F4;&#x65B0;&#x201C;head&#x201D;&#x3002;
     * &#x7136;&#x800C;&#xFF0C;&#x8282;&#x70B9;&#x9700;&#x8981;&#x505A;&#x66F4;&#x591A;&#x7684;&#x5DE5;&#x4F5C;&#x6765;&#x786E;&#x5B9A;&#x4ED6;&#x4EEC;&#x7684;&#x540E;&#x7EE7;&#xFF08;successors&#xFF09;&#x662F;&#x8C01;&#xFF0C;&#x90E8;&#x5206;&#x662F;&#x4E3A;&#x4E86;&#x5904;&#x7406;&#x7531;&#x4E8E;&#x8D85;&#x65F6;&#x548C;&#x4E2D;&#x65AD;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x7684;&#x53D6;&#x6D88;&#x3002;
     *
     * &#x4E0B;&#x9762;&#x4F1A;&#x8BB2;&#x53D6;&#x6D88;&#x7684;&#x95EE;&#x9898;
     * &lt;p&gt;The &quot;prev&quot; links (not used in original CLH locks), are mainly
     * needed to handle cancellation. If a node is cancelled, its
     * successor is (normally) relinked to a non-cancelled
     * predecessor. For explanation of similar mechanics in the case
     * of spin locks, see the papers by Scott and Scherer at
     * http://www.cs.rochester.edu/u/scott/synchronization/
     * &#x201C;prev&#x201D;&#x8FDE;&#x63A5;&#xFF08;&#x5728;&#x539F;&#x59CB;CLH&#x9501;&#x4E2D;&#x672A;&#x4F7F;&#x7528;&#xFF09;&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x5904;&#x7406;&#x53D6;&#x6D88;&#x3002;
     * &#x5982;&#x679C;&#x4E00;&#x4E2A;node&#x88AB;&#x53D6;&#x6D88;&#xFF0C;&#x5B83;&#x7684;&#x540E;&#x7EE7;&#xFF08;&#x901A;&#x5E38;&#xFF09;&#x4F1A;&#x91CD;&#x65B0;&#x8FDE;&#x63A5;&#x5230;&#x4E00;&#x4E2A;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x524D;&#x9A71;&#x3002;&#xFF08;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x88AB;&#x53D6;&#x6D88;&#x4E86;&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x4E2A;&#x8282;&#x70B9;&#x5E94;&#x8BE5;&#x4ECE;CLH&#x94FE;&#x4E0A;&#x5220;&#x9664;&#xFF0C;&#x8FD9;&#x65F6;&#x5019;&#x5C31;&#x9700;&#x8981;&#x5B83;&#x7684;&#x540E;&#x7EE7;&#x53BB;&#x91CD;&#x65B0;&#x627E;&#x5230;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x524D;&#x9A71;&#xFF09;
     * &#x6709;&#x5173;&#x81EA;&#x65CB;&#x9501;&#x60C5;&#x51B5;&#x4E0B;&#x7684;&#x7C7B;&#x4F3C;&#x673A;&#x5236;&#x89E3;&#x91CA;&#xFF0C;&#x8BF7;&#x53C2;&#x9605;&#x94FE;&#x63A5;&#x7684;&#x8BBA;&#x6587;
     *
     * &lt;p&gt;We also use &quot;next&quot; links to implement blocking mechanics.
     * The thread id for each node is kept in its own node, so a
     * predecessor signals the next node to wake up by traversing
     * next link to determine which thread it is.  Determination of
     * successor must avoid races with newly queued nodes to set
     * the &quot;next&quot; fields of their predecessors.  This is solved
     * when necessary by checking backwards from the atomically
     * updated &quot;tail&quot; when a node&apos;s successor appears to be null.
     * (Or, said differently, the next-links are an optimization
     * so that we don&apos;t usually need a backward scan.)
     * &#x6211;&#x4EEC;&#x8FD8;&#x4F7F;&#x7528;&#x201C;next&#x201D;&#x8FDE;&#x63A5;&#x6765;&#x5B9E;&#x73B0;&#x963B;&#x585E;&#x673A;&#x5236;&#x3002;
     * &#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x7EBF;&#x7A0B;ID&#x4FDD;&#x5B58;&#x5728;&#x4ED6;&#x4EEC;&#x81EA;&#x5DF1;&#x7684;node&#x91CC;&#xFF0C;&#x56E0;&#x6B64;&#x524D;&#x9A71;&#x4FE1;&#x53F7;&#x662F;&#x901A;&#x8FC7;&#x904D;&#x5386;next&#x8FDE;&#x63A5;&#x6765;&#x786E;&#x5B9A;&#x5B83;&#x662F;&#x54EA;&#x4E2A;&#x7EBF;&#x7A0B;&#x6765;&#x901A;&#x77E5;&#x5524;&#x9192;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x3002;&#xFF1F;&#xFF1F;&#xFF1F;
     * &#x786E;&#x5B9A;&#x540E;&#x9A71;&#x8282;&#x70B9;&#x5FC5;&#x987B;&#x907F;&#x514D;&#x4E0E;&#x65B0;&#x6392;&#x961F;&#x8282;&#x70B9;&#x7ADE;&#x4E89;&#x4EE5;&#x8BBE;&#x7F6E;&#x5176;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;&#x201C;next&#x201D;&#x5B57;&#x6BB5;&#x3002;&#xFF08;&#x5C31;&#x662F;&#x8BBE;&#x7F6E;&#x5176;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;next&#x503C;&#x65F6;&#x4E0D;&#x8981;&#x4E0E;&#x65B0;&#x5165;&#x961F;&#x7684;&#x8282;&#x70B9;&#x53D1;&#x751F;&#x51B2;&#x7A81;&#xFF09;
     * &#x5F53;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x540E;&#x9A71;&#x51FA;&#x73B0;&#x7A7A;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x5FC5;&#x8981;&#xFF0C;&#x4ECE;&#x539F;&#x5B50;&#x66F4;&#x65B0;&#x7684;&#x201C;tail&#x201D;&#x5411;&#x540E;&#x68C0;&#x67E5;&#x6765;&#x89E3;&#x51B3;&#x3002;&#xFF08;&#x6362;&#x53E5;&#x8BDD;&#x8BF4;&#xFF0C;next&#x8FDE;&#x63A5;&#x662F;&#x4E00;&#x79CD;&#x4F18;&#x5316;&#xFF08;optimization&#xFF09;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x901A;&#x5E38;&#x4E0D;&#x9700;&#x8981;&#x5411;&#x540E;&#x626B;&#x63CF;&#xFF09;&#xFF1F;&#xFF1F;&#xFF1F;
     *
     * &lt;p&gt;Cancellation introduces some conservatism to the basic
     * algorithms.  Since we must poll for cancellation of other
     * nodes, we can miss noticing whether a cancelled node is
     * ahead or behind us. This is dealt with by always unparking
     * successors upon cancellation, allowing them to stabilize on
     * a new predecessor, unless we can identify an uncancelled
     * predecessor who will carry this responsibility.
     * &#x53D6;&#x6D88;&#xFF08;Canellation&#xFF09;&#x4E3A;&#x57FA;&#x7840;&#x7B97;&#x6CD5;&#x5F15;&#x5165;&#x4E86;&#x4E9B;&#x4FDD;&#x5B88;&#x6027;&#x3002;&#x7531;&#x4E8E;&#x6211;&#x4EEC;&#x5FC5;&#x987B;&#x8F6E;&#x8BE2;&#xFF08;poll&#xFF09;&#x5176;&#x4ED6;&#x8282;&#x70B9;&#x7684;&#x53D6;&#x6D88;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x65E0;&#x6CD5;&#x6CE8;&#x610F;&#x5230;&#x53D6;&#x6D88;&#x7684;node&#x662F;&#x5728;&#x6211;&#x4EEC;&#x4E4B;&#x524D;&#x8FD8;&#x662F;&#x4E4B;&#x540E;&#x3002;
     * &#x901A;&#x8FC7;&#x5728;&#x53D6;&#x6D88;&#x65F6;&#x603B;&#x662F;&#x89E3;&#x9664;&#x540E;&#x7EE7;&#x6765;&#x5904;&#x7406;&#x7684;&#xFF0C;&#x5141;&#x8BB8;&#x4ED6;&#x4EEC;&#x7A33;&#x5B9A;&#x5728;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x524D;&#x9A71;&#x4E0A;&#xFF0C;&#x9664;&#x975E;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x786E;&#x5B9A;&#x4E00;&#x4E2A;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x524D;&#x9A71;&#x5C06;&#x627F;&#x62C5;&#x8FD9;&#x4E2A;&#x8D23;&#x4EFB;&#x3002;
     *
     * &lt;p&gt;CLH queues need a dummy header node to get started. But
     * we don&apos;t create them on construction, because it would be wasted
     * effort if there is never contention. Instead, the node
     * is constructed and head and tail pointers are set upon first
     * contention.
     * CLH&#x961F;&#x5217;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x865A;&#x62DF;&#xFF08;dummy&#xFF09;&#x5934;&#x7ED3;&#x70B9;&#x6765;&#x542F;&#x52A8;&#x3002;&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x4E0D;&#x4F1A;&#x5728;&#x6784;&#x5EFA;&#x65F6;&#x521B;&#x5EFA;&#x4ED6;&#x4EEC;&#xFF0C;&#x56E0;&#x4E3A;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x4ECE;&#x6765;&#x6CA1;&#x6709;&#x7ADE;&#x4E89;&#xFF0C;&#x8FD9;&#x4E2A;&#x865A;&#x62DF;&#x5934;&#x5C31;&#x662F;&#x6D6A;&#x8D39;&#x3002;
     * &#x53D6;&#x800C;&#x4EE3;&#x4E4B;&#x7684;&#x662F;&#xFF0C;&#x5728;&#x7B2C;&#x4E00;&#x6B21;&#x7ADE;&#x4E89;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x8FD9;&#x4E2A;&#x865A;&#x62DF;&#x5934;&#x8282;&#x70B9;&#x5C06;&#x521B;&#x5EFA;&#x5E76;&#x8BBE;&#x7F6E;head&#x8DDF;tail&#x6307;&#x9488;
     *
     * &lt;p&gt;Threads waiting on Conditions use the same nodes, but
     * use an additional link. Conditions only need to link nodes
     * in simple (non-concurrent) linked queues because they are
     * only accessed when exclusively held.  Upon await, a node is
     * inserted into a condition queue.  Upon signal, the node is
     * transferred to the main queue.  A special value of status
     * field is used to mark which queue a node is on.
     * &#x5728;Condition&#x4E0A;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x4F7F;&#x7528;&#x76F8;&#x540C;&#x7684;node&#xFF0C;&#x4E0D;&#x8FC7;&#x4F7F;&#x7528;&#x989D;&#x5916;&#x7684;&#x8FDE;&#x63A5;&#xFF08;&#x5C31;&#x662F;&#x8BF4;&#x6709;&#x4E00;&#x4E2A;&#x662F;CLH&#x4E3B;&#x94FE;&#xFF08;&#x4E3B;&#x94FE;=&#x4E3B;&#x961F;&#x5217;&#xFF09;&#xFF0C;&#x8FD8;&#x6709;&#x4E00;&#x4E9B;&#x662F;&#x9488;&#x5BF9;&#x4E0D;&#x540C;&#x7684;Condition&#x5EFA;&#x7ACB;&#x7684;&#x4E0D;&#x540C;&#x7684;&#x94FE;&#xFF09;
     * Condition&#x53EA;&#x9700;&#x8981;&#x8FDE;&#x63A5;&#x5728;&#x7B80;&#x5355;&#x7684;&#xFF08;&#x975E;&#x5E76;&#x53D1;&#xFF09;&#x94FE;&#x63A5;&#x961F;&#x5217;&#x4E0A;&#x7684;node&#xFF0C;&#x56E0;&#x4E3A;&#x4ED6;&#x4EEC;&#x4EC5;&#x5728;&#x72EC;&#x5360;&#x65F6;&#x624D;&#x4F1A;&#x88AB;&#x8BBF;&#x95EE;&#x3002;
     * &#x6839;&#x636E;&#x4FE1;&#x53F7;&#xFF0C;node&#x88AB;&#x8F6C;&#x79FB;&#x5230;&#x4E3B;&#x961F;&#x5217;&#x4E0A;&#x3002;&#xFF08;&#x8FD9;&#x4E2A;&#x4FE1;&#x53F7;&#x5C31;&#x662F;&#x80FD;&#x591F;&#x6EE1;&#x8DB3;&#x72EC;&#x5360;&#x9700;&#x6C42;&#x7684;&#x4FE1;&#x53F7;&#xFF0C;&#x4F1A;&#x5C06;&#x5BF9;&#x5E94;&#x7684;Condition&#x94FE;&#x8F6C;&#x79FB;&#x5230;&#x4E3B;&#x961F;&#x5217;&#x4E0A;&#xFF09;
     * status&#x5B57;&#x6BB5;&#x7684;&#x7279;&#x6B8A;&#x503C;&#x7528;&#x6765;&#x6807;&#x8BB0;node&#x6240;&#x5728;&#x7684;&#x961F;&#x5217;&#x3002;
     *
     * &lt;p&gt;Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill
     * Scherer and Michael Scott, along with members of JSR-166
     * expert group, for helpful ideas, discussions, and critiques
     * on the design of this class.
     * &#x5927;&#x4F6C;&#x611F;&#x8C22;&#x5927;&#x4F6C;&#x4EEC;&#x7684;&#x65F6;&#x95F4;&#xFF0C;&#x4E0D;&#x770B;&#x4E86;
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
        <span class="hljs-comment">/** Marker to indicate a node is waiting in shared mode */</span>
        <span class="hljs-comment">// &#x8868;&#x660E;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#x7684;node</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();
        <span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span>
        <span class="hljs-comment">// &#x8868;&#x660E;&#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#x7684;node</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span>
        <span class="hljs-comment">// &#x7B49;&#x5F85;status&#x503C;=1 &#x8868;&#x793A;&#x7EBF;&#x7A0B;&#x53D6;&#x6D88;</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;
        <span class="hljs-comment">/** waitStatus value to indicate successor&apos;s thread needs unparking */</span>
        <span class="hljs-comment">// &#x7B49;&#x5F85;status&#x503C;=-1 &#x8868;&#x793A;&#x540E;&#x7EE7;&#x7684;&#x7EBF;&#x7A0B;&#x9700;&#x8981;&#x5524;&#x9192;</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;
        <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span>
        <span class="hljs-comment">// &#x7B49;&#x5F85;status&#x503C;=-2 &#x8868;&#x793A;&#x7EBF;&#x7A0B;&#x5728;&#x7B49;&#x5F85;&#x6761;&#x4EF6;&#xFF08;&#x6216;&#x8005;&#x8BF4;&#x7EBF;&#x7A0B;&#x5728;condition&#x961F;&#x5217;&#x4E0A;&#xFF09;</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;
        <span class="hljs-comment">/**
         * waitStatus value to indicate the next acquireShared should
         * unconditionally propagate
         */</span>
         <span class="hljs-comment">// waitStatus&#x503C;=-3 &#x8868;&#x793A;&#x4E0B;&#x4E00;&#x4E2A;acquireShared&#x5E94;&#x8BE5;&#x65E0;&#x6761;&#x4EF6;&#x4F20;&#x64AD;</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;

        <span class="hljs-comment">/**
         * Status field, taking on only the values:
         *   SIGNAL:     The successor of this node is (or will soon be)
         *               blocked (via park), so the current node must
         *               unpark its successor when it releases or
         *               cancels. To avoid races, acquire methods must
         *               first indicate they need a signal,
         *               then retry the atomic acquire, and then,
         *               on failure, block.
         *               &#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x662F;&#x88AB;&#x963B;&#x585E;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x5728;&#x91CA;&#x653E;&#x6216;&#x8005;&#x53D6;&#x6D88;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5FC5;&#x987B;unpark&#x4ED6;&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x3002;
         *               &#x4E3A;&#x4E86;&#x907F;&#x514D;&#x7ADE;&#x4E89;&#xFF0C;&#x52A0;&#x9501;&#x65B9;&#x6CD5;&#x5FC5;&#x987B;&#x9996;&#x5148;&#x58F0;&#x660E;&#x4ED6;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x4FE1;&#x53F7;&#xFF0C;&#x7136;&#x540E;&#x91CD;&#x8BD5;&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x7684;&#x52A0;&#x9501;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x5931;&#x8D25;&#x65F6;&#x963B;&#x585E;&#x3002;
         *   CANCELLED:  This node is cancelled due to timeout or interrupt.
         *               Nodes never leave this state. In particular,
         *               a thread with cancelled node never again blocks.
         *               &#x5F53;&#x524D;&#x8282;&#x70B9;&#x7531;&#x4E8E;&#x8D85;&#x65F6;&#x6216;&#x8005;&#x4E2D;&#x65AD;&#x88AB;&#x53D6;&#x6D88;&#x3002;
         *               &#x8282;&#x70B9;&#x4ECE;&#x6765;&#x4E0D;&#x4F1A;&#x79BB;&#x5F00;&#x8FD9;&#x4E2A;&#x72B6;&#x6001;&#x3002;&#x7279;&#x522B;&#x662F;&#xFF0C;&#x53D6;&#x6D88;&#x8282;&#x70B9;&#x7684;&#x7EBF;&#x7A0B;&#x6C38;&#x8FDC;&#x4E0D;&#x4F1A;&#x518D;&#x963B;&#x585E;&#x3002;
         *   CONDITION:  This node is currently on a condition queue.
         *               It will not be used as a sync queue node
         *               until transferred, at which time the status
         *               will be set to 0. (Use of this value here has
         *               nothing to do with the other uses of the
         *               field, but simplifies mechanics.)
         *               &#x5F53;&#x524D;&#x8282;&#x70B9;&#x5728;&#x6761;&#x4EF6;&#x961F;&#x5217;&#x4E2D;&#x3002;
         *               &#x5B83;&#x5728;&#x4F20;&#x8F93;&#x4E4B;&#x524D;&#x4E0D;&#x4F1A;&#x7528;&#x4F5C;&#x540C;&#x6B65;&#x8282;&#x70B9;&#xFF0C;&#x5230;&#x90A3;&#x4E2A;&#x65F6;&#x5019;status&#x5C06;&#x88AB;&#x8BBE;&#x7F6E;&#x4E3A;0&#x3002;&#xFF08;&#x5728;&#x8FD9;&#x91CC;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x503C;&#x548C;&#x8FD9;&#x4E2A;&#x5B57;&#x6BB5;&#x7684;&#x5176;&#x4ED6;&#x7528;&#x6CD5;&#x65E0;&#x5173;&#xFF0C;&#x4F46;&#x662F;&#x7B80;&#x5316;&#x4E86;&#x673A;&#x5236;&#xFF09;
         *   PROPAGATE:  A releaseShared should be propagated to other
         *               nodes. This is set (for head node only) in
         *               doReleaseShared to ensure propagation
         *               continues, even if other operations have
         *               since intervened.
         *               &#x5171;&#x4EAB;&#x9501;&#x7684;&#x91CA;&#x653E;&#xFF08;releaseShared&#xFF09;&#x5E94;&#x5F53;&#x4F20;&#x64AD;&#x5230;&#x5176;&#x4ED6;&#x8282;&#x70B9;&#x3002;
         *               &#x8FD9;&#x5728;doReleaseShared&#x4E2D;&#x8BBE;&#x7F6E;&#xFF08;&#x4EC5;&#x9002;&#x7528;&#x4E8E;&#x5934;&#x8282;&#x70B9;&#xFF09;&#x4EE5;&#x786E;&#x4FDD;&#x4F20;&#x64AD;&#x7EE7;&#x7EED;&#xFF0C;&#x5373;&#x4F7F;&#x5176;&#x4ED6;&#x7684;&#x64CD;&#x4F5C;&#x5DF2;&#x7ECF;&#x4ECB;&#x5165;&#x3002;
         *   0:          None of the above
         *               &#x4E0D;&#x5904;&#x4E8E;&#x4EE5;&#x4E0A;&#x60C5;&#x51B5;&#x7684;status&#x503C;&#x5C31;&#x662F;0
         *
         * The values are arranged numerically to simplify use.
         * Non-negative values mean that a node doesn&apos;t need to
         * signal. So, most code doesn&apos;t need to check for particular
         * values, just for sign.
         * &#x503C;&#x6309;&#x6570;&#x5B57;&#x5316;&#x6392;&#x5217;&#x4EE5;&#x7B80;&#x5316;&#x4F7F;&#x7528;&#x3002;&#x975E;&#x8D1F;&#x503C;&#x610F;&#x5473;&#x7740;&#x8282;&#x70B9;&#x4E0D;&#x9700;&#x8981;&#x53D1;&#x51FA;&#x4FE1;&#x53F7;&#x3002;
         * &#x6240;&#x4EE5;&#xFF0C;&#x5927;&#x591A;&#x6570;&#x4EE3;&#x7801;&#x4E0D;&#x9700;&#x8981;&#x68C0;&#x67E5;&#x7279;&#x5B9A;&#x503C;&#xFF0C;&#x53EA;&#x9700;&#x8981;&#x68C0;&#x67E5;&#x7B26;&#x53F7;&#x3002;
         *
         * The field is initialized to 0 for normal sync nodes, and
         * CONDITION for condition nodes.  It is modified using CAS
         * (or when possible, unconditional volatile writes).
         * &#x8BE5;&#x5B57;&#x6BB5;&#x5BF9;&#x4E8E;&#x666E;&#x901A;&#x7684;&#x540C;&#x6B65;&#x8282;&#x70B9;&#x521D;&#x59CB;&#x5316;&#x4E3A;0&#xFF0C;&#x5BF9;&#x4E8E;condition&#x8282;&#x70B9;&#x521D;&#x8BC6;&#x5316;&#x4E3A;CONDIITON&#x3002;&#x4F7F;&#x7528;CAS&#x8FDB;&#x884C;&#x4FEE;&#x6539;&#xFF08;&#x6216;&#x8005;&#x53EF;&#x4EE5;&#x7684;&#x8BDD;&#xFF0C;&#x4F7F;&#x7528;&#x65E0;&#x6761;&#x4EF6;&#x7684;volatile&#x5199;&#x5165;&#xFF09;&#x3002;
         */</span>
        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;

        <span class="hljs-comment">/**
         * Link to predecessor node that current node/thread relies on
         * for checking waitStatus. Assigned during enqueuing, and nulled
         * out (for sake of GC) only upon dequeuing.  Also, upon
         * cancellation of a predecessor, we short-circuit while
         * finding a non-cancelled one, which will always exist
         * because the head node is never cancelled: A node becomes
         * head only as a result of successful acquire. A
         * cancelled thread never succeeds in acquiring, and a thread only
         * cancels itself, not any other node.
         * &#x8FDE;&#x63A5;&#x5230;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;/&#x8282;&#x70B9;&#x4F9D;&#x8D56;&#x68C0;&#x67E5;waitStatus&#x7684;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x3002;
         * &#x5728;&#x5165;&#x961F;&#x671F;&#x95F4;&#x5206;&#x914D;&#xFF0C;&#x5E76;&#x4EC5;&#x5728;&#x51FA;&#x961F;&#x65F6;&#x53D6;&#x6D88;&#xFF08;&#x4E3A;&#x4E86;GC&#xFF09;&#x3002;
         * &#x540C;&#x6837;&#xFF0C;&#x5728;&#x524D;&#x9A71;cancel&#x65F6;&#xFF0C;&#x5F53;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x672A;&#x53D6;&#x6D88;&#x7684;node&#x4E4B;&#x524D;&#x8FDB;&#x884C;&#x77ED;&#x8DEF;&#xFF0C;&#x672A;&#x53D6;&#x6D88;&#x7684;node&#x59CB;&#x7EC8;&#x5B58;&#x5728;&#xFF0C;&#x56E0;&#x4E3A;&#x5934;&#x8282;&#x70B9;&#x4ECE;&#x6765;&#x4E0D;&#x4F1A;cancel&#xFF1A;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x8981;&#x6210;&#x4E3A;&#x5934;&#x7ED3;&#x70B9;&#xFF0C;&#x53EA;&#x6709;&#x6210;&#x529F;&#x83B7;&#x53D6;&#x5230;&#x7ED3;&#x679C;&#x3002;
         * &#x53D6;&#x6D88;&#x7684;&#x7EBF;&#x7A0B;&#x5728;&#x52A0;&#x9501;&#x65F6;&#x6C38;&#x8FDC;&#x4E0D;&#x4F1A;&#x6210;&#x529F;&#xFF0C;&#x5E76;&#x4E14;&#x7EBF;&#x7A0B;&#x53EA;&#x80FD;&#x53D6;&#x6D88;&#x81EA;&#x5DF1;&#xFF0C;&#x4E0D;&#x80FD;&#x53D6;&#x6D88;&#x5176;&#x4ED6;node&#x3002;
         */</span>
        <span class="hljs-keyword">volatile</span> Node prev;

        <span class="hljs-comment">/**
         * Link to the successor node that the current node/thread
         * unparks upon release. Assigned during enqueuing, adjusted
         * when bypassing cancelled predecessors, and nulled out (for
         * sake of GC) when dequeued.  The enq operation does not
         * assign next field of a predecessor until after attachment,
         * so seeing a null next field does not necessarily mean that
         * node is at end of queue. However, if a next field appears
         * to be null, we can scan prev&apos;s from the tail to
         * double-check.  The next field of cancelled nodes is set to
         * point to the node itself instead of null, to make life
         * easier for isOnSyncQueue.
         * &#x8FDE;&#x63A5;&#x5230;&#x5F53;&#x524D;&#x8282;&#x70B9;/&#x7EBF;&#x7A0B;&#x5728;&#x89E3;&#x9501;&#x65F6;&#x9700;&#x8981;unpark&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x3002;
         * &#x5728;&#x5165;&#x961F;&#x65F6;&#x5206;&#x914D;&#xFF0C;&#x5728;&#x7ED5;&#x8FC7;&#x53D6;&#x6D88;&#x7684;&#x524D;&#x9A71;&#x65F6;&#x8C03;&#x6574;&#xFF0C;&#x5728;&#x51FA;&#x961F;&#x65F6;&#x53D6;&#x6D88;&#xFF08;&#x7F6E;&#x4E3A;null&#xFF09;&#xFF08;&#x4E3A;&#x4E86;GC&#xFF09;&#x3002;
         * enq&#x64CD;&#x4F5C;&#x76F4;&#x5230;&#x8FDE;&#x63A5;&#x540E;&#x624D;&#x5206;&#x914D;&#x524D;&#x9A71;&#x7684;next&#x5B57;&#x6BB5;&#xFF0C;&#x56E0;&#x6B64;&#x770B;&#x5230;next&#x5B57;&#x6BB5;&#x4E3A;null&#x65F6;&#x4E0D;&#x4E00;&#x5B9A;&#x610F;&#x5473;&#x7740;&#x8282;&#x70B9;&#x662F;&#x5C3E;&#x7ED3;&#x70B9;&#x3002;
         * &#x7136;&#x800C;&#xFF0C;&#x5982;&#x679C;next&#x5B57;&#x6BB5;&#x4E3A;null&#xFF0C;&#x53EF;&#x4EE5;&#x4ECE;tail&#x5F00;&#x59CB;&#x626B;&#x63CF;&#x4E0A;&#x4E00;&#x4E2A;&#x5B57;&#x6BB5;&#x4EE5;&#x8FDB;&#x884C;&#x4E8C;&#x6B21;&#x68C0;&#x67E5;&#x3002;
         * &#x53D6;&#x6D88;&#x8282;&#x70B9;&#x7684;next&#x5B57;&#x6BB5;&#x6307;&#x5411;&#x8BE5;&#x8282;&#x70B9;&#x81EA;&#x5DF1;&#x800C;&#x4E0D;&#x662F;null&#xFF0C;&#x4EE5;&#x4F7F;isOnSyncQueue&#x7684;&#x5DE5;&#x4F5C;&#x66F4;&#x8F7B;&#x677E;&#x3002;
         */</span>
        <span class="hljs-keyword">volatile</span> Node next;

        <span class="hljs-comment">/**
         * The thread that enqueued this node.  Initialized on
         * construction and nulled out after use.
         * &#x5165;&#x961F;node&#x7684;&#x7EBF;&#x7A0B;&#x3002;
         * &#x5728;&#x6784;&#x9020;&#x65F6;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x5728;&#x4F7F;&#x7528;&#x540E;&#x7F6E;&#x4E3A;null&#x3002;
         */</span>
        <span class="hljs-keyword">volatile</span> Thread thread;

        <span class="hljs-comment">/**
         * Link to next node waiting on condition, or the special
         * value SHARED.  Because condition queues are accessed only
         * when holding in exclusive mode, we just need a simple
         * linked queue to hold nodes while they are waiting on
         * conditions. They are then transferred to the queue to
         * re-acquire. And because conditions can only be exclusive,
         * we save a field by using special value to indicate shared
         * mode.
         * &#x8FDE;&#x63A5;&#x5230;&#x4E0B;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x6761;&#x4EF6;&#xFF08;&#x5728;&#x6761;&#x4EF6;&#x4E0A;&#x7B49;&#x5F85;&#xFF09;&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x6216;&#x8005;&#x7279;&#x6B8A;&#x503C;SHARED&#x3002;
         * &#x56E0;&#x4E3A;&#x6761;&#x4EF6;&#x961F;&#x5217;&#xFF08;condition queues&#xFF09;&#x53EA;&#x6709;&#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x624D;&#x4F1A;&#x88AB;&#x8BBF;&#x95EE;&#xFF0C;&#x6240;&#x4EE5;&#x5F53;&#x4ED6;&#x4EEC;&#x6B63;&#x5728;&#x7B49;&#x5F85;&#x6761;&#x4EF6;&#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x94FE;&#x63A5;&#x961F;&#x5217;&#x6765;&#x4FDD;&#x5B58;&#x8282;&#x70B9;&#x3002;
         * &#x7136;&#x540E;&#x5C06;&#x4ED6;&#x4EEC;&#x8F6C;&#x79FB;&#x5230;&#x4E3B;&#x961F;&#x5217;&#x4E0A;&#x6765;&#x91CD;&#x65B0;&#x52A0;&#x9501;&#x3002;&#x56E0;&#x4E3A;&#x6761;&#x4EF6;&#x53EA;&#x80FD;&#x662F;&#x72EC;&#x5360;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x901A;&#x8FC7;&#x4F7F;&#x7528;&#x7279;&#x6B8A;&#x503C;&#x6765;&#x8868;&#x540D;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x6765;&#x4FDD;&#x5B58;&#x5B57;&#x6BB5;&#x3002;
         */</span>
        Node nextWaiter;

        <span class="hljs-comment">/**
         * Returns true if node is waiting in shared mode.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> nextWaiter == SHARED;
        }

        <span class="hljs-comment">/**
         * Returns previous node, or throws NullPointerException if null.
         * Use when predecessor cannot be null.  The null check could
         * be elided, but is present to help the VM.
         * &#x8FD4;&#x56DE;&#x524D;&#x9A71;&#x8282;&#x70B9;&#xFF0C;&#x5982;&#x679C;&#x524D;&#x9A71;&#x4E3A;&#x7A7A;&#xFF0C;&#x629B;&#x51FA;NullPointerException
         * &#x5F53;&#x524D;&#x9A71;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&#x65F6;&#x4F7F;&#x7528;&#x3002;
         * &#x7A7A;&#x68C0;&#x67E5;&#x53EF;&#x4EE5;&#x7701;&#x7565;&#xFF0C;&#x4F46;&#x662F;&#x5BF9;VM&#x6709;&#x5E2E;&#x52A9;&#x3002;
         *
         * <span class="hljs-doctag">@return</span> the predecessor of this node
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>{
            Node p = prev;
            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> p;
        }

        Node() {    <span class="hljs-comment">// Used to establish initial head or SHARED marker // &#x72EC;&#x5360;&#x7684;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x521D;&#x59CB;&#x5316;&#x5934;&#x7ED3;&#x70B9;&#xFF0C;&#x5171;&#x4EAB;&#x7684;&#x53EF;&#x4EE5;&#x5EFA;&#x7ACB;SHARED&#x6807;&#x8BB0;</span>
        }

        Node(Thread thread, Node mode) {     <span class="hljs-comment">// Used by addWaiter</span>
            <span class="hljs-keyword">this</span>.nextWaiter = mode;
            <span class="hljs-keyword">this</span>.thread = thread;
        }

        Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) { <span class="hljs-comment">// Used by Condition</span>
            <span class="hljs-keyword">this</span>.waitStatus = waitStatus;
            <span class="hljs-keyword">this</span>.thread = thread;
        }
    }

    <span class="hljs-comment">/**
     * Head of the wait queue, lazily initialized.  Except for
     * initialization, it is modified only via method setHead.  Note:
     * If head exists, its waitStatus is guaranteed not to be
     * CANCELLED.
     * &#x7B49;&#x5F85;&#x961F;&#x5217;&#x7684;&#x5934;&#xFF0C;&#x5EF6;&#x8FDF;&#x521D;&#x59CB;&#x5316;&#x3002;
     * &#x9664;&#x4E86;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x53EA;&#x80FD;&#x4F7F;&#x7528;setHead&#x65B9;&#x6CD5;&#x6765;&#x4FEE;&#x6539;
     * &#x63D0;&#x793A;&#xFF1A;&#x5982;&#x679C;head&#x5B58;&#x5728;&#xFF0C;&#x4FDD;&#x8BC1;waitStatus&#x4E0D;&#x662F;CANCELLED
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;

    <span class="hljs-comment">/**
     * Tail of the wait queue, lazily initialized.  Modified only via
     * method enq to add new wait node.
     * &#x7B49;&#x5F85;&#x961F;&#x5217;&#x7684;&#x5C3E;&#x90E8;&#xFF0C;&#x61D2;&#x521D;&#x59CB;&#x5316;&#x3002;
     * &#x53EA;&#x80FD;&#x901A;&#x8FC7;enq&#x65B9;&#x6CD5;&#xFF0C;&#x5728;&#x589E;&#x52A0;&#x65B0;&#x7684;&#x7B49;&#x5F85;node&#x65F6;&#x4FEE;&#x6539;&#x3002;
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;

    <span class="hljs-comment">/**
     * The synchronization state.
     * &#x540C;&#x6B65;&#x72B6;&#x6001;&#xFF08;&#x83B7;&#x53D6;&#x9501;&#x7684;&#x72B6;&#x6001;&#xFF09;&#xFF08;&#x7528;volatile&#x4FEE;&#x9970;&#xFF0C;&#x5185;&#x5B58;&#x53EF;&#x89C1;&#xFF09;
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;

    <span class="hljs-comment">/**
     * Returns the current value of synchronization state.
     * This operation has memory semantics of a {<span class="hljs-doctag">@code</span> volatile} read.
     * state&#x7531;volatile&#x4FEE;&#x9970;&#xFF0C;&#x8FD9;&#x4E2A;&#x64CD;&#x4F5C;&#x6709;&#x5185;&#x5B58;&#x8BFB;&#x7684;&#x8BED;&#x4E49;
     * <span class="hljs-doctag">@return</span> current state value
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> state;
    }

    <span class="hljs-comment">/**
     * Sets the value of synchronization state.
     * This operation has memory semantics of a {<span class="hljs-doctag">@code</span> volatile} write.
     * &#x901A;&#x8FC7;volatile&#x5B9E;&#x73B0;&#x7684;&#x5185;&#x5B58;&#x8BED;&#x4E49;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x5B89;&#x5168;&#xFF0C;&#x53EF;&#x4EE5;&#x7528;&#x4E0B;&#x9762;&#x7684;compareAndSetState&#x65B9;&#x6CD5;&#x3002;
     * &#xFF08;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x901A;&#x5E38;&#x88AB;&#x5B9E;&#x73B0;AQS&#x7684;&#x5B50;&#x7C7B;&#x6765;&#x8C03;&#x7528;&#xFF0C;&#x7531;&#x5B50;&#x7C7B;&#x51B3;&#x5B9A;&#x5982;&#x4F55;&#x66F4;&#x65B0;state&#x503C;&#xFF09;
     *
     * <span class="hljs-doctag">@param</span> newState the new state value
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>{
        state = newState;
    }

    <span class="hljs-comment">/**
     * Atomically sets synchronization state to the given updated
     * value if the current state value equals the expected value.
     * This operation has memory semantics of a {<span class="hljs-doctag">@code</span> volatile} read
     * and write.
     * &#x7528;&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x6765;&#x8BBE;&#x5B9A;state&#x503C;
     * &#xFF08;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x901A;&#x5E38;&#x88AB;&#x5B9E;&#x73B0;AQS&#x7684;&#x5B50;&#x7C7B;&#x6765;&#x8C03;&#x7528;&#xFF0C;&#x7531;&#x5B50;&#x7C7B;&#x51B3;&#x5B9A;&#x5982;&#x4F55;&#x66F4;&#x65B0;state&#x503C;&#xFF09;
     *
     * <span class="hljs-doctag">@param</span> expect the expected value
     * <span class="hljs-doctag">@param</span> update the new value
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if successful. False return indicates that the actual
     *         value was not equal to the expected value.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>{
        <span class="hljs-comment">// See below for intrinsics setup to support this</span>
        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);
    }

    <span class="hljs-comment">// Queuing utilities</span>
    <span class="hljs-comment">// &#x961F;&#x5217;&#x76F8;&#x5173;&#x6709;&#x76CA;&#x64CD;&#x4F5C;</span>

    <span class="hljs-comment">/**
     * The number of nanoseconds for which it is faster to spin
     * rather than to use timed park. A rough estimate suffices
     * to improve responsiveness with very short timeouts.
     * &#x81EA;&#x65CB;&#x6BD4;&#x4F7F;&#x7528;&#x5B9A;&#x65F6;park&#x5177;&#x6709;&#x66F4;&#x5FEB;&#x7684;&#x7EB3;&#x79D2;&#x6570;&#x3002;&#x7C97;&#x7565;&#x4F30;&#x8BA1;&#x6EE1;&#x8DB3;&#x5728;&#x975E;&#x5E38;&#x77ED;&#x7684;&#x8D85;&#x65F6;&#x65F6;&#x95F4;&#x5185;&#x63D0;&#x9AD8;&#x54CD;&#x5E94;&#x3002;
     * &#xFF08;&#x81EA;&#x65CB;&#x7684;&#x65F6;&#x95F4;&#xFF0C;&#x5355;&#x4F4D;&#xFF1A;&#x7EB3;&#x79D2;&#xFF09;
     */</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> spinForTimeoutThreshold = <span class="hljs-number">1000L</span>;

    <span class="hljs-comment">/**
     * Inserts node into queue, initializing if necessary. See picture above.
     * node&#x5165;&#x961F;&#xFF0C;&#x5FC5;&#x8981;&#x7684;&#x8BDD;&#x521D;&#x59CB;&#x5316;&#x3002;&#x4E0A;&#x9762;&#x6709;&#x56FE;&#x3002;
     * <span class="hljs-doctag">@param</span> node the node to insert
     * <span class="hljs-doctag">@return</span> node&apos;s predecessor
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>{
        <span class="hljs-keyword">for</span> (;;) {  <span class="hljs-comment">// &#x8FD9;&#x4E2A;&#x5FAA;&#x73AF;&#x662F;&#x4E3A;&#x4E86;&#xFF0C;&#x5982;&#x679C;CAS&#x52A0;&#x9501;&#x5931;&#x8D25;&#xFF0C;&#x901A;&#x8FC7;&#x5FAA;&#x73AF;&#x6765;&#x91CD;&#x65B0;&#x52A0;&#x9501;&#x6216;&#x8005;&#x6267;&#x884C;&#x5176;&#x4ED6;&#x64CD;&#x4F5C;</span>
            Node t = tail;
            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// Must initialize // &#x961F;&#x5C3E;&#x4E3A;null&#xFF0C;&#x8BF4;&#x660E;&#x73B0;&#x5728;&#x961F;&#x5217;&#x91CC;&#x5565;&#x4E5F;&#x6CA1;&#x6709;&#xFF0C;&#x9700;&#x8981;&#x521D;&#x59CB;&#x5316;&#x961F;&#x5217;&#xFF08;&#x4E3B;&#x8981;&#x5C31;&#x662F;&#x521D;&#x59CB;&#x5316;&#x961F;&#x5217;Head&#x4E0E;Tail&#xFF0C;&#x7528;&#x6765;&#x6307;&#x5411;&#x961F;&#x5217;&#x5934;&#x5C3E;&#xFF09;</span>
                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node())) <span class="hljs-comment">// &#x5982;&#x679C;Head&#x4E3A;null&#xFF0C;&#x5219;&#x8BBE;&#x7F6E;&#x4E3A;New Node()</span>
                    tail = head; <span class="hljs-comment">// &#x65B0;&#x589E;&#x4E00;&#x4E2A;&#x7A7A;&#x8282;&#x70B9;&#xFF0C;&#x5934;&#x548C;&#x5C3E;&#x90FD;&#x6307;&#x5411;&#x540C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;</span>
            } <span class="hljs-keyword">else</span> {
                node.prev = t; <span class="hljs-comment">// &#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;prev&#x6307;&#x5411;&#x5C3E;&#x6307;&#x9488;&#x6307;&#x5411;&#x7684;&#x8282;&#x70B9;</span>
                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) { <span class="hljs-comment">// CAS&#x4FEE;&#x6539;tail&#x6307;&#x5411;&#x7684;&#x8282;&#x70B9;&#x4E3A;&#x5F53;&#x524D;&#x8282;&#x70B9;</span>
                    t.next = node; <span class="hljs-comment">// &#x539F;&#x6765;&#x7684;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;next&#x6307;&#x5411;&#x8FD9;&#x4E2A;node</span>
                    <span class="hljs-keyword">return</span> t;
                }
            }
        }
    }

    <span class="hljs-comment">/**
     * Creates and enqueues node for current thread and given mode.
     * &#x4E3A;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x548C;&#x7ED9;&#x5B9A;&#x6A21;&#x5F0F;&#x521B;&#x5EFA;&#x548C;&#x5165;&#x961F;node
     * &#xFF08;&#x7528;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x521B;&#x5EFA;Node&#xFF0C;&#x6839;&#x636E;&#x6307;&#x5B9A;&#x7684;&#x6A21;&#x5F0F;&#x5165;&#x961F;&#xFF09;
     *
     * <span class="hljs-doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
     * <span class="hljs-doctag">@return</span> the new node
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>{
        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode); <span class="hljs-comment">// addWaiter&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;</span>
        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span>
        <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x7B80;&#x5316;enq&#x8FC7;&#x7A0B;&#xFF1B;</span>
        Node pred = tail; <span class="hljs-comment">// &#x524D;&#x9A71;=tail&#xFF08;&#x6CE8;&#x610F;&#x4E0D;&#x662F;head&#xFF09;</span>
        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) {  <span class="hljs-comment">// &#x6709;tail&#xFF0C;&#x5C31;&#x7B80;&#x5316;enq(...)&#x65B9;&#x6CD5;</span>
            node.prev = pred; <span class="hljs-comment">// node.prev-&gt;tail</span>
            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) { <span class="hljs-comment">// tail -&gt; node</span>
                pred.next = node; <span class="hljs-comment">// &#x539F;&#x6765;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;next&#x6307;&#x5411;&#x8FD9;&#x4E2A;node&#xFF0C;&#x8FD9;&#x4E2A;node&#x7684;next&#x662F;null</span>
                <span class="hljs-keyword">return</span> node;
            }
        }
        enq(node); <span class="hljs-comment">// &#x4E0A;&#x9762;&#x7684;&#x4E0D;&#x884C;&#x518D;&#x8D70;enq&#x65B9;&#x6CD5;</span>
        <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-comment">/**
     * Sets head of queue to be node, thus dequeuing. Called only by
     * acquire methods.  Also nulls out unused fields for sake of GC
     * and to suppress unnecessary signals and traversals.
     * &#x8BBE;&#x7F6E;&#x961F;&#x5217;&#x7684;head&#x4E3A;&#x8BE5;&#x8282;&#x70B9;&#xFF0C;&#x4ECE;&#x800C;&#x51FA;&#x961F;&#x3002;&#x53EA;&#x80FD;&#x901A;&#x8FC7;&#x52A0;&#x9501;&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x3002;
     * &#x5C06;&#x4E0D;&#x4F7F;&#x7528;&#x7684;&#x5B57;&#x6BB5;&#x8BBE;&#x7F6E;&#x4E3A;null&#xFF0C;&#x4E3A;&#x4E86;GC&#x4E0E;&#x6291;&#x5236;&#x4E0D;&#x5FC5;&#x8981;&#x7684;&#x4FE1;&#x53F7;&#x4E0E;&#x904D;&#x5386;&#x3002;
     * &#xFF08;&#x76F8;&#x5F53;&#x4E8E;&#x5728;&#x8BE5;&#x8282;&#x70B9;&#x52A0;&#x9501;&#x6210;&#x529F;&#x65F6;&#xFF08;&#x5C31;&#x662F;&#x6210;&#x529F;&#x83B7;&#x53D6;&#x5230;&#x4E86;&#x9501;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x518D;&#x6392;&#x961F;&#x4E86;&#xFF09;&#xFF0C;&#x628A;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x8BBE;&#x7F6E;&#x4E3A;&#x4E86;&#x539F;&#x6765;&#x7684;&#x865A;&#x62DF;&#x8282;&#x70B9;&#x4F5C;&#x4E3A;head&#xFF09;
     *
     * <span class="hljs-doctag">@param</span> node the node
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>{
        head = node;
        node.thread = <span class="hljs-keyword">null</span>;
        node.prev = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">/**
     * Wakes up node&apos;s successor, if one exists.
     * &#x5982;&#x679C;&#x5B58;&#x5728;&#xFF0C;&#x5524;&#x9192;node&#x7684;&#x540E;&#x7EE7;
     *
     * <span class="hljs-doctag">@param</span> node the node
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>{
        <span class="hljs-comment">/*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         * &#x5982;&#x679C;&#x72B6;&#x6001;&#x4E3A;&#x8D1F;&#x503C;&#xFF08;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x4FE1;&#x53F7;&#x91CF;&#xFF09;&#x5C1D;&#x8BD5;&#x6E05;&#x695A;&#x4EE5;&#x671F;&#x5F85;&#x4FE1;&#x53F7;&#x3002;
         * &#x5982;&#x679C;&#x6E05;&#x9664;&#x72B6;&#x6001;&#x5931;&#x8D25;&#x6216;&#x8005;&#x72B6;&#x6001;&#x5DF2;&#x7ECF;&#x88AB;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#x4FEE;&#x6539;&#x4E86;&#xFF0C;&#x4E5F;&#x6CA1;&#x95EE;&#x9898;&#x3002;
         *
         */</span>
        <span class="hljs-keyword">int</span> ws = node.waitStatus;
        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// &#x53EA;&#x6709;cancelled&#x662F;1&#xFF0C;&#x5176;&#x4ED6;&#x7684;signal&#x3001;condition&#x3001;propagate&#x90FD;&#x662F;&#x8D1F;&#x503C;</span>
            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>); <span class="hljs-comment">// 0&#x5C31;&#x662F;&#x6B63;&#x5E38;&#x7B49;&#x5F85;&#x7684;node&#x7684;waitStatus&#x503C;&#xFF0C;&#x8868;&#x793A;&#x8BE5;&#x8282;&#x70B9;&#x6B63;&#x5728;&#x88AB;&#x64CD;&#x4F5C;&#xFF1F;&#xFF1F;&#xFF1F;&#x5176;&#x4ED6;&#x5173;&#x4E8E;&#x8BE5;&#x8282;&#x70B9;&#x7684;&#x64CD;&#x4F5C;&#x53EF;&#x4EE5;&#x7B49;&#x7B49;</span>

        <span class="hljs-comment">/*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         * unpark&#x7EBF;&#x7A0B;&#x88AB;&#x4FDD;&#x5B58;&#x5728;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x4E2D;&#xFF0C;&#x901A;&#x5E38;&#x662F;next&#x6307;&#x5411;&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x3002;
         * &#x5982;&#x679C;next&#x8282;&#x70B9;&#x88AB;&#x53D6;&#x6D88;&#x6216;&#x8005;&#x660E;&#x663E;&#x4E3A;null&#xFF0C;&#x4ECE;tail&#x56DE;&#x6EAF;&#x627E;&#x5230;&#x5B9E;&#x9645;&#x4E0A;&#x6CA1;&#x6709;&#x53D6;&#x6D88;&#x7684;&#x540E;&#x7EE7;&#x8005;&#xFF08;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4ECE;tail&#x56DE;&#x6EAF;&#xFF1F;&#x56E0;&#x4E3A;next&#x53EF;&#x80FD;&#x662F;null&#xFF0C;&#x6CA1;&#x6CD5;&#x4ECE;&#x524D;&#x904D;&#x5386;&#xFF09;
         */</span>
        Node s = node.next;
        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// &#x540E;&#x7EE7;&#x4E3A;null&#x6216;&#x8005;&#x88AB;&#x53D6;&#x6D88;</span>
            s = <span class="hljs-keyword">null</span>;
            <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="hljs-comment">// &#x627E;&#x5230;&#x79BB;&#x5F53;&#x524D;node&#x6700;&#x8FD1;&#x7684;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x975E;&#x7A7A;&#xFF08;&#x540E;&#x7EE7;&#xFF09;node &#xFF08;&#x5F53;&#x524D;node&#x7684;prev&#x662F;null&#xFF0C;&#x6240;&#x4EE5;&#x627E;&#x5230;&#x5F53;&#x524D;node&#x4E4B;&#x540E;&#x5C31;&#x4F1A;&#x7EC8;&#x6B62;&#xFF09;</span>
                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)
                    s = t;
        }
        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)
            LockSupport.unpark(s.thread); <span class="hljs-comment">// &#x5524;&#x9192;&#x540E;&#x7EE7;&#xFF0C;&#x7ADE;&#x4E89;&#x9501;</span>
    }

    <span class="hljs-comment">/**
     * Release action for shared mode -- signals successor and ensures
     * propagation. (Note: For exclusive mode, release just amounts
     * to calling unparkSuccessor of head if it needs signal.)
     * &#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x7684;&#x91CA;&#x653E;&#xFF08;&#x89E3;&#x9501;&#xFF09;&#x52A8;&#x4F5C; -- &#x4FE1;&#x53F7;&#x901A;&#x77E5;&#x540E;&#x7EE7;&#x8005;&#x5E76;&#x4E14;&#x786E;&#x4FDD;&#x5E7F;&#x64AD;&#x3002;
     * &#xFF08;&#x63D0;&#x793A;&#xFF1A;&#x5BF9;&#x4E8E;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#xFF0C;&#x5982;&#x679C;&#x9700;&#x8981;&#x4FE1;&#x53F7;&#x91CF;&#xFF0C;&#x89E3;&#x9501;&#x53EA;&#x662F;&#x76F8;&#x5F53;&#x4E8E;&#x5524;&#x9192;head&#x7684;&#x540E;&#x7EE7;&#x8005;&#xFF09;
     * &#x8FD9;&#x4E2A;&#x89E3;&#x9501;&#x52A8;&#x4F5C;&#xFF0C;&#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x5C06;&#x8282;&#x70B9;&#x4ECE;park&#x72B6;&#x6001;&#x5524;&#x9192;&#xFF08;&#x8C03;&#x7528;unpark&#xFF09;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x91CA;&#x653E;&#x7ADE;&#x4E89;&#x9501;
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">/*
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         * &#x5373;&#x4F7F;&#x6709;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x6B63;&#x5728;&#x52A0;&#x9501;/&#x89E3;&#x9501;&#xFF0C;&#x4E5F;&#x8981;&#x786E;&#x4FDD;release&#x5E7F;&#x64AD;&#x3002;
         * &#x901A;&#x5E38;&#x5C1D;&#x8BD5;&#x53BB;unpark head&#x7684;&#x540E;&#x7EE7;&#xFF0C;&#x5982;&#x679C;&#x5B83;&#x9700;&#x8981;&#x4FE1;&#x53F7;&#x7684;&#x8BDD;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x8FD9;&#x6837;&#xFF0C;&#x8BBE;&#x7F6E;head&#x7684;&#x540E;&#x7EE7;&#x7684;status&#x4E3A;PROPAGATE&#xFF0C;&#x4EE5;&#x786E;&#x4FDD;release&#x65F6;&#x4F20;&#x64AD;&#x7EE7;&#x7EED;&#x3002;
         * &#x6B64;&#x5916;&#xFF0C;&#x5FC5;&#x987B;loop&#x5FAA;&#x73AF;&#x4EE5;&#x9632;&#x6B62;&#x5728;&#x6211;&#x4EEC;&#x8FD9;&#x6837;&#x505A;&#x65F6;&#x6709;&#x65B0;&#x7684;&#x8282;&#x70B9;&#x52A0;&#x5165;&#x3002;
         * &#x6B64;&#x5916;&#xFF0C;&#x4E0D;&#x540C;&#x4E8E;&#x5176;&#x4ED6;&#x7684;unparkSuccessor&#xFF0C;&#x5FC5;&#x987B;&#x77E5;&#x9053;&#x4F7F;&#x7528;CAS&#x91CD;&#x7F6E;status&#x662F;&#x5426;&#x5931;&#x8D25;&#xFF0C;&#x5982;&#x679C;&#x5931;&#x8D25;&#x5219;&#x91CD;&#x65B0;&#x68C0;&#x67E5;&#x3002;
         */</span>
        <span class="hljs-keyword">for</span> (;;) {
            Node h = head;
            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) {
                <span class="hljs-keyword">int</span> ws = h.waitStatus;
                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) { <span class="hljs-comment">// &#x5F53;&#x524D;node&#x7684;ws&#x4E3A;SIGNAL&#xFF0C;&#x5219;&#x8868;&#x793A;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x9700;&#x8981;&#x4FE1;&#x53F7;&#xFF08;&#x4E5F;&#x5C31;&#x662F;&#x9700;&#x8981;&#x5524;&#x9192;&#x7684;&#x4FE1;&#x53F7;&#xFF09;</span>
                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>)) <span class="hljs-comment">// &#x5C06;head&#x8282;&#x70B9;&#x7684;waitStatus&#x7531;SIGNAL&#x66F4;&#x65B0;&#x4E3A;0</span>
                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases // &#x5FAA;&#x73AF;&#xFF0C;&#x518D;&#x6B21;&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x8BBE;&#x7F6E;&#xFF0C;&#x76F4;&#x5230;head&#x7531;SIGNAL&#x72B6;&#x6001;&#x8F6C;&#x4E3A;0&#xFF08;&#x56E0;&#x4E3A;&#x5F53;&#x524D;&#x961F;&#x5217;&#x53EF;&#x80FD;&#x4F1A;&#x6709;&#x65B0;&#x7684;&#x8282;&#x70B9;&#x51FA;&#x961F;/&#x5165;&#x961F;&#xFF09;</span>
                    unparkSuccessor(h); <span class="hljs-comment">// &#x5524;&#x9192;&#x540E;&#x7EE7;&#x8282;&#x70B9;</span>
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;
                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE)) <span class="hljs-comment">// &#x540E;&#x7EE7;&#x8282;&#x70B9;&#x4E0D;&#x9700;&#x8981;&#x4FE1;&#x53F7;&#x91CF;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x8BBE;&#x7F6E;ws&#x4E3A;PROPAGATE&#xFF0C;&#x786E;&#x4FDD;release&#x7684;&#x65F6;&#x5019;&#x4F20;&#x64AD;&#x7EE7;&#x7EED;</span>
                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span>
            }
            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed // &#x5982;&#x679C;head&#x6CA1;&#x53D8;&#xFF0C;&#x5C31;&#x9000;&#x51FA;</span>
                <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-comment">/**
     * Sets head of queue, and checks if successor may be waiting
     * in shared mode, if so propagating if either propagate &gt; 0 or
     * PROPAGATE status was set.
     * &#x8BBE;&#x7F6E;&#x961F;&#x5217;&#x5934;&#xFF0C;&#x5E76;&#x4E14;&#x68C0;&#x67E5;&#x5B83;&#x7684;&#x540E;&#x7EE7;&#x8005;&#x662F;&#x5426;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#x3002;
     * &#x5982;&#x679C;propagate &gt; 0&#xFF0C;&#x6216;&#x8005;&#x8BBE;&#x7F6E;&#x4E86;PROPAGATE&#x72B6;&#x6001;&#xFF0C;&#x5219;&#x8FDB;&#x884C;&#x4F20;&#x64AD;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> node the node
     * <span class="hljs-doctag">@param</span> propagate the return value from a tryAcquireShared
     * propagate&#x5165;&#x53C2;&#x503C;&#x662F;tryAcquireShared&#x65B9;&#x6CD5;&#x7684;&#x8FD4;&#x56DE;&#x503C;&#x3002;
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>{
        Node h = head; <span class="hljs-comment">// Record old head for check below</span>
        setHead(node); <span class="hljs-comment">// &#x8BBE;&#x7F6E;head&#x6307;&#x5411;node&#xFF0C;&#x5E76;&#x6E05;&#x9664;thread&#x3001;prev&#x7684;&#x503C;&#x4E3A;null&#xFF08;&#x56E0;&#x4E3A;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E00;&#x5B9A;&#x662F;&#x6210;&#x529F;&#x83B7;&#x53D6;&#x5230;&#x9501;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x76F4;&#x63A5;&#x7F6E;&#x4E3A;head&#xFF0C;&#x8868;&#x793A;&#x7EBF;&#x7A0B;&#x5DF2;&#x6267;&#x884C;&#xFF0C;&#x53D8;&#x6210;&#x4E86;&#x865A;&#x62DF;head&#xFF09;</span>
        <span class="hljs-comment">/*
         * Try to signal next queued node if:
         *   Propagation was indicated by caller,
         *     or was recorded (as h.waitStatus either before
         *     or after setHead) by a previous operation
         *     (note: this uses sign-check of waitStatus because
         *      PROPAGATE status may transition to SIGNAL.)
         * and
         *   The next node is waiting in shared mode,
         *     or we don&apos;t know, because it appears null
         *
         * The conservatism in both of these checks may cause
         * unnecessary wake-ups, but only when there are multiple
         * racing acquires/releases, so most need signals now or soon
         * anyway.
         * &#x5C1D;&#x8BD5;&#x5411;&#x4E0B;&#x4E00;&#x4E2A;&#x961F;&#x5217;&#x91CC;&#x7684;node&#x53D1;&#x51FA;&#x4FE1;&#x53F7;&#xFF0C;&#x5982;&#x679C;&#xFF1A;
         * 1. &#x8C03;&#x7528;&#x8005;&#x660E;&#x786E;&#x6307;&#x793A;&#x5E7F;&#x64AD;&#xFF08;Propagation&#xFF09;&#xFF0C;&#x6216;&#x8005;&#x88AB;&#x524D;&#x4E00;&#x4E2A;&#x64CD;&#x4F5C;&#x8BB0;&#x5F55;&#xFF08;&#x4F5C;&#x4E3A;h.waitStataus&#xFF0C;&#x5728;setHead&#x4E4B;&#x524D;&#x6216;&#x8005;&#x4E4B;&#x540E;&#xFF09;&#x3002;&#xFF08;&#x6CE8;&#x610F;&#xFF1A;waitStatus&#x4E0A;&#x7684;&#x4FE1;&#x53F7;&#x68C0;&#x67E5;&#xFF0C;&#x56E0;&#x4E3A;PROPAGATE&#x72B6;&#x6001;&#x53EF;&#x80FD;&#x4F1A;&#x8F6C;&#x5316;&#x4E3A;SIGNAL&#x72B6;&#x6001;&#xFF09;
         * 2. &#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#xFF0C;&#x6216;&#x8005;&#x6211;&#x4EEC;&#x4E0D;&#x77E5;&#x9053;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x770B;&#x8D77;&#x6765;&#x662F;null&#x3002;
         * &#x8FD9;&#x4E2A;&#x4E24;&#x9879;&#x68C0;&#x67E5;&#x7684;&#x4FDD;&#x5B88;&#x6027;&#x53EF;&#x80FD;&#x4F1A;&#x5BFC;&#x81F4;&#x4E0D;&#x5FC5;&#x8981;&#x7684;&#x5524;&#x9192;&#xFF0C;&#x4F46;&#x662F;&#x4EC5;&#x5F53;&#x6709;&#x591A;&#x4E2A;&#x7ADE;&#x4E89;&#x52A0;&#x9501;/&#x89E3;&#x9501;&#x65F6;&#xFF0C;&#x5927;&#x591A;&#x6570;&#x5F88;&#x5FEB;&#x5C31;&#x4F1A;&#x9700;&#x8981;&#x4FE1;&#x53F7;&#x3002;
         */</span>

        <span class="hljs-comment">// h == null &#x7684;&#x5224;&#x65AD;&#x662F;&#x9632;&#x6B62;&#x7A7A;&#x6307;&#x9488;&#x5F02;&#x5E38;&#x3002;</span>
        <span class="hljs-comment">// h.waitStatus &lt; 0&#xFF0C;&#x8868;&#x793A; h &#x5904;&#x4E8E; SIGNAL &#x6216; PROPAGATE &#x72B6;&#x6001;&#xFF0C;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x4E0B;&#x662F; PROPAGATE &#x72B6;&#x6001;&#xFF0C;&#x56E0;&#x4E3A;&#x5728; doReleaseShared &#x65B9;&#x6CD5;&#x4E2D; h &#x72B6;&#x6001;&#x53D8;&#x5316;&#x662F; SIGNAL -&gt; 0 -&gt; PROPAGATE&#x3002;</span>
        <span class="hljs-comment">// &#x90A3;&#x4E48;&#x4E3A;&#x4EC0;&#x4E48; SIGNAL &#x72B6;&#x6001;&#x4E5F;&#x8981;&#x5524;&#x9192;&#x5462;&#xFF1F;&#x8FD9;&#x662F;&#x56E0;&#x4E3A;&#x5728; doAcquireShared &#x4E2D;&#xFF0C;&#x7B2C;&#x4E00;&#x6B21;&#x6CA1;&#x6709;&#x83B7;&#x5F97;&#x8DB3;&#x591F;&#x7684;&#x8D44;&#x6E90;&#x65F6;&#xFF0C;shouldParkAfterFailedAcquire &#x5C06; PROPAGATE &#x72B6;&#x6001;&#x8F6C;&#x6362;&#x6210; SIGNAL&#xFF0C;&#x51C6;&#x5907;&#x963B;&#x585E;&#x7EBF;&#x7A0B;&#xFF0C;</span>
        <span class="hljs-comment">// &#x4F46;&#x662F;&#x7B2C;&#x4E8C;&#x6B21;&#x8FDB;&#x5165;&#x672C;&#x65B9;&#x6CD5;&#x65F6;&#x53D1;&#x73B0;&#x8D44;&#x6E90;&#x521A;&#x597D;&#x591F;&#xFF0C;&#x800C;&#x6B64;&#x65F6; h &#x7684;&#x72B6;&#x6001;&#x662F; SIGNAL &#x72B6;&#x6001;</span>
        <span class="hljs-comment">// (h = head) == null &#x662F;&#x518D;&#x6B21;&#x68C0;&#x67E5;</span>
        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> || 
            (h = head) == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// &#x91CD;&#x65B0;&#x6307;&#x5411;head&#xFF0C;&#x518D;&#x5224;&#x65AD;</span>
            Node s = node.next;
            <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared()) <span class="hljs-comment">// &#x540E;&#x7EE7;&#x4E3A;null&#x6216;&#x8005;&#x540E;&#x7EE7;&#x4E3A;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;</span>
                doReleaseShared(); <span class="hljs-comment">// &#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x7684;&#x89E3;&#x9501;</span>
        }
    }

    <span class="hljs-comment">// Utilities for various versions of acquire</span>
    <span class="hljs-comment">// &#x5404;&#x79CD;&#x7248;&#x672C;&#x7684;&#x52A0;&#x9501;</span>

    <span class="hljs-comment">/**
     * Cancels an ongoing attempt to acquire.
     * &#x53D6;&#x6D88;&#x6B63;&#x5728;&#x8FDB;&#x884C;&#x7684;&#x52A0;&#x9501;&#x5C1D;&#x8BD5;
     *
     * <span class="hljs-doctag">@param</span> node the node
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>{
        <span class="hljs-comment">// Ignore if node doesn&apos;t exist</span>
        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span>;

        node.thread = <span class="hljs-keyword">null</span>;

        <span class="hljs-comment">// Skip cancelled predecessors</span>
        <span class="hljs-comment">// &#x8DF3;&#x8FC7;&#x5DF2;&#x53D6;&#x6D88;&#x7684;&#x524D;&#x9A71;&#xFF08;&#x4E00;&#x4E2A;&#x8981;&#x53D6;&#x6D88;&#x52A0;&#x9501;&#x7684;node&#x4E3A;&#x5565;&#x8FD8;&#x6709;&#x524D;&#x9A71;&#xFF0C;&#x53EF;&#x4EE5;&#x4ECE;&#x4E2D;&#x95F4;&#x53D6;&#x6D88;&#x4E48;&#xFF1F;&#xFF1F;&#xFF1F;&#xFF09;</span>
        Node pred = node.prev;
        <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)
            node.prev = pred = pred.prev; <span class="hljs-comment">// &#x4E0D;&#x65AD;&#x4FEE;&#x6539;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;&#x524D;&#x9A71;</span>

        <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span>
        <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span>
        <span class="hljs-comment">// or signal, so no further action is necessary.</span>
        <span class="hljs-comment">// predNext&#x662F;&#x8981;&#x53D6;&#x6D88;&#x62FC;&#x63A5;&#x7684;&#x660E;&#x663E;&#x8282;&#x70B9;&#xFF08;&#x5C31;&#x662F;&#x8FD9;&#x4E2A;&#x8282;&#x70B9;&#x8981;&#x9000;&#x51FA;&#x961F;&#x5217;&#xFF0C;&#x4E0D;&#x5728;&#x961F;&#x5217;&#x94FE;&#x4E0A;&#xFF09;&#x3002;</span>
        <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709;&#xFF0C;&#x4E0B;&#x9762;&#x7684;CAS&#x5C06;&#x5931;&#x8D25;&#xFF0C;&#x5728;&#x8FD9;&#x79CD;&#x573A;&#x666F;&#x4E0B;&#xFF0C;&#x5728;&#x4E0E;&#x53E6;&#x4E00;&#x4E2A;cancel&#x6216;&#x8005;signal&#x7ADE;&#x4E89;&#x4E2D;&#x8F93;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x9700;&#x8981;&#x91C7;&#x53D6;&#x540E;&#x7EED;&#x64CD;&#x4F5C;&#x3002;</span>
        Node predNext = pred.next;

        <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span>
        <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span>
        <span class="hljs-comment">// Before, we are free of interference from other threads.</span>
        <span class="hljs-comment">// &#x5728;&#x8FD9;&#x91CC;&#x53EF;&#x4F7F;&#x7528;&#x65E0;&#x6761;&#x4EF6;&#x7684;&#x5199;&#x800C;&#x4E0D;&#x662F;&#x7528;CAS</span>
        <span class="hljs-comment">// &#x5728;&#x8FD9;&#x4E2A;&#x539F;&#x5B50;&#x6B65;&#x9AA4;&#x4E4B;&#x540E;&#xFF0C;&#x5176;&#x4ED6;&#x8282;&#x70B9;&#x53EF;&#x4EE5;&#x8DF3;&#x8FC7;&#x6211;&#x4EEC;</span>
        <span class="hljs-comment">// &#x4E4B;&#x524D;&#xFF0C;&#x4E0D;&#x53D7;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x7684;&#x5E72;&#x6270;&#xFF08;waitStatus&#x7531;volatile&#x63D0;&#x4F9B;&#x5185;&#x5B58;&#x53EF;&#x89C1;&#x6027;&#xFF09;</span>
        node.waitStatus = Node.CANCELLED;

        <span class="hljs-comment">// If we are the tail, remove ourselves.</span>
        <span class="hljs-comment">// &#x5982;&#x679C;&#x5F85;&#x53D6;&#x6D88;&#x7684;&#x8282;&#x70B9;&#x662F;&#x5728;&#x961F;&#x5C3E;&#xFF0C;&#x76F4;&#x63A5;&#x79FB;&#x9664;</span>
        <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) { <span class="hljs-comment">// &#x8BBE;&#x7F6E;tail&#x4E3A;&#x8BE5;&#x8282;&#x70B9;&#x7684;&#x524D;&#x9A71;&#x8282;&#x70B9;</span>
            compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// &#x5C06;&#x8BE5;&#x8282;&#x70B9;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;next&#x8BBE;&#x7F6E;&#x4E3A;null&#xFF08;&#x65AD;&#x5F00;&#x4E0E;&#x8BE5;&#x8282;&#x70B9;&#x7684;&#x5173;&#x8054;&#xFF0C;&#x4E3A;&#x4E86;GC&#x4E0E;&#x5176;&#x4ED6;&#x64CD;&#x4F5C;&#xFF09;</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// If successor needs signal, try to set pred&apos;s next-link</span>
            <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span>
            <span class="hljs-comment">// &#x5982;&#x679C;&#x5F85;&#x53D6;&#x6D88;&#x7684;&#x8282;&#x70B9;&#x4E0D;&#x5728;&#x961F;&#x5C3E;&#xFF08;&#x5728;&#x961F;&#x5217;&#x4E2D;&#x95F4;&#xFF08;&#x4E0D;&#x80FD;&#x4E3A;&#x961F;&#x9996;&#xFF0C;&#x56E0;&#x4E3A;&#x961F;&#x9996;&#x662F;&#x4E2A;&#x865A;&#x62DF;&#x8282;&#x70B9;&#xFF09;&#xFF09;</span>
            <span class="hljs-comment">// &#x5982;&#x679C;&#x540E;&#x7EE7;&#x9700;&#x8981;signal&#xFF0C;&#x5C1D;&#x8BD5;&#x8BBE;&#x7F6E;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x8FDE;&#x63A5;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x4F1A;&#x5F97;&#x5230;&#x4E00;&#x4E2A;&#x3002;</span>
            <span class="hljs-comment">// &#x5426;&#x5219;&#x5524;&#x9192;&#x5B83;&#x8FDB;&#x884C;&#x5E7F;&#x64AD;&#xFF08;propagate&#xFF09;</span>
            <span class="hljs-keyword">int</span> ws;
            <span class="hljs-keyword">if</span> (pred != head &amp;&amp; <span class="hljs-comment">// &#x5982;&#x679C;&#x8BE5;&#x8282;&#x70B9;&#x524D;&#x9762;&#x662F;&#x961F;&#x9996;&#xFF0C;&#x8BF4;&#x660E;&#x5B83;&#x524D;&#x9762;&#x6CA1;&#x6709;&#x7B49;&#x5F85;&#x7684;&#x8282;&#x70B9;&#x4E86;</span>
                ((ws = pred.waitStatus) == Node.SIGNAL || <span class="hljs-comment">// &#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;ws&#x672C;&#x6765;&#x5C31;&#x662F;SIGNAL</span>
                 (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="hljs-comment">// &#x524D;&#x9A71;&#x8282;&#x70B9;&#x72B6;&#x6001;&#x975E;&#x9ED8;&#x8BA4;&#x4E0E;&#x53D6;&#x6D88;&#xFF0C;&#x5E76;&#x4E14;&#x66F4;&#x65B0;&#x524D;&#x9A71;&#x7684;ws&#x4E3A;SIGNAL&#x6210;&#x529F;</span>
                pred.thread != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// &#x524D;&#x9A71;&#x8282;&#x70B9;&#x91CC;&#x7EBF;&#x7A0B;&#x4E0D;&#x4E3A;null</span>
                Node next = node.next;
                <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// &#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x4E0D;&#x662F;&#x7A7A;&#xFF0C;&#x5E76;&#x4E14;&#x6CA1;&#x6709;&#x53D6;&#x6D88;</span>
                    compareAndSetNext(pred, predNext, next); <span class="hljs-comment">// &#x8BBE;&#x7F6E;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x7684;next&#x6307;&#x5411;&#x8BE5;&#x8282;&#x70B9;&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;</span>
            } <span class="hljs-keyword">else</span> {
                unparkSuccessor(node); <span class="hljs-comment">// &#x8FD9;&#x4E2A;&#x5426;&#x5219;&#x5F88;&#x7075;&#x6027;&#xFF0C;&#x5982;&#x679C;&#x8BE5;&#x8282;&#x70B9;&#x662F;head&#x4E4B;&#x540E;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#xFF08;&#x6216;&#x8005;&#x662F;&#x4E0A;&#x9762;&#x7684;&#x6761;&#x4EF6;&#x4E0D;&#x6EE1;&#x8DB3;&#xFF09;&#x90A3;&#x4E48;&#x5B83;&#x53D6;&#x6D88;&#x4E4B;&#x540E;&#x5C31;&#x5F97;&#x76F4;&#x63A5;&#x5524;&#x9192;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x4E86;&#x3002;</span>
            }

            node.next = node; <span class="hljs-comment">// help GC // &#x6253;&#x65AD;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x4E0E;&#x5176;&#x4ED6;&#x8282;&#x70B9;&#x7684;&#x5173;&#x8054;&#xFF0C;&#x65B9;&#x4FBF;GC</span>
        }
    }

    <span class="hljs-comment">/**
     * Checks and updates status for a node that failed to acquire.
     * Returns true if thread should block. This is the main signal
     * control in all acquire loops.  Requires that pred == node.prev.
     * &#x68C0;&#x67E5;&#x548C;&#x66F4;&#x65B0;&#x52A0;&#x9501;&#x5931;&#x8D25;&#x7684;&#x8282;&#x70B9;&#x72B6;&#x6001;&#x3002;
     * &#x5982;&#x679C;&#x7EBF;&#x7A0B;&#x9700;&#x8981;&#x963B;&#x585E;&#xFF0C;&#x8FD4;&#x56DE;true&#x3002;&#x8FD9;&#x662F;&#x5728;&#x6240;&#x6709;&#x52A0;&#x9501;&#x5FAA;&#x73AF;&#x4E2D;&#x4E3B;&#x8981;&#x7684;&#x4FE1;&#x53F7;&#x63A7;&#x5236;&#x3002;
     * &#x8981;&#x6C42;pred == node.prev
     *
     * <span class="hljs-doctag">@param</span> pred node&apos;s predecessor holding status // &#x8282;&#x70B9;&#x7684;&#x524D;&#x9A71;&#x6301;&#x6709;&#x72B6;&#x6001;
     * <span class="hljs-doctag">@param</span> node the node // &#x5F53;&#x524D;&#x8282;&#x70B9;
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if thread should block
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>{
        <span class="hljs-keyword">int</span> ws = pred.waitStatus;
        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)
            <span class="hljs-comment">/*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             * &#x8BE5;node&#x5DF2;&#x7ECF;&#x8BBE;&#x7F6E;&#x4E86;status&#xFF0C;&#x8981;&#x6C42;&#x89E3;&#x9501;&#x65F6;&#x901A;&#x77E5;&#x5B83;&#xFF08;&#x8FD9;&#x4E2A;&#x7FFB;&#x8BD1;&#x4E0D;&#x4E00;&#x5B9A;&#x51C6;&#xFF0C;&#x7B49;&#x770B;&#x5177;&#x4F53;&#x8C03;&#x7528;&#xFF09;&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x53EF;&#x4EE5;&#x5B89;&#x5168;park&#x3002;
             */</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">/*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             * &#x524D;&#x9A71;&#x8282;&#x70B9;&#x5DF2;&#x7ECF;&#x53D6;&#x6D88;&#x4E86;&#x3002;&#x8DF3;&#x8FC7;&#x53D6;&#x6D88;&#x8282;&#x70B9;&#x91CD;&#x8BD5;&#x627E;&#x5230;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x3002;
             */</span>
            do {
                node.prev = pred = pred.prev;
            } <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);
            pred.next = node;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don&apos;t park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             * &#x5230;&#x4E86;&#x8FD9;&#x91CC;waitStatus&#x4E00;&#x5B9A;&#x662F;0&#x6216;&#x8005;PROPAGATE&#xFF08;-3&#xFF09;&#x3002;&#x58F0;&#x660E;&#x9700;&#x8981;&#x4E00;&#x4E2A;signal&#xFF0C;&#x4F46;park&#x8FD8;&#x6CA1;&#x6709;&#x6267;&#x884C;&#x3002;&#xFF1F;&#xFF1F;&#xFF1F;
             * &#x8C03;&#x7528;&#x8005;&#x5E94;&#x8BE5;&#x91CD;&#x8BD5;&#x4EE5;&#x786E;&#x4FDD;&#x5728;park&#x524D;&#x65E0;&#x6CD5;&#x52A0;&#x9501;&#xFF1F;&#xFF1F;&#xFF1F;
             */</span>
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">/**
     * Convenience method to interrupt current thread.
     * &#x4E2D;&#x65AD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;&#x4FBF;&#x6377;&#xFF08;convenience&#xFF09;&#x65B9;&#x6CD5;
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>{
        Thread.currentThread().interrupt();
    }

    <span class="hljs-comment">/**
     * Convenience method to park and then check if interrupted
     * park&#x548C;&#x4E4B;&#x540E;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x4E2D;&#x65AD;&#x7684;&#x4FBF;&#x6377;&#x65B9;&#x6CD5;
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if interrupted
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>{
        LockSupport.park(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// park&#x4F1A;&#x54CD;&#x5E94;&#x4E2D;&#x65AD;&#xFF0C;&#x4E2D;&#x65AD;&#x53D1;&#x751F;&#x65F6;&#x4F1A;&#x8BBE;&#x7F6E;interrupted&#x503C;&#xFF0C;&#x4E0D;&#x4F1A;&#x629B;&#x51FA;&#x5F02;&#x5E38;</span>
        <span class="hljs-keyword">return</span> Thread.interrupted(); <span class="hljs-comment">// &#x8FD4;&#x56DE;&#x68C0;&#x67E5;&#x5230;&#x7684;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x5E76;&#x6E05;&#x9664;&#x4E2D;&#x65AD;&#x72B6;&#x6001;</span>
    }

    <span class="hljs-comment">/*
     * Various flavors of acquire, varying in exclusive/shared and
     * control modes.  Each is mostly the same, but annoyingly
     * different.  Only a little bit of factoring is possible due to
     * interactions of exception mechanics (including ensuring that we
     * cancel if tryAcquire throws exception) and other control, at
     * least not without hurting performance too much.
     * &#x4E0D;&#x540C;&#x5F62;&#x5F0F;&#x7684;&#x52A0;&#x9501;&#xFF0C;&#x5728;&#x72EC;&#x5360;/&#x5171;&#x4EAB;&#x548C;&#x63A7;&#x5236;&#x6A21;&#x5F0F;&#x4E0B;&#x5404;&#x6709;&#x4E0D;&#x540C;&#x3002;
     * &#x6BCF;&#x4E00;&#x4E2A;&#x90FD;&#x5927;&#x81F4;&#x76F8;&#x540C;&#xFF0C;&#x4F46;&#x603B;&#x6709;&#x4E0D;&#x540C;&#xFF08;annoyingly &#x607C;&#x4EBA;&#x7684;&#xFF09;&#x3002;
     * &#x7531;&#x4E8E;&#x5F02;&#x5E38;&#x673A;&#x5236;&#xFF08;&#x5305;&#x62EC;&#x786E;&#x4FDD;&#x6211;&#x4EEC;&#x5728;tryAcquire&#x629B;&#x51FA;&#x7684;&#x5F02;&#x5E38;&#x65F6;cancel&#xFF09;&#x548C;&#x5176;&#x4ED6;&#x63A7;&#x5236;&#x7684;&#x76F8;&#x4E92;&#x4F5C;&#x7528;&#xFF0C;&#x53EA;&#x80FD;&#x8FDB;&#x884C;&#x4E00;&#x70B9;&#x70B9;&#x5206;&#x89E3;&#xFF0C;&#x81F3;&#x5C11;&#x5728;&#x4E0D;&#x4F1A;&#x8FC7;&#x591A;&#x635F;&#x8017;&#x6027;&#x80FD;&#x7684;&#x524D;&#x63D0;&#x4E0B;&#x8FDB;&#x884C;&#x3002;
     *
     */</span>

    <span class="hljs-comment">/**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     * &#x5BF9;&#x4E8E;&#x5DF2;&#x7ECF;&#x5728;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7EBF;&#x7A0B;&#xFF0C;&#x5728;&#x72EC;&#x5360;&#x975E;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;&#x3002;
     * &#x7531;&#x6761;&#x4EF6;&#x7B49;&#x5F85;&#x65B9;&#x6CD5;&#x4F7F;&#x7528;&#x4E5F;&#x80FD;&#x52A0;&#x9501;&#xFF1F;&#xFF1F;&#xFF1F; 
     *
     * <span class="hljs-doctag">@param</span> node the node
     * <span class="hljs-doctag">@param</span> arg the acquire argument
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if interrupted while waiting // &#x5982;&#x679C;&#x5728;&#x7B49;&#x5F85;&#x65F6;&#x4E2D;&#x65AD;&#xFF0C;&#x8FD4;&#x56DE;true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">for</span> (;;) { <span class="hljs-comment">// &#x5982;&#x679C;&#x52A0;&#x9501;&#x5931;&#x8D25;&#xFF0C;&#x8FD9;&#x4E2A;for&#x5565;&#x65F6;&#x5019;&#x4F1A;&#x9000;&#x51FA;&#x5462;&#xFF1F;&#xFF1F;&#xFF1F;</span>
                <span class="hljs-keyword">final</span> Node p = node.predecessor();
                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) { <span class="hljs-comment">// &#x5982;&#x679C;&#x524D;&#x9A71;&#x662F;head&#xFF0C;&#x5E76;&#x4E14;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x72EC;&#x5360;&#x9501;&#x6210;&#x529F;</span>
                    setHead(node);  <span class="hljs-comment">// &#x5C06;&#x5F53;&#x524D;node&#x8F6C;&#x79FB;&#x4E3A;head</span>
                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC // &#x539F;&#x6765;head&#x7684;next&#x6307;&#x5411;null&#xFF0C;&#x65AD;&#x5F00;head&#x7684;&#x8FDE;&#x63A5;&#xFF0C;&#x51C6;&#x5907;&#x56DE;&#x6536;&#x539F;head</span>
                    failed = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// &#x52A0;&#x9501;&#x5931;&#x8D25;&#x72B6;&#x6001;&#x4E3A;false&#xFF08;&#x8868;&#x793A;&#x83B7;&#x53D6;&#x9501;&#x6210;&#x529F;&#xFF09;</span>
                    <span class="hljs-keyword">return</span> interrupted; <span class="hljs-comment">// &#x83B7;&#x53D6;&#x9501;&#x6210;&#x529F;&#x4E86;&#xFF0C;&#x8FD4;&#x56DE;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#x72B6;&#x6001;</span>
                }
                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="hljs-comment">// &#x5224;&#x65AD;&#x5728;&#x83B7;&#x53D6;&#x9501;&#x5931;&#x8D25;&#x540E;&#x662F;&#x5426;&#x9700;&#x8981;park</span>
                    parkAndCheckInterrupt())                 <span class="hljs-comment">// &#x5982;&#x679C;&#x9700;&#x8981;park&#xFF0C;&#x8FDB;&#x884C;park&#x5E76;&#x4E14;&#x68C0;&#x67E5;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF08;&#x5982;&#x679C;&#x7EBF;&#x7A0B;&#x4E3A;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x8FD4;&#x56DE;true&#xFF09;&#xFF08;&#x56E0;&#x4E3A;park&#x80FD;&#x54CD;&#x5E94;&#x4E2D;&#x65AD;&#xFF0C;&#x4E2D;&#x65AD;&#x65F6;&#x4F1A;&#x9000;&#x51FA;park&#xFF09;</span>
                    interrupted = <span class="hljs-keyword">true</span>;                     <span class="hljs-comment">// &#x80FD;&#x8FDB;&#x5230;&#x8FD9;&#x91CC;&#x8BF4;&#x660E;&#x5DF2;&#x7ECF;&#x8BBE;&#x7F6E;&#x4E86;park&#xFF08;&#x963B;&#x585E;&#xFF09;&#xFF0C;&#x5E76;&#x4E14;&#x5728;park&#x7B49;&#x5F85;&#x65F6;&#x53D1;&#x751F;&#x4E86;&#x4E2D;&#x65AD;&#xFF0C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#x4E3A;true&#x3002;&#xFF08;&#x8FD9;&#x91CC;true&#x4E5F;&#x4E0D;&#x4F1A;&#x76F4;&#x63A5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#xFF0C;&#x800C;&#x662F;&#x7EE7;&#x7EED;&#x53BB;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x9501;&#xFF09;</span>
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (failed)
                cancelAcquire(node); <span class="hljs-comment">// &#x5565;&#x65F6;&#x5019;&#x4F1A;&#x8D70;&#x5230;&#x8FD9;&#x91CC;&#x5462;&#xFF1F;&#xFF1F;&#xFF1F;</span>
        }
    }

    <span class="hljs-comment">/**
     * Acquires in exclusive interruptible mode.
     * &#x5728;&#x72EC;&#x5360;&#x53EF;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;
     * <span class="hljs-doctag">@param</span> arg the acquire argument
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span>
        <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="hljs-comment">// &#x8FD4;&#x56DE;&#x7528;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5C01;&#x88C5;&#x7684;node</span>
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (;;) {
                <span class="hljs-keyword">final</span> Node p = node.predecessor();
                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) { <span class="hljs-comment">// tryAcquire()&#x65B9;&#x6CD5;&#x9700;&#x8981;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#xFF0C;&#x6765;&#x51B3;&#x5B9A;&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x9501;&#x7684;&#x8BED;&#x4E49;&#xFF0C;&#x5728;AQS&#x91CC;&#x6CA1;&#x6709;&#x963B;&#x585E;/&#x975E;&#x963B;&#x585E;&#x7684;&#x6982;&#x5FF5;</span>
                    setHead(node);
                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                    failed = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException(); <span class="hljs-comment">// &#x5982;&#x679C;&#x68C0;&#x67E5;&#x5230;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;</span>
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (failed)
                cancelAcquire(node); <span class="hljs-comment">// &#x5565;&#x65F6;&#x5019;&#x4F1A;&#x8D70;&#x5230;&#x8FD9;&#x91CC;&#x5462;&#xFF1F;&#xFF1F;&#xFF1F;</span>
        }
    }

    <span class="hljs-comment">/**
     * Acquires in exclusive timed mode.
     * &#x5728;&#x72EC;&#x5360;&#x9650;&#x65F6;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument
     * <span class="hljs-doctag">@param</span> nanosTimeout max wait time // &#x6700;&#x5927;&#x7B49;&#x5F85;&#x65F6;&#x95F4;
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if acquired // &#x6210;&#x529F;&#x52A0;&#x9501;&#x8FD4;&#x56DE;true
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// &#x5BF9;&#x4E8E;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&lt;=0&#x7684;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;false</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="hljs-comment">// &#x751F;&#x6210;&#x622A;&#x6B62;&#x65F6;&#x95F4;</span>
        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (;;) {
                <span class="hljs-keyword">final</span> Node p = node.predecessor();
                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                    failed = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                }
                nanosTimeout = deadline - System.nanoTime(); <span class="hljs-comment">// &#x68C0;&#x67E5;&#x5269;&#x4F59;&#x7684;&#x7B49;&#x5F85;&#x65F6;&#x95F4;</span>
                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// &#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x4E0D;&#x591F;&#xFF0C;&#x8FD4;&#x56DE;false</span>
                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    nanosTimeout &gt; spinForTimeoutThreshold) <span class="hljs-comment">// &#x5982;&#x679C;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#xFF08;&#x76F8;&#x5F53;&#x4E8E;&#x9884;&#x4F30;&#x7684;&#x8FD8;&#x9700;&#x8981;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#xFF09;&gt; &#x81EA;&#x65CB;&#x7684;&#x65F6;&#x95F4;&#x9608;&#x503C;&#xFF0C;&#x5C31;&#x8FDB;&#x5165;park&#xFF08;&#x5982;&#x679C;&#x9884;&#x4F30;&#x65F6;&#x95F4;&#x5C0F;&#x4E8E;&#x81EA;&#x65CB;&#x7684;&#x9608;&#x503C;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x81EA;&#x65CB;&#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#xFF09;&#x3002;</span>
                    <span class="hljs-comment">// &#x8FD9;&#x91CC;&#x8868;&#x660E;&#xFF0C;&#x5982;&#x679C;&#x7ED9;&#x4E00;&#x4E2A;&#x8F83;&#x5C0F;&#x7684;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x4E0D;&#x65AD;&#x7684;&#x901A;&#x8FC7;&#x81EA;&#x65CB;&#x6765;&#x52A0;&#x9501;&#xFF08;&#x5F53;&#x7136;&#x4E5F;&#x4F1A;&#x56E0;&#x4E3A;&#x81EA;&#x65CB;&#x52A0;&#x9501;&#x5931;&#x8D25;&#xFF0C;&#x9700;&#x8981;&#x4E0D;&#x65AD;&#x8C03;&#x7528;&#x52A0;&#x9501;&#x7684;&#x6D88;&#x8017;&#xFF09;</span>
                    LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);
                <span class="hljs-keyword">if</span> (Thread.interrupted())
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (failed)
                cancelAcquire(node);
        }
    }

    <span class="hljs-comment">/**
     * Acquires in shared uninterruptible mode.
     * &#x5728;&#x5171;&#x4EAB;&#x975E;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;
     * <span class="hljs-doctag">@param</span> arg the acquire argument
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">for</span> (;;) {
                <span class="hljs-keyword">final</span> Node p = node.predecessor();
                <span class="hljs-keyword">if</span> (p == head) {
                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg); <span class="hljs-comment">// &#x9700;&#x8981;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684;5&#x5927;&#x65B9;&#x6CD5;&#x4E4B;&#x4E00;&#xFF0C;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x5C1D;&#x8BD5;&#x52A0;&#x9501;&#x3002;&#x8D1F;&#x503C;&#x8868;&#x793A;&#x5931;&#x8D25;&#xFF0C;0&#x8868;&#x793A;&#x5F53;&#x524D;&#x6210;&#x529F;&#xFF0C;&#x4F46;&#x540E;&#x7EE7;&#x7684;&#x7EBF;&#x7A0B;&#x4EEC;&#x52A0;&#x9501;&#x53EF;&#x80FD;&#x4F1A;&#x5931;&#x8D25;&#xFF0C;&#x6B63;&#x503C;&#x8868;&#x793A;&#x5F53;&#x524D;&#x6210;&#x529F;&#xFF0C;&#x540E;&#x7EE7;&#x7684;&#x7EBF;&#x7A0B;&#x4EEC;&#x52A0;&#x9501;&#x4E5F;&#x53EF;&#x80FD;&#x6210;&#x529F;</span>
                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) {
                        setHeadAndPropagate(node, r); <span class="hljs-comment">// &#x5C06;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x8BBE;&#x7F6E;&#x4E3A;&#x5934;&#x7ED3;&#x70B9;&#xFF08;&#x8868;&#x793A;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x5DF2;&#x6210;&#x529F;&#x83B7;&#x53D6;&#x5230;&#x9501;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x5176;&#x4ED6;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#x4E5F;&#x80FD;&#x83B7;&#x53D6;&#x5230;&#x9501;&#xFF08;&#x6BD5;&#x7ADF;&#x662F;&#x4E2A;&#x5171;&#x4EAB;&#x9501;&#xFF09;&#xFF0C;&#x4E5F;&#x4F1A;&#x88AB;&#x4ECE;park&#x5524;&#x9192;</span>
                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                        <span class="hljs-keyword">if</span> (interrupted)
                            selfInterrupt(); <span class="hljs-comment">// &#x5982;&#x679C;&#x68C0;&#x6D4B;&#x5230;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#xFF0C;&#x8C03;&#x7528;&#x4E2D;&#x65AD;&#x65B9;&#x6CD5;&#xFF08;&#x53EA;&#x662F;&#x5199;&#x4E86;&#x4E2A;&#x4E2D;&#x65AD;&#x6807;&#x8BB0;&#xFF0C;&#x6CA1;&#x6709;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#xFF09;</span>
                        failed = <span class="hljs-keyword">false</span>;
                        <span class="hljs-keyword">return</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt()) <span class="hljs-comment">// &#x68C0;&#x6D4B;&#x7EBF;&#x7A0B;&#x662F;&#x5426;&#x88AB;&#x4E2D;&#x65AD;</span>
                    interrupted = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// &#x5982;&#x679C;&#x5224;&#x65AD;&#x5728;&#x52A0;&#x9501;&#x5931;&#x8D25;&#x65F6;&#x9700;&#x8981;&#x963B;&#x585E;&#xFF08;park&#xFF09;&#xFF0C;&#x5E76;&#x4E14;&#x963B;&#x585E;&#x540E;&#x68C0;&#x6D4B;&#x5230;&#x7EBF;&#x7A0B;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x66F4;&#x65B0;&#x5F53;&#x524D;&#x4E2D;&#x65AD;&#x6807;&#x8BB0;&#x4E3A;true</span>
            }
        } <span class="hljs-keyword">finally</span> { <span class="hljs-comment">// &#x4E0D;&#x77E5;&#x9053;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x4F1A;&#x8D70;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x53EF;&#x80FD;&#x662F;&#x4E2D;&#x65AD;&#x7684;&#x65F6;&#x5019;&#xFF1F;&#xFF1F;&#xFF1F;</span>
            <span class="hljs-keyword">if</span> (failed)
                cancelAcquire(node);
        }
    }

    <span class="hljs-comment">/**
     * Acquires in shared interruptible mode.
     * &#x5728;&#x5171;&#x4EAB;&#x53EF;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;
     * <span class="hljs-doctag">@param</span> arg the acquire argument
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span>
        <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (;;) {
                <span class="hljs-keyword">final</span> Node p = node.predecessor();
                <span class="hljs-keyword">if</span> (p == head) {
                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);
                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) {
                        setHeadAndPropagate(node, r);
                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                        failed = <span class="hljs-keyword">false</span>;
                        <span class="hljs-keyword">return</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException(); <span class="hljs-comment">// &#x4E0E;&#x4E0A;&#x9762;&#x4E0D;&#x540C;&#x7684;&#x5C31;&#x5728;&#x8FD9;&#x91CC;&#xFF0C;&#x5982;&#x679C;&#x68C0;&#x6D4B;&#x5230;&#x4E86;&#x4E2D;&#x65AD;&#xFF0C;&#x76F4;&#x63A5;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;</span>
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (failed)
                cancelAcquire(node);
        }
    }

    <span class="hljs-comment">/**
     * Acquires in shared timed mode.
     * &#x5728;&#x5171;&#x4EAB;&#x9650;&#x65F6;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument
     * <span class="hljs-doctag">@param</span> nanosTimeout max wait time
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if acquired
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;
        <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (;;) {
                <span class="hljs-keyword">final</span> Node p = node.predecessor();
                <span class="hljs-keyword">if</span> (p == head) {
                    <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);
                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) {
                        setHeadAndPropagate(node, r);
                        p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                        failed = <span class="hljs-keyword">false</span>;
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                    }
                }
                nanosTimeout = deadline - System.nanoTime();
                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    nanosTimeout &gt; spinForTimeoutThreshold)
                    LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);
                <span class="hljs-keyword">if</span> (Thread.interrupted())
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException(); <span class="hljs-comment">// &#x540C;&#x6837;&#x7684;&#xFF0C;&#x4E5F;&#x4F1A;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;</span>
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (failed)
                cancelAcquire(node);
        }
    }

    <span class="hljs-comment">// Main exported methods</span>
    <span class="hljs-comment">// &#x4E3B;&#x8981;&#x5BF9;&#x5916;&#x65B9;&#x6CD5;&#xFF08;&#x4E0A;&#x9762;&#x90A3;&#x4E9B;&#x90FD;&#x662F;private&#x7684;&#x65B9;&#x6CD5;&#xFF09;</span>

    <span class="hljs-comment">// &#x4E0B;&#x9762;&#x8FD9;5&#x4E2A;protected&#x65B9;&#x6CD5;&#x9700;&#x8981;&#x5B50;&#x7C7B;&#x6765;&#x5B9E;&#x73B0;</span>
    <span class="hljs-comment">/**
     * Attempts to acquire in exclusive mode. This method should query
     * if the state of the object permits it to be acquired in the
     * exclusive mode, and if so to acquire it.
     * &#x5C1D;&#x8BD5;&#x4EE5;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x52A0;&#x9501;&#x3002;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x5E94;&#x5F53;&#x68C0;&#x67E5;&#x5BF9;&#x8C61;&#x7684;&#x72B6;&#x6001;&#x662F;&#x5426;&#x5141;&#x8BB8;&#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;&#xFF0C;&#x5982;&#x679C;&#x5141;&#x8BB8;&#x5219;&#x52A0;&#x9501;
     *
     * &lt;p&gt;This method is always invoked by the thread performing
     * acquire.  If this method reports failure, the acquire method
     * may queue the thread, if it is not already queued, until it is
     * signalled by a release from some other thread. This can be used
     * to implement method {<span class="hljs-doctag">@link</span> Lock#tryLock()}.
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x603B;&#x662F;&#x88AB;&#x6267;&#x884C;&#x52A0;&#x9501;&#xFF08;acquire&#xFF09;&#x7684;&#x7EBF;&#x7A0B;&#x8C03;&#x7528;&#x3002;
     * &#x5982;&#x679C;&#x6B64;&#x65B9;&#x6CD5;&#x62A5;&#x544A;&#x5931;&#x8D25;&#xFF0C;&#x8FD9;&#x4E2A;acquire&#x65B9;&#x6CD5;&#x53EF;&#x80FD;&#x4F1A;&#x5C06;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF08;&#x5982;&#x679C;&#x8BE5;&#x7EBF;&#x7A0B;&#x8FD8;&#x6CA1;&#x6709;&#x5165;&#x961F;&#xFF09;&#xFF0C;&#x76F4;&#x5230;&#x5B83;&#x88AB;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x53D1;&#x51FA;release&#xFF08;&#x91CA;&#x653E;&#xFF09;&#x4FE1;&#x53F7;&#x3002;
     * &#x53EF;&#x4EE5;&#x901A;&#x8FC7;tryLock()&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#x3002;
     *
     * &lt;p&gt;The default
     * implementation throws {<span class="hljs-doctag">@link</span> UnsupportedOperationException}.
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument. This value is always the one
     *        passed to an acquire method, or is the value saved on entry
     *        to a condition wait.  The value is otherwise uninterpreted
     *        and can represent anything you like.
     *        &#x52A0;&#x9501;&#x53C2;&#x6570;&#x3002;&#x8BE5;&#x503C;&#x59CB;&#x7EC8;&#x662F;&#x4F20;&#x9012;&#x7ED9;acquire&#x65B9;&#x6CD5;&#x7684;&#x503C;&#xFF0C;&#x6216;&#x8005;&#x662F;&#x8FDB;&#x5165;&#x6761;&#x4EF6;&#x7B49;&#x5F85;&#x65F6;&#x4FDD;&#x5B58;&#x7684;&#x503C;&#x3002;
     *        &#x8BE5;&#x503C;&#x662F;&#x672A;&#x7ECF;&#x89E3;&#x91CA;&#x7684;&#xFF0C;&#x53EF;&#x4EE5;&#x8868;&#x793A;&#x4F60;&#x559C;&#x6B22;&#x7684;&#x4EFB;&#x4F55;&#x5185;&#x5BB9;
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if successful. Upon success, this object has
     *         been acquired.
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if acquiring would place this
     *         synchronizer in an illegal state. This exception must be
     *         thrown in a consistent fashion for synchronization to work
     *         correctly.
     *         &#x5982;&#x679C;&#x52A0;&#x9501;&#x4F1A;&#x5BFC;&#x81F4;&#x540C;&#x6B65;&#x5668;&#x8FDB;&#x5165;&#x975E;&#x6CD5;&#x72B6;&#x6001;&#x5219;&#x4F1A;&#x629B;&#x51FA;IllegalMonitorStateException&#x3002;
     *         &#x5FC5;&#x987B;&#x4EE5;&#x4E00;&#x81F4;&#x7684;&#x65B9;&#x5F0F;&#x629B;&#x51FA;&#x6B64;&#x5F02;&#x5E38;&#xFF0C;&#x540C;&#x6B65;&#x5668;&#x624D;&#x80FD;&#x6B63;&#x5E38;&#x5DE5;&#x4F5C;&#xFF08;&#x4E5F;&#x662F;&#x4E2A;runtimeException&#xFF09;
     * <span class="hljs-doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported // &#x5982;&#x679C;&#x4E0D;&#x652F;&#x6301;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#xFF0C;&#x629B;&#x51FA;UnsupportedOperationException&#xFF08;&#x8FD9;&#x662F;&#x4E2A;runtimeException&#xFF09;
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hljs-comment">/**
     * Attempts to set the state to reflect a release in exclusive
     * mode.
     * &#x5C1D;&#x8BD5;&#x8BBE;&#x7F6E;&#x72B6;&#x6001;&#x6765;&#x53CD;&#x6620;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x7684;&#x89E3;&#x9501;/&#x91CA;&#x653E;&#xFF08;release&#xFF09;
     *
     * &lt;p&gt;This method is always invoked by the thread performing release.
     * &#x8BE5;&#x65B9;&#x6CD5;&#x603B;&#x662F;&#x88AB;&#x6267;&#x884C;&#x89E3;&#x9501;&#xFF08;release&#xFF09;&#x7684;&#x7EBF;&#x7A0B;&#x8C03;&#x7528;
     *
     * &lt;p&gt;The default implementation throws
     * {<span class="hljs-doctag">@link</span> UnsupportedOperationException}.
     *
     * <span class="hljs-doctag">@param</span> arg the release argument. This value is always the one
     *        passed to a release method, or the current state value upon
     *        entry to a condition wait.  The value is otherwise
     *        uninterpreted and can represent anything you like.
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if this object is now in a fully released
     *         state, so that any waiting threads may attempt to acquire;
     *         and {<span class="hljs-doctag">@code</span> false} otherwise.
     *         true&#xFF1A;&#x8868;&#x793A;&#x6B64;&#x5BF9;&#x8C61;&#x5904;&#x4E8E;&#x5B8C;&#x5168;&#x91CA;&#x653E;&#x72B6;&#x6001;&#xFF0C;&#x4EFB;&#x4F55;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#x90FD;&#x53EF;&#x4EE5;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if releasing would place this
     *         synchronizer in an illegal state. This exception must be
     *         thrown in a consistent fashion for synchronization to work
     *         correctly.
     * <span class="hljs-doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hljs-comment">/**
     * Attempts to acquire in shared mode. This method should query if
     * the state of the object permits it to be acquired in the shared
     * mode, and if so to acquire it.
     * &#x5C1D;&#x8BD5;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;&#x3002;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x5E94;&#x5F53;&#x68C0;&#x67E5;&#x5BF9;&#x8C61;&#x7684;&#x72B6;&#x6001;&#x662F;&#x5426;&#x5141;&#x8BB8;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;&#xFF0C;&#x5982;&#x679C;&#x5141;&#x8BB8;&#x5219;&#x52A0;&#x9501;
     *
     * &lt;p&gt;This method is always invoked by the thread performing
     * acquire.  If this method reports failure, the acquire method
     * may queue the thread, if it is not already queued, until it is
     * signalled by a release from some other thread.
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x603B;&#x662F;&#x88AB;&#x60F3;&#x52A0;&#x9501;&#x7684;&#x7EBF;&#x7A0B;&#x8C03;&#x7528;&#x3002;
     * &#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x62A5;&#x544A;&#x5931;&#x8D25;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x80FD;&#x4F1A;&#x5C06;&#x8FD8;&#x6CA1;&#x5728;&#x7B49;&#x5F85;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF0C;&#x76F4;&#x5230;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x91CA;&#x653E;&#x9501;&#x65F6;&#x6765;&#x5524;&#x9192;&#x5B83;&#x3002;
     *
     * &lt;p&gt;The default implementation throws {<span class="hljs-doctag">@link</span>
     * UnsupportedOperationException}.
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument. This value is always the one
     *        passed to an acquire method, or is the value saved on entry
     *        to a condition wait.  The value is otherwise uninterpreted
     *        and can represent anything you like.
     * <span class="hljs-doctag">@return</span> a negative value on failure; zero if acquisition in shared
     *         mode succeeded but no subsequent shared-mode acquire can
     *         succeed; and a positive value if acquisition in shared
     *         mode succeeded and subsequent shared-mode acquires might
     *         also succeed, in which case a subsequent waiting thread
     *         must check availability. (Support for three different
     *         return values enables this method to be used in contexts
     *         where acquires only sometimes act exclusively.)  Upon
     *         success, this object has been acquired.
     *         &#x8D1F;&#x503C;&#x8868;&#x793A;&#x5931;&#x8D25;&#xFF1B;
     *         0&#x8868;&#x793A;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;&#x6210;&#x529F;&#x4F46;&#x662F;&#x5728;&#x968F;&#x540E;&#x7684;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x52A0;&#x9501;&#x4E2D;&#x6CA1;&#x6709;&#x6210;&#x529F;&#xFF1B;&#xFF08;&#x5C31;&#x662F;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x80FD;&#x591F;&#x83B7;&#x53D6;&#x5230;&#x5171;&#x4EAB;&#x9501;&#xFF0C;&#x6CA1;&#x6709;&#x5269;&#x4F59;&#x7684;&#x5171;&#x4EAB;&#x9501;&#x53EF;&#x4EE5;&#x88AB;&#x83B7;&#x53D6;&#xFF09;
     *         &#x6B63;&#x503C;&#x8868;&#x793A;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x52A0;&#x9501;&#x6210;&#x529F;&#x4F46;&#x662F;&#x5728;&#x968F;&#x540E;&#x7684;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x52A0;&#x9501;&#x4E2D;&#x4E5F;&#x53EF;&#x80FD;&#x6210;&#x529F;&#xFF08;&#x5C31;&#x662F;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x80FD;&#x591F;&#x83B7;&#x53D6;&#x5230;&#x5171;&#x4EAB;&#x9501;&#xFF0C;&#x8FD8;&#x6709;&#x5269;&#x4F59;&#x7684;&#x5171;&#x4EAB;&#x9501;&#x53EF;&#x4EE5;&#x88AB;&#x83B7;&#x53D6;&#xFF09;&#xFF0C;&#x5728;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x540E;&#x7EED;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#x5FC5;&#x987B;&#x68C0;&#x67E5;&#x53EF;&#x7528;&#x6027;&#x3002;
     *         &#xFF08;&#x652F;&#x6301;&#x4E09;&#x79CD;&#x4E0D;&#x540C;&#x7684;&#x8FD4;&#x56DE;&#x503C;&#xFF0C;&#x80FD;&#x591F;&#x4FDD;&#x8BC1;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x80FD;&#x591F;&#x5728;&#x4EC5;&#x6267;&#x884C;&#x72EC;&#x5360;&#x884C;&#x4E3A;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x4E2D;&#x4F7F;&#x7528;&#xFF09;
     *         &#x6210;&#x529F;&#x503C;&#x8868;&#x793A;&#x8BE5;&#x5BF9;&#x8C61;&#x52A0;&#x9501;&#x6210;&#x529F;&#x3002;
     *         
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if acquiring would place this
     *         synchronizer in an illegal state. This exception must be
     *         thrown in a consistent fashion for synchronization to work
     *         correctly.
     * <span class="hljs-doctag">@throws</span> UnsupportedOperationException if shared mode is not supported
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hljs-comment">/**
     * Attempts to set the state to reflect a release in shared mode.
     * &#x5C1D;&#x8BD5;&#x8BBE;&#x7F6E;&#x72B6;&#x6001;&#x6765;&#x53CD;&#x6620;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x89E3;&#x9501;/&#x91CA;&#x653E;&#xFF08;release&#xFF09;
     *
     * &lt;p&gt;This method is always invoked by the thread performing release.
     *
     * &lt;p&gt;The default implementation throws
     * {<span class="hljs-doctag">@link</span> UnsupportedOperationException}.
     *
     * <span class="hljs-doctag">@param</span> arg the release argument. This value is always the one
     *        passed to a release method, or the current state value upon
     *        entry to a condition wait.  The value is otherwise
     *        uninterpreted and can represent anything you like.
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if this release of shared mode may permit a
     *         waiting acquire (shared or exclusive) to succeed; and
     *         {<span class="hljs-doctag">@code</span> false} otherwise
     *         true&#xFF1A;&#x8868;&#x793A;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7684;release&#x53EF;&#x4EE5;&#x5141;&#x8BB8;&#x7B49;&#x5F85;&#x83B7;&#x53D6;&#xFF08;&#x5171;&#x4EAB;/&#x72EC;&#x5360;&#xFF09;&#x64CD;&#x4F5C;&#x6210;&#x529F;
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if releasing would place this
     *         synchronizer in an illegal state. This exception must be
     *         thrown in a consistent fashion for synchronization to work
     *         correctly.
     * <span class="hljs-doctag">@throws</span> UnsupportedOperationException if shared mode is not supported
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if synchronization is held exclusively with
     * respect to the current (calling) thread.  This method is invoked
     * upon each call to a non-waiting {<span class="hljs-doctag">@link</span> ConditionObject} method.
     * (Waiting methods instead invoke {<span class="hljs-doctag">@link</span> #release}.)
     * &#x5982;&#x679C;&#x5F53;&#x524D;&#xFF08;&#x8C03;&#x7528;&#xFF09;&#x7EBF;&#x7A0B;&#x6301;&#x6709;&#x72EC;&#x5360;&#x7684;&#x540C;&#x6B65;&#x9501;&#xFF0C;&#x5C06;&#x8FD4;&#x56DE;true&#x3002;
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x88AB;&#x6BCF;&#x4E2A;&#x975E;&#x7B49;&#x5F85;&#x7684;ConditionObject&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x3002;
     * &#xFF08;&#x7B49;&#x5F85;&#x65B9;&#x6CD5;&#x66FF;&#x6362;&#x6210;&#x8C03;&#x7528;release&#xFF09;
     *
     * &lt;p&gt;The default implementation throws {<span class="hljs-doctag">@link</span>
     * UnsupportedOperationException}. This method is invoked
     * internally only within {<span class="hljs-doctag">@link</span> ConditionObject} methods, so need
     * not be defined if conditions are not used.
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4EC5;&#x5728;ConditionObject&#x7684;&#x65B9;&#x6CD5;&#x5185;&#x90E8;&#x8C03;&#x7528;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x4F7F;&#x7528;Condition&#x5C31;&#x4E0D;&#x7528;&#x5B9A;&#x4E49;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x3002;
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if synchronization is held exclusively;
     *         {<span class="hljs-doctag">@code</span> false} otherwise
     * <span class="hljs-doctag">@throws</span> UnsupportedOperationException if conditions are not supported
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }

        <span class="hljs-comment">// &#x4E0B;&#x9762;&#x662F;&#x5B8C;&#x5168;&#x5BF9;&#x5916;&#x7684;public&#x65B9;&#x6CD5;</span>
    <span class="hljs-comment">/**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {<span class="hljs-doctag">@link</span> #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {<span class="hljs-doctag">@link</span>
     * #tryAcquire} until success.  This method can be used
     * to implement method {<span class="hljs-doctag">@link</span> Lock#lock}.
     * &#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF0C;&#x5FFD;&#x7565;&#x4E2D;&#x65AD;&#x3002;&#x901A;&#x8FC7;&#x81F3;&#x5C11;&#x8C03;&#x7528;&#x4E00;&#x6B21;tryAcquire&#x6765;&#x5B9E;&#x73B0;&#xFF0C;&#x5728;&#x6210;&#x529F;&#x65F6;&#x8FD4;&#x56DE;&#x3002;
     * &#x5426;&#x5219;&#x7EBF;&#x7A0B;&#x4F1A;&#x6392;&#x961F;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x53CD;&#x590D;&#x963B;&#x585E;&#x4E0E;&#x89E3;&#x9664;&#x963B;&#x585E;&#xFF0C;&#x8C03;&#x7528;tryAcquire&#x76F4;&#x5230;&#x6210;&#x529F;&#x3002;
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x5B9E;&#x73B0;lock&#x65B9;&#x6CD5;&#x3002;
     * &#xFF08;&#x62FF;&#x4E0D;&#x5230;&#x9501;&#x5C31;&#x5165;&#x961F;&#x6392;&#x961F;&#xFF0C;&#x7B49;&#x4E0D;&#x5230;&#x5C31;&#x963B;&#x585E;&#x7B49;&#x5F85;&#x5524;&#x9192;&#xFF09;
     * 
     * <span class="hljs-doctag">@param</span> arg the acquire argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x5931;&#x8D25;</span>
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
            <span class="hljs-comment">// addWaiter(Node.EXCLUSIVE), arg)&#x5C06;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6309;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x521B;&#x5EFA;node&#xFF0C;&#x52A0;&#x5165;&#x5230;&#x961F;&#x5217;&#x4E2D;</span>
            <span class="hljs-comment">// acquireQueued&#x5982;&#x679C;&#x5F53;&#x524D;node&#x7684;&#x524D;&#x9A71;&#x662F;head&#xFF0C;&#x90A3;&#x4E48;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;&#xFF0C;&#x5206;&#x6790;&#x662F;&#x5426;&#x963B;&#x585E;&#x7B49;&#x5F85;&#x4E0E;&#x963B;&#x585E;&#x5524;&#x9192;&#x540E;&#x68C0;&#x6D4B;&#x4E2D;&#x65AD;&#x4FE1;&#x53F7;</span>
            selfInterrupt();
    }

    <span class="hljs-comment">/**
     * Acquires in exclusive mode, aborting if interrupted.
     * Implemented by first checking interrupt status, then invoking
     * at least once {<span class="hljs-doctag">@link</span> #tryAcquire}, returning on
     * success.  Otherwise the thread is queued, possibly repeatedly
     * blocking and unblocking, invoking {<span class="hljs-doctag">@link</span> #tryAcquire}
     * until success or the thread is interrupted.  This method can be
     * used to implement method {<span class="hljs-doctag">@link</span> Lock#lockInterruptibly}.
     * &#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF0C;&#x5982;&#x679C;&#x4E2D;&#x65AD;&#x4E86;&#x5C31;&#x7EC8;&#x6B62;&#x3002;
     * &#x901A;&#x8FC7;&#x9996;&#x5148;&#x68C0;&#x67E5;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x81F3;&#x5C11;&#x8C03;&#x7528;&#x4E00;&#x6B21;tryAcquire&#x5B9E;&#x73B0;&#xFF0C;&#x6210;&#x529F;&#x65F6;&#x8FD4;&#x56DE;&#x3002;
     * &#x5426;&#x5219;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF0C;&#x53EF;&#x80FD;&#x53CD;&#x590D;&#x963B;&#x585E;&#x4E0E;&#x53D6;&#x6D88;&#x963B;&#x585E;&#xFF0C;&#x8C03;&#x7528;tryAcquire&#x76F4;&#x5230;&#x6210;&#x529F;&#x6216;&#x8005;&#x7EBF;&#x7A0B;&#x88AB;&#x4E2D;&#x65AD;&#x3002;
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x5B9E;&#x73B0;lockInterruptibly&#x65B9;&#x6CD5;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        <span class="hljs-keyword">if</span> (!tryAcquire(arg))
            doAcquireInterruptibly(arg); <span class="hljs-comment">// &#x5982;&#x679C;&#x83B7;&#x53D6;&#x5931;&#x8D25;&#xFF0C;&#x8C03;&#x7528;doAcquireInterruptibly&#x65B9;&#x6CD5;&#xFF0C;&#x8DDF;acquireQueued&#x65B9;&#x6CD5;&#x7C7B;&#x4F3C;&#xFF0C;&#x53EA;&#x662F;&#x4F1A;&#x5728;&#x68C0;&#x6D4B;&#x5230;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#x540E;&#xFF0C;&#x76F4;&#x63A5;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x7EE7;&#x7EED;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x9501;</span>
    }

    <span class="hljs-comment">/**
     * Attempts to acquire in exclusive mode, aborting if interrupted,
     * and failing if the given timeout elapses.  Implemented by first
     * checking interrupt status, then invoking at least once {<span class="hljs-doctag">@link</span>
     * #tryAcquire}, returning on success.  Otherwise, the thread is
     * queued, possibly repeatedly blocking and unblocking, invoking
     * {<span class="hljs-doctag">@link</span> #tryAcquire} until success or the thread is interrupted
     * or the timeout elapses.  This method can be used to implement
     * method {<span class="hljs-doctag">@link</span> Lock#tryLock(long, TimeUnit)}.
     * &#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF0C;&#x5982;&#x679C;&#x4E2D;&#x65AD;&#x6216;&#x8005;&#x8D85;&#x65F6;&#x5C31;&#x7EC8;&#x6B62;&#x6216;&#x8005;&#x5931;&#x8D25;&#x3002;
     * &#x901A;&#x8FC7;&#x9996;&#x5148;&#x68C0;&#x67E5;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x81F3;&#x5C11;&#x4E00;&#x6B21;&#x8C03;&#x7528;tryAcquire&#x6765;&#x5B9E;&#x73B0;&#xFF0C;&#x6210;&#x529F;&#x65F6;&#x8FD4;&#x56DE;&#x3002;
     * &#x5426;&#x5219;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF0C;&#x53EF;&#x80FD;&#x53CD;&#x590D;&#x963B;&#x585E;&#x4E0E;&#x53D6;&#x6D88;&#x963B;&#x585E;&#xFF0C;&#x8C03;&#x7528;tryAcquire&#x76F4;&#x5230;&#x83B7;&#x53D6;&#x6210;&#x529F;&#xFF0C;&#x6216;&#x8005;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x6216;&#x8005;&#x8D85;&#x65F6;&#x3002;
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x5B9E;&#x73B0;tryLock(long, TimeUnit)&#x65B9;&#x6CD5;
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     * <span class="hljs-doctag">@param</span> nanosTimeout the maximum number of nanoseconds to wait
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if acquired; {<span class="hljs-doctag">@code</span> false} if timed out
     * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        <span class="hljs-keyword">return</span> tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
    }

    <span class="hljs-comment">/**
     * Releases in exclusive mode.  Implemented by unblocking one or
     * more threads if {<span class="hljs-doctag">@link</span> #tryRelease} returns true.
     * This method can be used to implement method {<span class="hljs-doctag">@link</span> Lock#unlock}.
     * &#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x91CA;&#x653E;&#x3002;&#x5982;&#x679C;tryRelease&#x8FD4;&#x56DE;true&#xFF0C;&#x901A;&#x8FC7;&#x89E3;&#x9664;&#x963B;&#x585E;&#x4E00;&#x4E2A;&#x6216;&#x591A;&#x4E2A;&#x7EBF;&#x7A0B;&#x6765;&#x5B9E;&#x73B0;&#x3002;
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x7528;&#x6765;&#x5B9E;&#x73B0;unlock&#x65B9;&#x6CD5;
     *
     * <span class="hljs-doctag">@param</span> arg the release argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryRelease} but is otherwise uninterpreted and
     *        can represent anything you like.
     * <span class="hljs-doctag">@return</span> the value returned from {<span class="hljs-doctag">@link</span> #tryRelease}
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">if</span> (tryRelease(arg)) {
            Node h = head;
            <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x5934;&#x7ED3;&#x70B9;&#xFF0C;&#x5E76;&#x4E14;ws&#x4E0D;&#x662F;&#x9ED8;&#x8BA4;&#x503C;0</span>
                unparkSuccessor(h); <span class="hljs-comment">// &#x5524;&#x9192;&#x4E00;&#x4E2A;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4F1A;&#x628A;ws&#x7F6E;&#x4E3A;0&#xFF0C;&#x8868;&#x793A;&#x6B63;&#x5728;&#x64CD;&#x4F5C;&#xFF1F;&#xFF1F;&#xFF1F;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">/**
     * Acquires in shared mode, ignoring interrupts.  Implemented by
     * first invoking at least once {<span class="hljs-doctag">@link</span> #tryAcquireShared},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {<span class="hljs-doctag">@link</span>
     * #tryAcquireShared} until success.
     * &#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF0C;&#x5FFD;&#x7565;&#x4E2D;&#x65AD;&#x3002;
     * &#x901A;&#x8FC7;&#x9996;&#x5148;&#x8C03;&#x7528;&#x81F3;&#x5C11;&#x4E00;&#x6B21;tryAcquireShared&#x65B9;&#x6CD5;&#x6765;&#x5B9E;&#x73B0;&#xFF0C;&#x6210;&#x529F;&#x65F6;&#x8FD4;&#x56DE;&#x3002;
     * &#x5426;&#x5219;&#x8BE5;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF0C;&#x53EF;&#x80FD;&#x53CD;&#x590D;&#x963B;&#x585E;&#x6216;&#x8005;&#x89E3;&#x9664;&#x963B;&#x585E;&#xFF0C;&#x8C03;&#x7528;tryAcquireShared&#x76F4;&#x5230;&#x6210;&#x529F;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// &#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x5931;&#x8D25;&#xFF08;&#x8FD9;&#x662F;&#x4E2A;&#x9700;&#x8981;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684;&#x65B9;&#x6CD5;&#xFF09;</span>
            doAcquireShared(arg); <span class="hljs-comment">// &#x5C06;&#x8BE5;&#x7EBF;&#x7A0B;&#x5C01;&#x88C5;&#x6210;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x7684;node&#x7136;&#x540E;&#x5165;&#x961F;&#xFF0C;&#x5FAA;&#x73AF;&#x8C03;&#x7528;tryAcquireShared&#x6765;&#x83B7;&#x53D6;&#xFF0C;&#x5982;&#x679C;tryAcquireShared&#x8FD4;&#x56DE;&#x503C;&gt;=0&#xFF0C;&#x4F1A;&#x8C03;&#x7528;setHeadAndPropagate&#x65B9;&#x6CD5;&#xFF0C;&#x5148;&#x628A;&#x5F53;&#x524D;node&#x8BBE;&#x7F6E;&#x4E3A;head&#xFF0C;&#x7136;&#x540E;&#x5C1D;&#x8BD5;&#x91CA;&#x653E;&#x540E;&#x7EE7;&#x7684;node&#xFF1B;&#x5982;&#x679C;tryAcquireShared&#x8FD4;&#x56DE;&lt;0&#xFF0C;&#x4F1A;&#x5224;&#x65AD;&#x662F;&#x5426;&#x9700;&#x8981;park</span>
    }

    <span class="hljs-comment">/**
     * Acquires in shared mode, aborting if interrupted.  Implemented
     * by first checking interrupt status, then invoking at least once
     * {<span class="hljs-doctag">@link</span> #tryAcquireShared}, returning on success.  Otherwise the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {<span class="hljs-doctag">@link</span> #tryAcquireShared} until success or the thread
     * is interrupted.
     * &#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF0C;&#x5728;&#x4E2D;&#x65AD;&#x65F6;&#x7EC8;&#x6B62;&#x3002;
     * &#x901A;&#x8FC7;&#x9996;&#x5148;&#x68C0;&#x67E5;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x81F3;&#x5C11;&#x8C03;&#x7528;&#x4E00;&#x6B21;tryAcquireShared&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#xFF0C;&#x6210;&#x529F;&#x65F6;&#x8FD4;&#x56DE;&#x3002;
     * &#x5426;&#x5219;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF0C;&#x53EF;&#x80FD;&#x53CD;&#x590D;&#x963B;&#x585E;&#x4E0E;&#x89E3;&#x9664;&#x963B;&#x585E;&#xFF0C;&#x8C03;&#x7528;tryAcquireShared&#x65B9;&#x6CD5;&#xFF0C;&#x76F4;&#x5230;&#x6210;&#x529F;&#x6216;&#x8005;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#x3002;
     * 
     * <span class="hljs-doctag">@param</span> arg the acquire argument.
     * This value is conveyed to {<span class="hljs-doctag">@link</span> #tryAcquireShared} but is
     * otherwise uninterpreted and can represent anything
     * you like.
     * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)
            doAcquireSharedInterruptibly(arg); <span class="hljs-comment">// &#x5728;&#x4E2D;&#x65AD;&#x65F6;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;</span>
    }

    <span class="hljs-comment">/**
     * Attempts to acquire in shared mode, aborting if interrupted, and
     * failing if the given timeout elapses.  Implemented by first
     * checking interrupt status, then invoking at least once {<span class="hljs-doctag">@link</span>
     * #tryAcquireShared}, returning on success.  Otherwise, the
     * thread is queued, possibly repeatedly blocking and unblocking,
     * invoking {<span class="hljs-doctag">@link</span> #tryAcquireShared} until success or the thread
     * is interrupted or the timeout elapses.
     * &#x5C1D;&#x8BD5;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF0C;&#x5982;&#x679C;&#x4E2D;&#x65AD;&#x5219;&#x7EC8;&#x6B62;&#xFF0C;&#x5982;&#x679C;&#x8D85;&#x65F6;&#x5219;&#x8FD4;&#x56DE;&#x5931;&#x8D25;&#x3002;
     * &#x901A;&#x8FC7;&#x9996;&#x5148;&#x68C0;&#x67E5;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x7136;&#x540E;&#x81F3;&#x5C11;&#x8C03;&#x7528;&#x4E00;&#x6B21;tryAcquireShared&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;&#xFF0C;&#x6210;&#x529F;&#x65F6;&#x8FD4;&#x56DE;&#x3002;
     * &#x5426;&#x5219;&#xFF0C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#xFF0C;&#x53EF;&#x80FD;&#x53CD;&#x590D;&#x591A;&#x6B21;&#x963B;&#x585E;&#x4E0E;&#x89E3;&#x9664;&#x963B;&#x585E;&#xFF0C;&#x8C03;&#x7528;tryAcquireShared&#x65B9;&#x6CD5;&#x76F4;&#x5230;&#x6210;&#x529F;&#xFF0C;&#x6216;&#x8005;&#x7EBF;&#x7A0B;&#x4E2D;&#x65AD;&#xFF0C;&#x6216;&#x8005;&#x8D85;&#x65F6;
     *
     * <span class="hljs-doctag">@param</span> arg the acquire argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryAcquireShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * <span class="hljs-doctag">@param</span> nanosTimeout the maximum number of nanoseconds to wait
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if acquired; {<span class="hljs-doctag">@code</span> false} if timed out
     * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg, <span class="hljs-keyword">long</span> nanosTimeout)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">if</span> (Thread.interrupted())
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
        <span class="hljs-keyword">return</span> tryAcquireShared(arg) &gt;= <span class="hljs-number">0</span> ||
            doAcquireSharedNanos(arg, nanosTimeout); <span class="hljs-comment">// &#x6B63;&#x5E38;&#x903B;&#x8F91;&#x64CD;&#x4F5C;&#xFF0C;&#x6CA1;&#x5565;&#x8BF4;&#x7684;</span>
    }

    <span class="hljs-comment">/**
     * Releases in shared mode.  Implemented by unblocking one or more
     * threads if {<span class="hljs-doctag">@link</span> #tryReleaseShared} returns true.
     * &#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x91CA;&#x653E;&#x3002;
     * &#x5982;&#x679C;tryReleaseShared&#x8FD4;&#x56DE;true&#xFF0C;&#x901A;&#x8FC7;&#x89E3;&#x9664;&#x963B;&#x585E;&#x4E00;&#x4E2A;&#x6216;&#x591A;&#x4E2A;&#x7EBF;&#x7A0B;&#x6765;&#x5B9E;&#x73B0;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> arg the release argument.  This value is conveyed to
     *        {<span class="hljs-doctag">@link</span> #tryReleaseShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * <span class="hljs-doctag">@return</span> the value returned from {<span class="hljs-doctag">@link</span> #tryReleaseShared}
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>{
        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) {
            doReleaseShared();
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">// Queue inspection methods</span>
    <span class="hljs-comment">// &#x961F;&#x5217;&#x68C0;&#x67E5;&#x65B9;&#x6CD5;</span>

    <span class="hljs-comment">/**
     * Queries whether any threads are waiting to acquire. Note that
     * because cancellations due to interrupts and timeouts may occur
     * at any time, a {<span class="hljs-doctag">@code</span> true} return does not guarantee that any
     * other thread will ever acquire.
     * &#x67E5;&#x8BE2;&#x662F;&#x5426;&#x6709;&#x7EBF;&#x7A0B;&#x6B63;&#x5728;&#x7B49;&#x5F85;&#x83B7;&#x53D6;&#x3002;
     * &#x6CE8;&#x610F;&#xFF1A;&#x7531;&#x4E8E;&#x53EF;&#x80FD;&#x5728;&#x4EFB;&#x610F;&#x65F6;&#x95F4;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#x6216;&#x8005;&#x8D85;&#x65F6;&#xFF0C;&#x4F1A;&#x5BFC;&#x81F4;&#x7EBF;&#x7A0B;&#x53D6;&#x6D88;&#xFF0C;&#x6240;&#x4EE5;&#x8FD4;&#x56DE;true&#x4E5F;&#x4E0D;&#x80FD;&#x4FDD;&#x8BC1;&#x6709;&#x7EBF;&#x7A0B;&#x6C38;&#x8FDC;&#x5728;&#x7B49;&#x5F85;&#x83B7;&#x53D6;&#x3002;
     *
     * &lt;p&gt;In this implementation, this operation returns in
     * constant time.
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if there may be other threads waiting to acquire
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedThreads</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> head != tail;
    }

    <span class="hljs-comment">/**
     * Queries whether any threads have ever contended to acquire this
     * synchronizer; that is if an acquire method has ever blocked.
     * &#x67E5;&#x8BE2;&#x662F;&#x5426;&#x6709;&#x7EBF;&#x7A0B;&#x7ADE;&#x4E89;&#x8FC7;&#x83B7;&#x53D6;&#x8FD9;&#x4E2A;&#x540C;&#x6B65;&#x5668;&#xFF1B;
     * &#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#xFF0C;&#x66FE;&#x7ECF;&#x6709;&#x7EBF;&#x7A0B;&#x8C03;&#x7528;acquire&#x65B9;&#x6CD5;&#x963B;&#x585E;&#x8FC7;&#x3002;
     *
     * &lt;p&gt;In this implementation, this operation returns in
     * constant time.
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if there has ever been contention
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasContended</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> head != <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">/**
     * Returns the first (longest-waiting) thread in the queue, or
     * {<span class="hljs-doctag">@code</span> null} if no threads are currently queued.
     * &#x8FD4;&#x56DE;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#xFF08;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x6700;&#x957F;&#x7684;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x7EBF;&#x7A0B;&#x5728;&#x5F53;&#x524D;&#x961F;&#x5217;&#xFF0C;&#x8FD4;&#x56DE;null
     *
     * &lt;p&gt;In this implementation, this operation normally returns in
     * constant time, but may iterate upon contention if other threads are
     * concurrently modifying the queue.
     *
     * <span class="hljs-doctag">@return</span> the first (longest-waiting) thread in the queue, or
     *         {<span class="hljs-doctag">@code</span> null} if no threads are currently queued
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title">getFirstQueuedThread</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// handle only fast path, else relay</span>
        <span class="hljs-keyword">return</span> (head == tail) ? <span class="hljs-keyword">null</span> : fullGetFirstQueuedThread();
    }

    <span class="hljs-comment">/**
     * Version of getFirstQueuedThread called when fastpath fails
     * &#x5FEB;&#x901F;&#x8DEF;&#x5F84;&#x5931;&#x8D25;&#x65F6;&#x8C03;&#x7528;&#x7684;&#x7248;&#x672C;
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Thread <span class="hljs-title">fullGetFirstQueuedThread</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">/*
         * The first node is normally head.next. Try to get its
         * thread field, ensuring consistent reads: If thread
         * field is nulled out or s.prev is no longer head, then
         * some other thread(s) concurrently performed setHead in
         * between some of our reads. We try this twice before
         * resorting to traversal.
         * &#x786E;&#x4FDD;&#x8BFB;&#x4E00;&#x81F4;&#x6027;&#xFF0C;&#x5982;&#x679C;&#x7EBF;&#x7A0B;&#x5B57;&#x6BB5;&#x88AB;&#x7F6E;null&#xFF0C;&#x6216;&#x8005;s.prev&#x4E0D;&#x518D;&#x662F;head&#xFF0C;&#x7136;&#x540E;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#x5E76;&#x53D1;&#x7684;&#x5728;&#x6211;&#x4EEC;&#x8BFB;&#x4E2D;&#x95F4;setHead&#x3002;
         * &#x5C1D;&#x8BD5;&#x4E24;&#x6B21;
         */</span>
        Node h, s;
        Thread st;
        <span class="hljs-keyword">if</span> (((h = head) != <span class="hljs-keyword">null</span> &amp;&amp; (s = h.next) != <span class="hljs-keyword">null</span> &amp;&amp;
             s.prev == head &amp;&amp; (st = s.thread) != <span class="hljs-keyword">null</span>) ||
            ((h = head) != <span class="hljs-keyword">null</span> &amp;&amp; (s = h.next) != <span class="hljs-keyword">null</span> &amp;&amp;
             s.prev == head &amp;&amp; (st = s.thread) != <span class="hljs-keyword">null</span>))
            <span class="hljs-keyword">return</span> st;

        <span class="hljs-comment">/*
         * Head&apos;s next field might not have been set yet, or may have
         * been unset after setHead. So we must check to see if tail
         * is actually first node. If not, we continue on, safely
         * traversing from tail back to head to find first,
         * guaranteeing termination.
         * head&#x7684;next&#x53EF;&#x80FD;&#x8FD8;&#x6CA1;&#x6709;&#x8BBE;&#x7F6E;&#xFF0C;&#x6216;&#x8005;&#x53EF;&#x80FD;&#x5728;setHead&#x4E4B;&#x540E;&#x672A;&#x8BBE;&#x7F6E;&#x3002;&#x6240;&#x4EE5;&#x5E94;&#x8BE5;&#x68C0;&#x67E5;tail&#x662F;&#x5426;&#x5B9E;&#x9645;&#x4E0A;&#x662F;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x3002;
         * &#x5982;&#x679C;&#x4E0D;&#x662F;&#xFF0C;&#x7EE7;&#x7EED;&#x5B89;&#x5168;&#x7684;&#x4ECE;tail&#x5411;head&#x67E5;&#x627E;&#x7B2C;&#x4E00;&#x4E2A;&#xFF0C;&#x4FDD;&#x8BC1;&#x7EC8;&#x6B62;&#x3002;
         */</span>

        Node t = tail;
        Thread firstThread = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t != head) {
            Thread tt = t.thread;
            <span class="hljs-keyword">if</span> (tt != <span class="hljs-keyword">null</span>)
                firstThread = tt;
            t = t.prev;
        }
        <span class="hljs-keyword">return</span> firstThread;
    }

    <span class="hljs-comment">/**
     * Returns true if the given thread is currently queued.
     * &#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5728;&#x6392;&#x961F;&#xFF0C;&#x8FD4;&#x56DE;true
     *
     * &lt;p&gt;This implementation traverses the queue to determine
     * presence of the given thread.
     *
     * <span class="hljs-doctag">@param</span> thread the thread
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if the given thread is on the queue
     * <span class="hljs-doctag">@throws</span> NullPointerException if the thread is null
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isQueued</span><span class="hljs-params">(Thread thread)</span> </span>{
        <span class="hljs-keyword">if</span> (thread == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        <span class="hljs-keyword">for</span> (Node p = tail; p != <span class="hljs-keyword">null</span>; p = p.prev)
            <span class="hljs-keyword">if</span> (p.thread == thread)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">/**
     * Returns {<span class="hljs-doctag">@code</span> true} if the apparent first queued thread, if one
     * exists, is waiting in exclusive mode.  If this method returns
     * {<span class="hljs-doctag">@code</span> true}, and the current thread is attempting to acquire in
     * shared mode (that is, this method is invoked from {<span class="hljs-doctag">@link</span>
     * #tryAcquireShared}) then it is guaranteed that the current thread
     * is not the first queued thread.  Used only as a heuristic in
     * ReentrantReadWriteLock.
     * &#x5982;&#x679C;&#x660E;&#x663E;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#xFF08;&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;&#xFF09;&#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#xFF0C;&#x8FD4;&#x56DE;true&#x3002;
     * &#x5982;&#x679C;&#x8BE5;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;true&#xFF0C;&#x5E76;&#x4E14;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x8BD5;&#x56FE;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x83B7;&#x53D6;&#xFF08;&#x8FD9;&#x610F;&#x5473;&#x7740;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x5F0F;&#x662F;&#x901A;&#x8FC7;tryAcquireShared&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x7684;&#xFF09;&#xFF0C;&#x5219;&#x53EF;&#x4EE5;&#x4FDD;&#x8BC1;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0D;&#x662F;&#x7B2C;&#x4E00;&#x4E2A;&#x6392;&#x961F;&#x7684;&#x7EBF;&#x7A0B;&#x3002;
     * &#x4EC5;&#x7528;&#x4E8E;ReentrantReadWriteLcok&#x7684;&#x542F;&#x53D1;&#x5F0F;&#x65B9;&#x6CD5;
     * 
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">apparentlyFirstQueuedIsExclusive</span><span class="hljs-params">()</span> </span>{
        Node h, s;
        <span class="hljs-keyword">return</span> (h = head) != <span class="hljs-keyword">null</span> &amp;&amp;
            (s = h.next)  != <span class="hljs-keyword">null</span> &amp;&amp;
            !s.isShared()         &amp;&amp;
            s.thread != <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">/**
     * Queries whether any threads have been waiting to acquire longer
     * than the current thread.
     * &#x67E5;&#x8BE2;&#x662F;&#x5426;&#x6709;&#x6BD4;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x66F4;&#x4E45;&#x7684;&#x7EBF;&#x7A0B;&#x3002;
     *
     * &lt;p&gt;An invocation of this method is equivalent to (but may be
     * more efficient than):
     * &#x8C03;&#x7528;&#x6B64;&#x65B9;&#x6CD5;&#x7B49;&#x6548;&#x4E8E;&#xFF08;&#x4F46;&#x662F;&#x53EF;&#x80FD;&#x66F4;&#x9AD8;&#x6548;&#xFF09;&#xFF1A;
     *  &lt;pre&gt; {<span class="hljs-doctag">@code</span>
     * getFirstQueuedThread() != Thread.currentThread() &amp;&amp;
     * hasQueuedThreads()}&lt;/pre&gt;
     * &#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E0D;&#x662F;&#x961F;&#x5217;&#x91CC;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#xFF0C;&#x5E76;&#x4E14;&#x961F;&#x5217;&#x91CC;&#x6709;&#x7EBF;&#x7A0B;
     *
     * &lt;p&gt;Note that because cancellations due to interrupts and
     * timeouts may occur at any time, a {<span class="hljs-doctag">@code</span> true} return does not
     * guarantee that some other thread will acquire before the current
     * thread.  Likewise, it is possible for another thread to win a
     * race to enqueue after this method has returned {<span class="hljs-doctag">@code</span> false},
     * due to the queue being empty.
     * &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4E0D;&#x80FD;&#x4FDD;&#x8BC1;&#x8FD9;&#x4E2A;&#x7EBF;&#x7A0B;&#x524D;&#x9762;&#x4E00;&#x5B9A;&#x6709;&#x8001;&#x7EBF;&#x7A0B;&#xFF0C;&#x6216;&#x8005;&#x8FD9;&#x4E2A;&#x7EBF;&#x7A0B;&#x4E00;&#x5B9A;&#x662F;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x6700;&#x957F;&#x7684;&#x7EBF;&#x7A0B;
     * &#x539F;&#x56E0;1&#x3001;&#x53EF;&#x80FD;&#x5728;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;true&#x540E;&#xFF0C;&#x524D;&#x9762;&#x7684;&#x7EBF;&#x7A0B;&#x7531;&#x4E8E;&#x4E2D;&#x65AD;&#x6216;&#x8005;&#x8D85;&#x65F6;&#x5BFC;&#x81F4;&#x9000;&#x51FA;&#x4E86;&#x7B49;&#x5F85;
     * &#x539F;&#x56E0;2&#x3001;&#x53EF;&#x80FD;&#x5728;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;false&#x540E;&#xFF0C;&#x5728;&#x961F;&#x5217;&#x4E3A;&#x7A7A;&#x65F6;&#xFF0C;&#x6709;&#x65B0;&#x7684;&#x7EBF;&#x7A0B;&#x5728;&#x4E0E;&#x8BE5;&#x7EBF;&#x7A0B;&#x5165;&#x961F;&#x7ADE;&#x4E89;&#x65F6;&#x83B7;&#x80DC;&#xFF0C;&#x6BD4;&#x8BE5;&#x7EBF;&#x7A0B;&#x66F4;&#x65E9;&#x5165;&#x961F;
     *
     * &lt;p&gt;This method is designed to be used by a fair synchronizer to
     * avoid &lt;a href=&quot;AbstractQueuedSynchronizer#barging&quot;&gt;barging&lt;/a&gt;.
     * Such a synchronizer&apos;s {<span class="hljs-doctag">@link</span> #tryAcquire} method should return
     * {<span class="hljs-doctag">@code</span> false}, and its {<span class="hljs-doctag">@link</span> #tryAcquireShared} method should
     * return a negative value, if this method returns {<span class="hljs-doctag">@code</span> true}
     * (unless this is a reentrant acquire).  For example, the {<span class="hljs-doctag">@code</span>
     * tryAcquire} method for a fair, reentrant, exclusive mode
     * synchronizer might look like this:
     * &#x8BE5;&#x65B9;&#x6CD5;&#x662F;&#x4E3A;&#x4E86;&#x516C;&#x5E73;&#x540C;&#x6B65;&#x5668;&#x8BBE;&#x8BA1;&#x7684;&#xFF0C;&#x907F;&#x514D;&#x63D2;&#x961F;&#x60C5;&#x51B5;&#x3002;
     * &#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;true&#xFF0C;&#x8FD9;&#x79CD;&#x540C;&#x6B65;&#x5668;&#x7684;tryAcquire&#x65B9;&#x6CD5;&#x5E94;&#x8BE5;&#x8FD4;&#x56DE;false&#xFF0C;&#x5B83;&#x7684;tryAcquireShared&#x65B9;&#x6CD5;&#x5E94;&#x8BE5;&#x8FD4;&#x56DE;&#x8D1F;&#x503C;&#xFF0C;&#x9664;&#x975E;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x53EF;&#x91CD;&#x5165;&#x7684;&#x83B7;&#x53D6;&#x8FC7;&#x7A0B;&#x3002;
     * &#x4F8B;&#x5982;&#xFF1A;&#x516C;&#x5E73;&#x3001;&#x53EF;&#x91CD;&#x5165;&#x3001;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x7684;&#x540C;&#x6B65;&#x5668;tryAcquire&#x65B9;&#x6CD5;&#x53EF;&#x80FD;&#x5982;&#x4E0B;&#x6240;&#x793A;&#xFF1A;
     *
     *  &lt;pre&gt; {<span class="hljs-doctag">@code</span>
     * protected boolean tryAcquire(int arg) {
     *   if (isHeldExclusively()) { // &#x5148;&#x770B;&#x662F;&#x4E0D;&#x662F;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x72EC;&#x5360;
     *     // A reentrant acquire; increment hold count
     *     return true;
     *   } else if (hasQueuedPredecessors()) { // &#x518D;&#x770B;&#x524D;&#x9762;&#x6709;&#x6CA1;&#x6709;&#x6392;&#x961F;&#x7684;&#xFF08;&#x73B0;&#x5728;&#x7EBF;&#x7A0B;&#x53EF;&#x80FD;&#x4E0D;&#x5728;&#x961F;&#x5217;&#xFF0C;&#x4E5F;&#x53EF;&#x80FD;&#x5728;&#x961F;&#x5217;&#x91CC;&#xFF0C;&#x4E0D;&#x5F71;&#x54CD;&#x5224;&#x65AD;&#xFF09;
     *     return false;
     *   } else { // &#x90FD;&#x6CA1;&#x6709;&#x5C31;&#x51C6;&#x5907;&#x7ADE;&#x4E89;
     *     // try to acquire normally
     *   }
     * }}&lt;/pre&gt;
     *
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if there is a queued thread preceding the
     *         current thread, and {<span class="hljs-doctag">@code</span> false} if the current thread
     *         is at the head of the queue or the queue is empty
     * <span class="hljs-doctag">@since</span> 1.7
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// The correctness of this depends on head being initialized</span>
        <span class="hljs-comment">// before tail and on head.next being accurate if the current</span>
        <span class="hljs-comment">// thread is first in queue.</span>
        <span class="hljs-comment">// &#x6B63;&#x786E;&#x6027;&#x53D6;&#x51B3;&#x4E8E;head&#x5728;tail&#x4E4B;&#x524D;&#x88AB;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x5E76;&#x4E14;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x662F;&#x5728;&#x961F;&#x5217;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x4E48;head.next&#x662F;&#x51C6;&#x786E;&#x7684;</span>
        Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span>
        Node h = head;
        Node s;
        <span class="hljs-comment">// &#x65B9;&#x6CD5;&#x8FD4;&#x56DE;true&#x8868;&#x793A;&#x5728;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E4B;&#x524D;&#x8FD8;&#x6709;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#xFF0C;false&#x8868;&#x793A;&#x6CA1;&#x6709;</span>
        <span class="hljs-comment">// head != tail&#x6392;&#x9664;&#x4E86;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#xFF1A;</span>
        <span class="hljs-comment">// 1&#x3001;head = tail = null&#xFF08;&#x6B64;&#x65F6;&#x961F;&#x5217;&#x8FD8;&#x672A;&#x6709;&#x9636;&#x6BB5;&#x5165;&#x8FC7;&#x961F;&#xFF09;</span>
        <span class="hljs-comment">// 2&#x3001;head = tail = node&#xFF08;&#x6B64;&#x65F6;&#x961F;&#x5217;&#x91CC;&#x66FE;&#x7ECF;&#x6709;&#x5165;&#x8FC7;&#x961F;&#x7684;&#xFF0C;&#x4F46;&#x90FD;&#x5DF2;&#x51FA;&#x961F;&#xFF09;</span>
        <span class="hljs-comment">// (s = h.next) == null&#xFF08;&#x53EF;&#x80FD;&#x5B58;&#x5728;&#x4E00;&#x79CD;&#x60C5;&#x51B5;&#xFF0C;&#x8BBE;&#x7F6E;&#x4E86;head&#xFF0C;&#x4F46;&#x662F;next&#x8FD8;&#x6CA1;&#x6765;&#x5F97;&#x53CA;&#x8BBE;&#x7F6E;&#x4E3A;&#xFF08;&#x9664;&#x4E86;head&#x4E4B;&#x5916;&#xFF09;&#x7B2C;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x8282;&#x70B9;&#xFF0C;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;next&#x4E0D;&#x51C6;&#x786E;&#xFF0C;&#x56E0;&#x4E3A;&#x4E0D;&#x77E5;&#x9053;next&#x662F;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x8FD8;&#x662F;&#x5176;&#x4ED6;&#x7EBF;&#x7A0B;&#xFF0C;&#x4E3A;&#x4E86;&#x4FDD;&#x9669;&#x8D77;&#x89C1;&#xFF0C;&#x8FD4;&#x56DE;true&#xFF09;</span>
        <span class="hljs-comment">// s.thread != Thread.currentThread() &#xFF08;&#x8FD9;&#x4E2A;&#x7B80;&#x5355;&#x4E86;&#xFF0C;&#x5224;&#x65AD;&#x7B2C;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8282;&#x70B9;&#x662F;&#x4E0D;&#x662F;&#x8BE5;&#x7EBF;&#x7A0B;&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x4E0D;&#x662F;&#x7684;&#x8BDD;&#x8FD4;&#x56DE;true&#xFF09;</span>
        <span class="hljs-keyword">return</span> h != t &amp;&amp;
            ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());
    }


    <span class="hljs-comment">// Instrumentation and monitoring methods</span>
    <span class="hljs-comment">// &#x4EEA;&#x8868;&#x76D8;&#x548C;&#x76D1;&#x63A7;&#x65B9;&#x6CD5;</span>

    <span class="hljs-comment">/**
     * Returns an estimate of the number of threads waiting to
     * acquire.  The value is only an estimate because the number of
     * threads may change dynamically while this method traverses
     * internal data structures.  This method is designed for use in
     * monitoring system state, not for synchronization
     * control.
     * &#x8FD4;&#x56DE;&#x9884;&#x4F30;&#x7684;&#x7B49;&#x5F85;&#x83B7;&#x53D6;&#x7684;&#x7EBF;&#x7A0B;&#x6570;&#x3002;
     * &#x8FD9;&#x4E2A;&#x8FD4;&#x56DE;&#x503C;&#x53EA;&#x662F;&#x4E2A;&#x9884;&#x4F30;&#x503C;&#xFF0C;&#x56E0;&#x4E3A;&#x5728;&#x65B9;&#x6CD5;&#x904D;&#x5386;&#x5185;&#x90E8;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x65F6;&#xFF0C;&#x7EBF;&#x7A0B;&#x662F;&#x53EF;&#x80FD;&#x52A8;&#x6001;&#x53D8;&#x5316;&#x7684;&#x3002;
     * &#x8BE5;&#x65B9;&#x6CD5;&#x662F;&#x4E3A;&#x4E86;&#x76D1;&#x63A7;&#x7CFB;&#x7EDF;&#x72B6;&#x6001;&#x8BBE;&#x8BA1;&#x7684;&#xFF0C;&#x4E0D;&#x662F;&#x4E3A;&#x4E86;&#x540C;&#x6B65;&#x3002;
     *
     * <span class="hljs-doctag">@return</span> the estimated number of threads waiting to acquire
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQueueLength</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Node p = tail; p != <span class="hljs-keyword">null</span>; p = p.prev) { <span class="hljs-comment">// &#x518D;&#x6B21;&#x7406;&#x89E3;&#x4E00;&#x4E0B;&#xFF0C;&#x8BF4;&#x662F;queue&#xFF0C;&#x5176;&#x5B9E;&#x6CA1;&#x6709;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x961F;&#x5217;&#x957F;&#x5EA6;&#x7684;&#x5C5E;&#x6027;</span>
            <span class="hljs-keyword">if</span> (p.thread != <span class="hljs-keyword">null</span>)
                ++n;
        }
        <span class="hljs-keyword">return</span> n;
    }

    <span class="hljs-comment">/**
     * Returns a collection containing threads that may be waiting to
     * acquire.  Because the actual set of threads may change
     * dynamically while constructing this result, the returned
     * collection is only a best-effort estimate.  The elements of the
     * returned collection are in no particular order.  This method is
     * designed to facilitate construction of subclasses that provide
     * more extensive monitoring facilities.
     * &#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x6B63;&#x5728;&#x7B49;&#x5F85;&#x83B7;&#x53D6;&#x7684;&#x7EBF;&#x7A0B;&#x96C6;&#x5408;&#x3002;
     * &#x56E0;&#x4E3A;&#x5728;&#x6784;&#x9020;&#x8BE5;&#x96C6;&#x5408;&#x7ED3;&#x679C;&#x65F6;&#xFF0C;&#x5B9E;&#x9645;&#x7EBF;&#x7A0B;&#x53EF;&#x80FD;&#x5728;&#x52A8;&#x6001;&#x6539;&#x53D8;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x8FD4;&#x56DE;&#x7684;&#x96C6;&#x5408;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x5C3D;&#x529B;&#x7684;&#x9884;&#x4F30;&#x3002;
     * &#x8FD4;&#x56DE;&#x96C6;&#x5408;&#x91CC;&#x7684;&#x7EBF;&#x7A0B;&#x6CA1;&#x6709;&#x7279;&#x5B9A;&#x987A;&#x5E8F;&#x3002;
     * &#x8BE5;&#x65B9;&#x6CD5;&#x662F;&#x4E3A;&#x4E86;&#x4FC3;&#x8FDB;&#x5B50;&#x7C7B;&#x6784;&#x5EFA;&#x800C;&#x8BBE;&#x8BA1;&#xFF0C;&#x4EE5;&#x63D0;&#x9AD8;&#x66F4;&#x5E7F;&#x6CDB;&#x7684;&#x76D1;&#x63A7;&#x8BBE;&#x5907;
     *
     * <span class="hljs-doctag">@return</span> the collection of threads
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title">getQueuedThreads</span><span class="hljs-params">()</span> </span>{
        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Thread&gt;();
        <span class="hljs-keyword">for</span> (Node p = tail; p != <span class="hljs-keyword">null</span>; p = p.prev) {
            Thread t = p.thread;
            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)
                list.add(t);
        }
        <span class="hljs-keyword">return</span> list;
    }

    <span class="hljs-comment">/**
     * Returns a collection containing threads that may be waiting to
     * acquire in exclusive mode. This has the same properties
     * as {<span class="hljs-doctag">@link</span> #getQueuedThreads} except that it only returns
     * those threads waiting due to an exclusive acquire.
     * &#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x53EF;&#x80FD;&#x6B63;&#x5728;&#x72EC;&#x5360;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x96C6;&#x5408;&#x3002;
     * &#x8DDF;&#x4E0A;&#x9762;&#x7684;getQueueThreads&#x65B9;&#x6CD5;&#x7C7B;&#x4F3C;&#xFF0C;&#x9664;&#x4E86;&#x53EA;&#x8FD4;&#x56DE;&#x72EC;&#x5360;&#x83B7;&#x53D6;&#x7684;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;
     *
     * <span class="hljs-doctag">@return</span> the collection of threads
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title">getExclusiveQueuedThreads</span><span class="hljs-params">()</span> </span>{
        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Thread&gt;();
        <span class="hljs-keyword">for</span> (Node p = tail; p != <span class="hljs-keyword">null</span>; p = p.prev) {
            <span class="hljs-keyword">if</span> (!p.isShared()) { <span class="hljs-comment">// &#x53BB;&#x6389;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7684;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#xFF08;&#x5C31;&#x662F;&#x8BF4;&#x4E00;&#x4E2A;queue&#x91CC;&#x9762;&#x53EF;&#x80FD;&#x65E2;&#x6709;&#x72EC;&#x5360;&#xFF0C;&#x53C8;&#x6709;&#x5171;&#x4EAB;&#x7684;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#xFF09;</span>
                Thread t = p.thread;
                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)
                    list.add(t);
            }
        }
        <span class="hljs-keyword">return</span> list;
    }

    <span class="hljs-comment">/**
     * Returns a collection containing threads that may be waiting to
     * acquire in shared mode. This has the same properties
     * as {<span class="hljs-doctag">@link</span> #getQueuedThreads} except that it only returns
     * those threads waiting due to a shared acquire.
     * &#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x5728;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x96C6;&#x5408;&#x3002;
     *
     * <span class="hljs-doctag">@return</span> the collection of threads
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title">getSharedQueuedThreads</span><span class="hljs-params">()</span> </span>{
        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Thread&gt;();
        <span class="hljs-keyword">for</span> (Node p = tail; p != <span class="hljs-keyword">null</span>; p = p.prev) {
            <span class="hljs-keyword">if</span> (p.isShared()) { <span class="hljs-comment">// &#x53EA;&#x8981;&#x5171;&#x4EAB;&#x6A21;&#x5F0F;&#x4E0B;&#x7684;</span>
                Thread t = p.thread;
                <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)
                    list.add(t);
            }
        }
        <span class="hljs-keyword">return</span> list;
    }

    <span class="hljs-comment">/**
     * Returns a string identifying this synchronizer, as well as its state.
     * The state, in brackets, includes the String {<span class="hljs-doctag">@code</span> &quot;State =&quot;}
     * followed by the current value of {<span class="hljs-doctag">@link</span> #getState}, and either
     * {<span class="hljs-doctag">@code</span> &quot;nonempty&quot;} or {<span class="hljs-doctag">@code</span> &quot;empty&quot;} depending on whether the
     * queue is empty.
     * &#x8FD4;&#x56DE;&#x6807;&#x8BC6;&#x6B64;&#x540C;&#x6B65;&#x5668;&#x548C;state&#x7684;&#x5B57;&#x7B26;&#x4E32;&#xFF08;state&#x7531;&#x5B50;&#x7C7B;&#x5B9E;&#x73B0;&#xFF0C;&#x5728;AQS&#x4E2D;&#x6CA1;&#x4F7F;&#x7528;&#xFF09;
     * &#xFF08;bracket &#x62EC;&#x53F7;&#xFF09;
     * <span class="hljs-doctag">@return</span> a string identifying this synchronizer, as well as its state
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> s = getState();
        String q  = hasQueuedThreads() ? <span class="hljs-string">&quot;non&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString() +
            <span class="hljs-string">&quot;[State = &quot;</span> + s + <span class="hljs-string">&quot;, &quot;</span> + q + <span class="hljs-string">&quot;empty queue]&quot;</span>;
    }


    <span class="hljs-comment">// Internal support methods for Conditions</span>
    <span class="hljs-comment">// &#x5185;&#x90E8;&#x652F;&#x6301;Condition&#x7684;&#x65B9;&#x6CD5;</span>

    <span class="hljs-comment">/**
     * Returns true if a node, always one that was initially placed on
     * a condition queue, is now waiting to reacquire on sync queue.
     * &#x5982;&#x679C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x59CB;&#x7EC8;&#x662F;&#x6700;&#x521D;&#x653E;&#x5728;&#x6761;&#x4EF6;&#x961F;&#x5217;&#x4E2D;&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x73B0;&#x5728;&#x6B63;&#x5728;&#x7B49;&#x5F85;&#x91CD;&#x65B0;&#x83B7;&#x53D6;sync&#x961F;&#x5217;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;true
     * 
     * <span class="hljs-doctag">@param</span> node the node
     * <span class="hljs-doctag">@return</span> true if is reacquiring
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> </span>{
          <span class="hljs-comment">// &#x5982;&#x679C;&#x8282;&#x70B9;&#x7684;&#x7B49;&#x5F85;&#x72B6;&#x6001;&#x662F;CONDITION&#xFF0C;&#x8BF4;&#x660E;&#x5728;condition&#x961F;&#x5217;&#x4E2D;&#xFF08;&#x4E0D;&#x5728;AQS&#x4E3B;&#x961F;&#x5217;&#xFF09;&#xFF1B;</span>
          <span class="hljs-comment">// &#x5982;&#x679C;prev&#x662F;null&#xFF0C;&#x5E76;&#x4E14;&#x662F;AQS&#xFF0C;&#x4E5F;&#x662F;&#x5DF2;&#x83B7;&#x53D6;&#x5230;&#x9501;&#x7684;head&#x8282;&#x70B9;&#xFF0C;&#x4E5F;&#x4E0D;&#x5728;AQS&#x4E3B;&#x961F;&#x5217;&#x4E2D;&#x7B49;&#x5F85;</span>
        <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// If has successor, it must be on queue // &#x610F;&#x601D;&#x662F;&#x53EA;&#x6709;AQS&#x4E3B;&#x961F;&#x5217;&#x624D;&#x6709;next&#x8DDF;prev&#x5173;&#x7CFB;&#xFF0C;&#x5982;&#x679C;next&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x4E00;&#x5B9A;&#x5728;AQS sync&#x4E3B;&#x961F;&#x5217;&#x91CC;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">/*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         * node.prev&#x5982;&#x679C;&#x4E0D;&#x4E3A;null&#xFF0C;&#x4E0D;&#x80FD;&#x4FDD;&#x8BC1;&#x4E00;&#x5B9A;&#x5728;&#x961F;&#x5217;&#x91CC;&#xFF0C;&#x56E0;&#x4E3A;&#x901A;&#x8FC7;CAS&#x64CD;&#x4F5C;&#x5165;&#x961F;&#x65F6;&#x4F1A;&#x5931;&#x8D25;&#x3002;&#xFF08;&#x53EF;&#x4EE5;&#x770B;addWaiter&#x65B9;&#x6CD5;&#xFF0C;&#x5148;&#x8BBE;&#x7F6E;node.prev=tail&#xFF0C;&#x7136;&#x540E;&#x53BB;&#x505A;&#x7684;CAS&#xFF0C;&#x53EA;&#x6709;CAS&#x6210;&#x529F;&#x4E86;&#x624D;&#x7B97;&#x6210;&#x529F;&#x5165;&#x961F;&#xFF09;
         * &#x6240;&#x4EE5;&#x4ECE;tail&#x5411;&#x524D;&#x904D;&#x5386;&#xFF0C;&#x786E;&#x4FDD;&#x5B83;&#x786E;&#x5B9E;&#x5165;&#x961F;&#x4E86;&#x3002;
         * &#x9664;&#x975E;CAS&#x5931;&#x8D25;&#xFF08;&#x57FA;&#x672C;&#x4E0D;&#x592A;&#x53EF;&#x80FD;&#xFF09;&#xFF0C;&#x5426;&#x5219;&#x5728;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x65F6;&#x5B83;&#x603B;&#x662F;&#x9760;&#x8FD1;&#x5C3E;&#x90E8;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x4E0D;&#x4F1A;&#x904D;&#x5386;&#x592A;&#x591A;&#x3002;
         */</span>
        <span class="hljs-keyword">return</span> findNodeFromTail(node);
    }

    <span class="hljs-comment">/**
     * Returns true if node is on sync queue by searching backwards from tail.
     * Called only when needed by isOnSyncQueue.
     * &#x4ECE;sync&#x961F;&#x5217;&#x7684;tail&#x5411;&#x524D;&#x904D;&#x5386;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#x8BE5;&#x8282;&#x70B9;&#xFF0C;&#x5C31;&#x8FD4;&#x56DE;true
     *
     * <span class="hljs-doctag">@return</span> true if present
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNodeFromTail</span><span class="hljs-params">(Node node)</span> </span>{
        Node t = tail;
        <span class="hljs-keyword">for</span> (;;) {
            <span class="hljs-keyword">if</span> (t == node)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// &#x8981;&#x4E48;tail&#x4E3A;null&#xFF0C;&#x8981;&#x4E48;&#x627E;&#x5230;&#x4E86;head&#x7684;prev&#xFF0C;&#x4E5F;&#x662F;null&#xFF0C;&#x53EF;&#x4EE5;&#x770B;setHead</span>
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            t = t.prev;
        }
    }

    <span class="hljs-comment">/**
     * Transfers a node from a condition queue onto sync queue.
     * Returns true if successful.
     * &#x5C06;node&#x4ECE;condition&#x961F;&#x5217;&#x8F6C;&#x79FB;&#x5230;sync&#x961F;&#x5217;&#x3002;
     * &#x6210;&#x529F;&#x8F6C;&#x79FB;&#x8FD4;&#x56DE;true
     *
     * <span class="hljs-doctag">@param</span> node the node
     * <span class="hljs-doctag">@return</span> true if successfully transferred (else the node was
     * cancelled before signal)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>{
        <span class="hljs-comment">/*
         * If cannot change waitStatus, the node has been cancelled.
         * &#x5982;&#x679C;&#x4E0D;&#x80FD;&#x66F4;&#x6539;ws&#xFF0C;&#x8BF4;&#x660E;&#x8FD9;&#x4E2A;node&#x5DF2;&#x7ECF;&#x88AB;&#x53D6;&#x6D88;&#x4E86;&#x3002;&#xFF08;&#x5728;condition&#x961F;&#x5217;&#x4E0A;&#x7684;node&#x4E00;&#x5B9A;&#x662F;CONDITION&#x72B6;&#x6001;&#xFF0C;&#x5982;&#x679C;node&#x5B58;&#x6D3B;&#xFF0C;&#x4E00;&#x5B9A;&#x53EF;&#x4EE5;CAS&#x6539;&#x53D8;ws&#xFF09;
         */</span>
        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

        <span class="hljs-comment">/*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         * &#x62FC;&#x63A5;&#x5230;&#x961F;&#x5217;&#xFF0C;&#x5C1D;&#x8BD5;&#x8BBE;&#x7F6E;&#x524D;&#x9A71;&#x7684;ws&#x503C;&#xFF0C;&#x8868;&#x540D;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5728;&#xFF08;&#x53EF;&#x80FD;&#xFF09;&#x7B49;&#x5F85;&#x3002;
         * &#x5982;&#x679C;&#x524D;&#x9A71;&#x88AB;&#x53D6;&#x6D88;&#x6216;&#x8005;&#x8BD5;&#x56FE;&#x8BBE;&#x7F6E;&#x524D;&#x9A71;&#x7684;ws&#x5931;&#x8D25;&#xFF0C;&#x5219;&#x5524;&#x9192;&#x4EE5;&#x91CD;&#x65B0;&#x540C;&#x6B65;&#xFF08;&#x5728;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;waitStatus&#x4E0D;&#x5339;&#x914D;&#x53EF;&#x80FD;&#x662F;&#x6682;&#x65F6;&#x4E14;&#x65E0;&#x5BB3;&#x7684;&#x9519;&#x8BEF;&#xFF09;
         * 
         */</span>
        Node p = enq(node); <span class="hljs-comment">// &#x52A0;&#x5165;&#x5230;sync&#x961F;&#x5217;&#x4E2D;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x524D;&#x9A71;&#x8282;&#x70B9;</span>
        <span class="hljs-keyword">int</span> ws = p.waitStatus;
        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) <span class="hljs-comment">// &#x5982;&#x679C;&#x524D;&#x9A71;&#x7684;ws&gt;0&#xFF08;&#x8BF4;&#x660E;&#x524D;&#x9A71;&#x8282;&#x70B9;&#x88AB;cancel&#x4E86;&#xFF09;&#xFF0C;&#x6216;&#x8005;&#x8BBE;&#x7F6E;&#x524D;&#x9A71;&#x7684;ws&#x4E3A;SIGNAL&#x5931;&#x8D25;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;&#x5524;&#x9192;&#x5F53;&#x524D;&#x8FD9;&#x4E2A;node&#x53BB;&#x7ADE;&#x4E89;&#x8D44;&#x6E90;&#xFF08;&#x7ADE;&#x4E89;&#x4E0D;&#x5230;&#x548B;&#x529E;&#xFF1F;&#xFF1F;&#xFF1F;&#x7531;&#x5177;&#x4F53;&#x7684;&#x5B9E;&#x73B0;&#x53BB;&#x505A;&#xFF0C;&#x6BD4;&#x5982;&#x91CD;&#x65B0;&#x5165;&#x961F;&#xFF09;</span>
            LockSupport.unpark(node.thread);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-comment">/**
     * Transfers node, if necessary, to sync queue after a cancelled wait.
     * Returns true if thread was cancelled before being signalled.
     * &#x5982;&#x679C;&#x5FC5;&#x8981;&#x7684;&#x8BDD;&#xFF0C;&#x5728;&#x53D6;&#x6D88;&#x7B49;&#x5F85;&#x540E;&#xFF0C;&#x8F6C;&#x79FB;node&#x5230;sync&#x961F;&#x5217;&#x3002;&#xFF08;&#x8FD9;&#x4E2A;&#x53D6;&#x6D88;&#x7B49;&#x5F85;&#xFF0C;&#x4E0D;&#x662F;&#x5728;condition&#x961F;&#x5217;wait&#x65F6;&#x88AB;CANCEL&#x4E86;&#xFF0C;&#x800C;&#x662F;wait&#x7684;&#x6761;&#x4EF6;&#x6EE1;&#x8DB3;&#xFF0C;&#x6216;&#x8005;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x8D85;&#x65F6;&#xFF0C;&#x88AB;&#x5524;&#x9192;&#x4E86;&#xFF0C;&#x624D;&#x8C03;&#x7528;&#x7684;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF09;
     * &#x5982;&#x679C;&#x7EBF;&#x7A0B;&#x5728;&#x6536;&#x5230;&#x4FE1;&#x53F7;&#x524D;&#x53D6;&#x6D88;&#x7B49;&#x5F85;&#x4E86;&#xFF0C;&#x8FD4;&#x56DE;true
     *
     * <span class="hljs-doctag">@param</span> node the node
     * <span class="hljs-doctag">@return</span> true if cancelled before the node was signalled
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> </span>{
        <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) { <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x72B6;&#x6001;&#x4E3A;CONDITION&#xFF0C;&#x5219;&#x8FDB;&#x884C;&#x5165;sync&#x961F;&#x5217;&#x64CD;&#x4F5C;</span>
            enq(node);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-comment">// &#x4E0D;&#x4E3A;CONDITION&#x72B6;&#x6001;&#x7684;&#x8BDD;&#xFF0C;&#x6709;&#x4E24;&#x79CD;&#x60C5;&#x51B5;</span>
        <span class="hljs-comment">// 1&#x3001;CANCEL &#x8BF4;&#x660E;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x88AB;&#x53D6;&#x6D88;&#x4E86;&#xFF0C;&#x4F46;&#x4E0D;&#x77E5;&#x9053;&#x662F;&#x5728;&#x961F;&#x5217;&#x91CC;&#x88AB;&#x53D6;&#x6D88;&#x8FD8;&#x662F;&#x6CA1;&#x5728;&#x961F;&#x5217;&#x91CC;&#x88AB;&#x53D6;&#x6D88;</span>
        <span class="hljs-comment">// 2&#x3001;&#x5176;&#x4ED6;&#x72B6;&#x6001; &#x8BF4;&#x660E;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x5728;&#x961F;&#x5217;&#x91CC;</span>
        <span class="hljs-comment">// &#x4E0A;&#x9762;&#x90A3;&#x53E5;&#x8BDD;&#x4E0D;&#x5BF9;&#xFF0C;&#x5176;&#x5B9E;&#x4E0D;&#x4E3A;CONDITION&#x53EA;&#x6709;&#x4E00;&#x79CD;&#x60C5;&#x51B5;&#xFF0C;&#x90A3;&#x5C31;&#x662F;&#x8BE5;node&#x5DF2;&#x7ECF;&#x8FDB;&#x4E86;sync&#x961F;&#x5217;&#xFF0C;&#x5E76;&#x4E14;ws&#x53D1;&#x751F;&#x4E86;&#x53D8;&#x5316;&#x3002;&#x5728;condition&#x961F;&#x5217;&#x91CC;ws&#x662F;&#x4E0D;&#x4F1A;&#x53D8;&#x7684;&#x3002;&#x8FD9;&#x53E5;&#x8BDD;&#x4E5F;&#x4E0D;&#x5BF9;&#xFF0C;condition&#x91CC;&#x9762;&#x72B6;&#x6001;&#x53EF;&#x4EE5;&#x53D8;&#x3002;</span>
        <span class="hljs-comment">/*
         * If we lost out to a signal(), then we can&apos;t proceed
         * until it finishes its enq().  Cancelling during an
         * incomplete transfer is both rare and transient, so just
         * spin.
         * &#x5982;&#x679C;&#x6211;&#x4EEC;&#x8F93;&#x7ED9;&#x4E86;signal&#x65B9;&#x6CD5;&#xFF0C;&#x90A3;&#x4E48;&#x5728;&#x5B83;&#x5B8C;&#x6210;enq()&#x4E4B;&#x524D;&#x4E0D;&#x80FD;&#x7EE7;&#x7EED;&#x505A;&#x522B;&#x7684;&#x3002;
         * &#x5728;&#x672A;&#x5B8C;&#x6210;&#x8F6C;&#x79FB;&#x65F6;&#x53D6;&#x6D88;&#xFF0C;&#x662F;&#x7F55;&#x89C1;&#x53C8;&#x77ED;&#x6682;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x53EA;&#x9700;&#x8981;&#x81EA;&#x65CB;&#x3002;
         */</span>
        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))
            Thread.yield();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }

    <span class="hljs-comment">/**
     * Invokes release with current state value; returns saved state.
     * Cancels node and throws exception on failure.
     * &#x5728;&#x5F53;&#x524D;state&#x503C;&#x4E0B;&#x8C03;&#x7528;release&#xFF1B;
     * &#x8FD4;&#x56DE;&#x4FDD;&#x5B58;&#x7684;state&#x503C;
     * &#x5728;&#x5931;&#x8D25;&#x65F6;&#x53D6;&#x6D88;&#x8282;&#x70B9;&#x5E76;&#x629B;&#x51FA;&#x5F02;&#x5E38;
     * 
     * <span class="hljs-doctag">@param</span> node the condition node for this wait
     * <span class="hljs-doctag">@return</span> previous sync state
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>{
        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">int</span> savedState = getState();
            <span class="hljs-keyword">if</span> (release(savedState)) { <span class="hljs-comment">// &#x7528;&#x5F53;&#x524D;state&#x503C;&#x4F5C;&#x4E3A;release(arg)&#x7684;&#x5165;&#x53C2;&#xFF0C;&#x5982;&#x679C;&#x81EA;&#x5B9A;&#x4E49;&#x7684;tryRelease&#x8FD4;&#x56DE;true&#xFF0C;&#x4ECE;head&#x5F00;&#x59CB;&#x5524;&#x9192;&#x540E;&#x7EE7;&#x8282;&#x70B9;</span>
                failed = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">return</span> savedState;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
            }
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">if</span> (failed)
                node.waitStatus = Node.CANCELLED; <span class="hljs-comment">// &#x5982;&#x679C;&#x5524;&#x9192;&#x5931;&#x8D25;&#xFF0C;&#x5C31;&#x53D6;&#x6D88;&#x5F53;&#x524D;&#x8282;&#x70B9;&#xFF08;&#x8FD9;&#x662F;&#x4E2A;&#x4EC0;&#x4E48;&#x64CD;&#x4F5C;&#xFF1F;&#xFF09;</span>
        }
    }

    <span class="hljs-comment">// Instrumentation methods for conditions</span>
    <span class="hljs-comment">// condition&#x7684;&#x68C0;&#x6D4B;&#x65B9;&#x6CD5;</span>

    <span class="hljs-comment">/**
     * Queries whether the given ConditionObject
     * uses this synchronizer as its lock.
     * &#x67E5;&#x8BE2;&#x7ED9;&#x5B9A;&#x7684;ConditionObject&#x662F;&#x5426;&#x7528;&#x8BE5;&#x540C;&#x6B65;&#x5668;&#x4F5C;&#x4E3A;&#x5B83;&#x7684;&#x9501;
     *
     * <span class="hljs-doctag">@param</span> condition the condition
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if owned
     * <span class="hljs-doctag">@throws</span> NullPointerException if the condition is null
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">owns</span><span class="hljs-params">(ConditionObject condition)</span> </span>{
        <span class="hljs-keyword">return</span> condition.isOwnedBy(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">/**
     * Queries whether any threads are waiting on the given condition
     * associated with this synchronizer. Note that because timeouts
     * and interrupts may occur at any time, a {<span class="hljs-doctag">@code</span> true} return
     * does not guarantee that a future {<span class="hljs-doctag">@code</span> signal} will awaken
     * any threads.  This method is designed primarily for use in
     * monitoring of the system state.
     * &#x67E5;&#x8BE2;&#x662F;&#x5426;&#x6709;&#x7EBF;&#x7A0B;&#x5728;&#x7ED9;&#x5B9A;&#x7684;condition&#x5173;&#x8054;&#x7684;&#x540C;&#x6B65;&#x5668;&#x4E0A;&#x7B49;&#x5F85;&#x3002;
     * &#x6CE8;&#x610F;&#xFF0C;&#x7531;&#x4E8E;&#x8D85;&#x65F6;&#x548C;&#x4E2D;&#x65AD;&#x53EF;&#x80FD;&#x5728;&#x4EFB;&#x610F;&#x65F6;&#x523B;&#x53D1;&#x751F;&#xFF0C;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;true&#x4E0D;&#x4FDD;&#x8BC1;&#x672A;&#x6765;signal&#x53EF;&#x4EE5;&#x5524;&#x9192;&#x7EBF;&#x7A0B;&#x3002;
     * &#x8BE5;&#x65B9;&#x6CD5;&#x8BBE;&#x8BA1;&#x7684;&#x610F;&#x56FE;&#x662F;&#x4E3A;&#x4E86;&#x5728;&#x76D1;&#x63A7;&#x7CFB;&#x7EDF;&#x4E2D;&#x4F7F;&#x7528;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> condition the condition
     * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if there are any waiting threads
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * <span class="hljs-doctag">@throws</span> NullPointerException if the condition is null
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasWaiters</span><span class="hljs-params">(ConditionObject condition)</span> </span>{
        <span class="hljs-keyword">if</span> (!owns(condition)) <span class="hljs-comment">// &#x5982;&#x679C;condition&#x6CA1;&#x6709;&#x5173;&#x8054;&#x5230;&#x672C;AbstractQueuedSynchronizer&#xFF08;sync)</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Not owner&quot;</span>);
        <span class="hljs-keyword">return</span> condition.hasWaiters(); <span class="hljs-comment">// &#x5982;&#x679C;&#x6709;&#x5728;CONDITION&#x4E0A;&#x7B49;&#x5F85;&#x6761;&#x4EF6;&#x7684;&#xFF0C;&#x8FD4;&#x56DE;true</span>
    }

    <span class="hljs-comment">/**
     * Returns an estimate of the number of threads waiting on the
     * given condition associated with this synchronizer. Note that
     * because timeouts and interrupts may occur at any time, the
     * estimate serves only as an upper bound on the actual number of
     * waiters.  This method is designed for use in monitoring of the
     * system state, not for synchronization control.
     * &#x8FD4;&#x56DE;&#x9884;&#x4F30;&#x7684;&#x5728;&#x7ED9;&#x5B9A;&#x7684;condition&#x5173;&#x8054;&#x7684;&#x540C;&#x6B65;&#x5668;&#x4E0A;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x6570;&#x3002;
     * &#x6CE8;&#x610F;&#xFF0C;&#x7531;&#x4E8E;&#x8D85;&#x65F6;&#x4E0E;&#x4E2D;&#x65AD;&#x53EF;&#x80FD;&#x5728;&#x4EFB;&#x610F;&#x65F6;&#x523B;&#x53D1;&#x751F;&#xFF0C;&#x9884;&#x4F30;&#x7684;&#x670D;&#x52A1;&#x6570;&#x662F;&#x5B9E;&#x9645;&#x670D;&#x52A1;&#x6570;&#x7684;&#x4E0A;&#x9650;&#x3002;
     * &#x8BE5;&#x65B9;&#x6CD5;&#x53EA;&#x662F;&#x8BBE;&#x8BA1;&#x7528;&#x4F5C;&#x76D1;&#x63A7;&#x7CFB;&#x7EDF;&#x7684;&#xFF0C;&#x4E0D;&#x662F;&#x4E3A;&#x4E86;&#x540C;&#x6B65;&#x63A7;&#x5236;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> condition the condition
     * <span class="hljs-doctag">@return</span> the estimated number of waiting threads
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * <span class="hljs-doctag">@throws</span> NullPointerException if the condition is null
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWaitQueueLength</span><span class="hljs-params">(ConditionObject condition)</span> </span>{
        <span class="hljs-keyword">if</span> (!owns(condition))
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Not owner&quot;</span>);
        <span class="hljs-keyword">return</span> condition.getWaitQueueLength();
    }

    <span class="hljs-comment">/**
     * Returns a collection containing those threads that may be
     * waiting on the given condition associated with this
     * synchronizer.  Because the actual set of threads may change
     * dynamically while constructing this result, the returned
     * collection is only a best-effort estimate. The elements of the
     * returned collection are in no particular order.
     * &#x8FD4;&#x56DE;&#x5305;&#x542B;&#x53EF;&#x80FD;&#x5728;&#x7ED9;&#x5B9A;condition&#x5173;&#x8054;&#x7684;&#x540C;&#x6B65;&#x5668;&#x4E0A;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x96C6;&#x5408;&#x3002;
     * &#x7531;&#x4E8E;&#x5728;&#x7ED3;&#x6784;&#x5316;&#x751F;&#x6210;&#x7ED3;&#x679C;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5B9E;&#x9645;&#x4E0A;&#x7EBF;&#x7A0B;&#x662F;&#x52A8;&#x6001;&#x53D8;&#x5316;&#x7684;&#xFF0C;&#x8FD9;&#x4E2A;&#x8FD4;&#x56DE;&#x7ED3;&#x679C;&#x7A3D;&#x6838;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x5C3D;&#x529B;&#x9884;&#x4F30;&#x503C;&#x3002;
     * &#x8FD4;&#x56DE;&#x7684;&#x7A3D;&#x6838;&#x5143;&#x7D20;&#x6CA1;&#x6709;&#x7279;&#x5B9A;&#x7684;&#x987A;&#x5E8F;&#x3002;
     *
     * <span class="hljs-doctag">@param</span> condition the condition
     * <span class="hljs-doctag">@return</span> the collection of threads
     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if exclusive synchronization
     *         is not held
     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the given condition is
     *         not associated with this synchronizer
     * <span class="hljs-doctag">@throws</span> NullPointerException if the condition is null
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title">getWaitingThreads</span><span class="hljs-params">(ConditionObject condition)</span> </span>{
        <span class="hljs-keyword">if</span> (!owns(condition))
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Not owner&quot;</span>);
        <span class="hljs-keyword">return</span> condition.getWaitingThreads();
    }

    <span class="hljs-comment">/**
     * Condition implementation for a {<span class="hljs-doctag">@link</span>
     * AbstractQueuedSynchronizer} serving as the basis of a {<span class="hljs-doctag">@link</span>
     * Lock} implementation.
     * &#x4F5C;&#x4E3A;AQS&#x670D;&#x52A1;&#x7684;&#x6761;&#x4EF6;&#x5B9E;&#x73B0;&#xFF0C;&#x4F5C;&#x4E3A;Lock&#x5B9E;&#x73B0;&#x7684;&#x57FA;&#x7840;&#x3002;
     *
     * &lt;p&gt;Method documentation for this class describes mechanics,
     * not behavioral specifications from the point of view of Lock
     * and Condition users. Exported versions of this class will in
     * general need to be accompanied by documentation describing
     * condition semantics that rely on those of the associated
     * {<span class="hljs-doctag">@code</span> AbstractQueuedSynchronizer}.
     * &#x8BE5;&#x7C7B;&#x7684;&#x65B9;&#x6CD5;&#x8BF4;&#x660E;&#x4ECE;&#x4F7F;&#x7528;&#x8005;&#x7684;&#x89D2;&#x5EA6;&#x63CF;&#x8FF0;Lock&#x4E0E;Condition&#x7684;&#x673A;&#x5236;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x884C;&#x4E3A;&#x89C4;&#x8303;&#x3002;
     * &#x8BE5;&#x7C7B;&#x7684;&#x5BFC;&#x51FA;&#x7248;&#x672C;&#x901A;&#x5E38;&#x9700;&#x8981;&#x8DDF;&#x4F9D;&#x8D56;&#x5173;&#x8054;&#x7684;AQS&#x7684;&#x6761;&#x4EF6;&#x8BED;&#x4E49;&#x6587;&#x6863;&#x4E00;&#x8D77;&#x770B;&#x3002;
     *
     * &lt;p&gt;This class is Serializable, but all fields are transient,
     * so deserialized conditions have no waiters.
     * class&#x662F;&#x53EF;&#x5E8F;&#x5217;&#x5316;&#x7684;&#xFF0C;&#x4E0D;&#x8FC7;&#x6240;&#x6709;&#x7684;&#x5B57;&#x6BB5;&#x90FD;&#x662F;transient&#xFF08;&#x6682;&#x65F6;&#x7684;&#xFF09;&#xFF0C;&#x6240;&#x4EE5;&#x53CD;&#x5E8F;&#x5217;&#x5316;&#x7684;condition&#x6CA1;&#x6709;&#x4EFB;&#x4F55;waiter&#x3002;
     *
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>{
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1173984872572414699L</span>; <span class="hljs-comment">// &#x7528;&#x6765;&#x9A8C;&#x8BC1;&#x7248;&#x672C;&#x4E00;&#x81F4;&#x6027;&#x3002;&#x6839;&#x636E;&#x5305;&#x540D;&#xFF0C;&#x7C7B;&#x540D;&#xFF0C;&#x7EE7;&#x627F;&#x5173;&#x7CFB;&#xFF0C;&#x975E;&#x79C1;&#x6709;&#x7684;&#x65B9;&#x6CD5;&#x548C;&#x5C5E;&#x6027;&#xFF0C;&#x4EE5;&#x53CA;&#x53C2;&#x6570;&#xFF0C;&#x8FD4;&#x56DE;&#x503C;&#x7B49;&#x8BF8;&#x591A;&#x56E0;&#x5B50;&#x8BA1;&#x7B97;&#x5F97;&#x51FA;&#x7684;&#xFF0C;&#x6781;&#x5EA6;&#x590D;&#x6742;&#x751F;&#x6210;&#x7684;&#x4E00;&#x4E2A;64&#x4F4D;&#x7684;&#x54C8;&#x5E0C;&#x5B57;&#x6BB5;&#x3002;&#x57FA;&#x672C;&#x4E0A;&#x8BA1;&#x7B97;&#x51FA;&#x6765;&#x7684;&#x8FD9;&#x4E2A;&#x503C;&#x662F;&#x552F;&#x4E00;&#x7684;&#x3002;&#x9ED8;&#x8BA4;&#x662F;1L&#x3002;</span>
        <span class="hljs-comment">/** First node of condition queue. */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter; <span class="hljs-comment">// firstWaiter&#x662F;&#x4E2A;Node&#x7C7B;&#x578B;&#xFF0C;&#x5177;&#x6709;prev&#x3001;next&#x3001;thread&#x7B49;&#x5C5E;&#x6027;&#xFF0C;&#x8FD8;&#x6709;nextWaiter&#x8FD9;&#x79CD;&#x5C5E;&#x6027;</span>
        <span class="hljs-comment">/** Last node of condition queue. */</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter; <span class="hljs-comment">// lastWaiter&#x662F;&#x4E2A;Node&#x7C7B;&#x578B;</span>

        <span class="hljs-comment">/**
         * Creates a new {<span class="hljs-doctag">@code</span> ConditionObject} instance.
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>{ }

        <span class="hljs-comment">// Internal methods</span>
        <span class="hljs-comment">// &#x5185;&#x90E8;&#x65B9;&#x6CD5;</span>

        <span class="hljs-comment">/**
         * Adds a new waiter to wait queue.
         * <span class="hljs-doctag">@return</span> its new wait node
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>{
            Node t = lastWaiter;
            <span class="hljs-comment">// If lastWaiter is cancelled, clean out. // &#x5982;&#x679C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x53D6;&#x6D88;&#x4E86;&#xFF0C;&#x6E05;&#x7406;&#x6389;&#x3002;</span>
            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters(); <span class="hljs-comment">// &#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x8FDB;&#x884C;&#x5B8C;&#x6574;&#x904D;&#x5386;&#xFF0C;&#x7559;&#x4E0B;ws=CONDITION&#x7684;&#x8282;&#x70B9;</span>
                t = lastWaiter; <span class="hljs-comment">// unlink&#x4F1A;&#x66F4;&#x65B0;lastWaiter&#xFF0C;&#x91CD;&#x65B0;&#x6307;&#x5411;lastWaiter</span>
            }
            Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION); <span class="hljs-comment">// &#x5C01;&#x88C5;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E3A;Node&#xFF0C;&#x9ED8;&#x8BA4;ws&#x4E3A;CONDITION</span>
            <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// &#x6CA1;&#x6709;lastWaiter&#xFF0C;&#x8BF4;&#x660E;&#x5F53;&#x524D;condition&#x961F;&#x5217;&#x4E3A;&#x7A7A;&#xFF0C;&#x8BA9;firstWaiter&#x6307;&#x5411;&#x8BE5;&#x8282;&#x70B9;</span>
                firstWaiter = node;
            <span class="hljs-keyword">else</span>
                t.nextWaiter = node; <span class="hljs-comment">// &#x5426;&#x5219;&#x8BA9;&#x5F53;&#x524D;lastWaiter&#x7684;next&#x6307;&#x5411;&#x8BE5;&#x8282;&#x70B9;</span>
            lastWaiter = node; <span class="hljs-comment">// &#x8BBE;&#x7F6E;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x4E3A;lastWaiter</span>
            <span class="hljs-keyword">return</span> node;
        }

        <span class="hljs-comment">/**
         * Removes and transfers nodes until hit non-cancelled one or
         * null. Split out from signal in part to encourage compilers
         * to inline the case of no waiters.
         * &#x8F6C;&#x79FB;&#x548C;&#x79FB;&#x9664;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x5230;&#x547D;&#x4E2D;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x8282;&#x70B9;&#x6216;&#x8005;&#x904D;&#x5386;&#x5B8C;&#x6CA1;&#x6709;&#x975E;null&#x8282;&#x70B9;&#x3002;
         * &#x4ECE;signal&#x4E2D;&#x5206;&#x79BB;&#x51FA;&#x6765;&#xFF0C;&#x4E00;&#x90E8;&#x5206;&#x662F;&#x4E3A;&#x4E86;&#x9F13;&#x52B1;&#x7F16;&#x8BD1;&#x5668;&#x5185;&#x8054;&#x6CA1;&#x6709;waiters&#x7684;&#x60C5;&#x51B5;&#x3002;
         *
         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>{
              <span class="hljs-comment">// &#x76EE;&#x6807;&#x5C31;&#x662F;&#x5C06;firstWaiter&#x8282;&#x70B9;&#x8F6C;&#x79FB;&#x5230;sync&#x961F;&#x5217;&#x91CC;&#xFF0C;&#x7136;&#x540E;&#x79FB;&#x9664;&#x8BE5;&#x8282;&#x70B9;&#x3002;first&#x4E3A;&#x975E;&#x7A7A;&#x7684;firstWaiter&#x3002;&#xFF08;&#x5982;&#x679C;&#x662F;null&#xFF0C;&#x4F1A;&#x5BFC;&#x81F4;transferForSignal(first)&#x62A5;&#x9519;&#xFF09;</span>
            do {
                <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 1&#x3001;&#x8BA9;firstWaiter&#x6307;&#x5411;firstWaiter&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;</span>
                    lastWaiter = <span class="hljs-keyword">null</span>;                         <span class="hljs-comment">// 2&#x3001;&#x5982;&#x679C;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x4E3A;&#x7A7A;&#xFF0C;&#x8BF4;&#x660E;condition&#x961F;&#x5217;&#x91CC;&#x6CA1;&#x6709;&#x7B49;&#x5F85;&#x8282;&#x70B9;&#x4E86;&#xFF0C;lastWaiter&#x4E5F;&#x7F6E;&#x4E3A;&#x7A7A;</span>
                first.nextWaiter = <span class="hljs-keyword">null</span>;                       <span class="hljs-comment">// 3&#x3001;&#x65AD;&#x5F00;&#x5373;&#x5C06;&#x79FB;&#x5165;sync&#x961F;&#x5217;&#x7684;&#x8282;&#x70B9;next&#x5F15;&#x7528;</span>
            } <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;              <span class="hljs-comment">// 4&#x3001;&#x5982;&#x679C;&#x8BE5;&#x8282;&#x70B9;&#x72B6;&#x6001;&#x975E;CONDITION&#xFF0C;&#x8868;&#x793A;&#x8BE5;&#x8282;&#x70B9;&#x5DF2;CANCEL&#xFF0C;&#x8FD4;&#x56DE;false&#xFF0C;&#x8868;&#x793A;&#x65E0;&#x6CD5;&#x5165;&#x961F;&#xFF0C;&#x5426;&#x5219;&#x5C06;&#x8BE5;&#x8282;&#x70B9;enq&#x5165;&#x961F;&#xFF0C;&#x5982;&#x679C;&#x5165;&#x961F;&#x5931;&#x8D25;&#xFF0C;&#x4F1A;unpark&#x8BE5;&#x8282;&#x70B9;&#x76F4;&#x63A5;&#x7ADE;&#x4E89;&#x9501;</span>
                     (first = firstWaiter) != <span class="hljs-keyword">null</span>);           <span class="hljs-comment">// 5&#x3001;&#x8BA9;first&#x6307;&#x5411;firstWaiter&#xFF0C;&#x5982;&#x679C;&#x73B0;&#x5728;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x4E0D;&#x4E3A;null&#xFF0C;&#x5E76;&#x4E14;&#x4E0A;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x5DF2;&#x7ECF;&#x88AB;&#x53D6;&#x6D88;&#x4E86;&#xFF0C;&#x90A3;&#x4E48;&#x5C1D;&#x8BD5;&#x91CA;&#x653E;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x3002;</span>
        }

        <span class="hljs-comment">/**
         * Removes and transfers all nodes.
         * &#x8F6C;&#x79FB;&#x548C;&#x79FB;&#x9664;&#x6240;&#x6709;&#x8282;&#x70B9;
         *
         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>{
            lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// &#x53CD;&#x6B63;&#x90FD;&#x8981;&#x79FB;&#x9664;&#x4E86;&#xFF0C;&#x5565;&#x4E5F;&#x4E0D;&#x7BA1;&#x76F4;&#x63A5;&#x90FD;&#x7F6E;&#x4E3A;null</span>
            do {
                Node next = first.nextWaiter; <span class="hljs-comment">// &#x904D;&#x5386;&#x975E;null&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x6709;&#x4E00;&#x4E2A;&#x7B97;&#x4E00;&#x4E2A;&#xFF0C;&#x90FD;&#x7ED9;&#x6254;&#x5230;transferForSignal(first)&#x65B9;&#x6CD5;&#x4E2D;&#x53BB;&#x8F6C;&#x79FB;&#x5230;sync&#x961F;&#x5217;&#x91CC;&#xFF0C;&#x7136;&#x540E;&#x79FB;&#x9664;&#x3002;</span>
                first.nextWaiter = <span class="hljs-keyword">null</span>;
                transferForSignal(first);
                first = next;
            } <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);
        }

        <span class="hljs-comment">/**
         * Unlinks cancelled waiter nodes from condition queue.
         * Called only while holding lock. This is called when
         * cancellation occurred during condition wait, and upon
         * insertion of a new waiter when lastWaiter is seen to have
         * been cancelled. This method is needed to avoid garbage
         * retention in the absence of signals. So even though it may
         * require a full traversal, it comes into play only when
         * timeouts or cancellations occur in the absence of
         * signals. It traverses all nodes rather than stopping at a
         * particular target to unlink all pointers to garbage nodes
         * without requiring many re-traversals during cancellation
         * storms.
         * &#x4ECE;&#x6761;&#x4EF6;&#x961F;&#x5217;&#x4E2D;&#x53D6;&#x6D88;&#x8FDE;&#x63A5;&#x7684;cancel waiter&#x8282;&#x70B9;&#x3002;
         * &#x53EA;&#x6709;&#x5728;&#x6301;&#x6709;&#x9501;&#x7684;&#x65F6;&#x5019;&#x624D;&#x4F1A;&#x88AB;&#x8C03;&#x7528;&#x3002;
         * &#x5F53;&#x5728;&#x6761;&#x4EF6;&#x7B49;&#x5F85;&#x65F6;&#x53D1;&#x751F;&#x53D6;&#x6D88;&#xFF0C;&#x5728;&#x63D2;&#x5165;&#x65B0;&#x7684;waiter&#x65F6;&#x53D1;&#x73B0;&#x6700;&#x540E;&#x7684;waiter&#x5DF2;&#x7ECF;&#x88AB;&#x53D6;&#x6D88;&#x65F6;&#xFF0C;&#x4F1A;&#x8C03;&#x7528;&#x5230;&#x8BE5;&#x65B9;&#x6CD5;&#x3002;&#xFF08;&#x53D1;&#x73B0;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x88AB;&#x53D6;&#x6D88;&#x65F6;&#x4F1A;&#x8C03;&#x7528;&#xFF0C;&#x904D;&#x5386;&#x5219;&#x662F;&#x4ECE;&#x5934;&#x5F00;&#x59CB;&#x5411;&#x540E;&#x904D;&#x5386;&#xFF09;
         * &#x9700;&#x8981;&#x8BE5;&#x65B9;&#x6CD5;&#x5728;&#x6CA1;&#x6709;&#x4FE1;&#x53F7;&#xFF08;absence &#x7F3A;&#x5E2D;&#xFF09;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x907F;&#x514D;&#x5783;&#x573E;&#x4FDD;&#x7559;&#x3002;
         * &#x56E0;&#x6B64;&#xFF0C;&#x5373;&#x4F7F;&#x5B83;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x5168;&#x90E8;&#x904D;&#x5386;&#xFF0C;&#x5B83;&#x4E5F;&#x4EC5;&#x5728;&#x6CA1;&#x6709;&#x4FE1;&#x53F7;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x53D1;&#x751F;&#x8D85;&#x65F6;&#x6216;&#x8005;&#x53D6;&#x6D88;&#x65F6;&#x624D;&#x8D77;&#x4F5C;&#x7528;&#x3002;
         * &#x5B83;&#x904D;&#x5386;&#x6240;&#x6709;&#x8282;&#x70B9;&#x800C;&#x4E0D;&#x662F;&#x5728;&#x7279;&#x5B9A;&#x8282;&#x70B9;&#x5904;&#x505C;&#x6B62;&#xFF0C;&#x4EE5;&#x53D6;&#x6D88;&#x6240;&#x6709;&#x6307;&#x5411;&#x5783;&#x573E;&#x8282;&#x70B9;&#x7684;&#x6307;&#x9488;&#xFF0C;&#x800C;&#x4E0D;&#x9700;&#x8981;&#x5728;&#x53D6;&#x6D88;&#x98CE;&#x66B4;&#x4E2D;&#x591A;&#x6B21;&#x91CD;&#x65B0;&#x904D;&#x5386;&#x3002;
         *
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlinkCancelledWaiters</span><span class="hljs-params">()</span> </span>{
            Node t = firstWaiter; <span class="hljs-comment">// &#x4ECE;&#x7B2C;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x5F00;&#x59CB;&#x5411;&#x540E;&#x904D;&#x5386;</span>
            Node trail = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// trail&#x4FDD;&#x7559;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x8282;&#x70B9;&#x5F15;&#x7528;&#xFF08;&#x6BCF;&#x5F53;&#x53D1;&#x73B0;&#x4E00;&#x4E2A;&#x540E;&#x7EED;&#x672A;&#x53D6;&#x6D88;&#x8282;&#x70B9;&#xFF0C;&#x8FD9;&#x4E2A;trail&#x5C31;&#x53D8;&#x4E3A;&#x6307;&#x5411;&#x8BE5;&#x8282;&#x70B9;&#xFF09;</span>
            <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>) {
                Node next = t.nextWaiter;
                <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) { <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;ws&#x4E0D;&#x662F;CONDITION&#xFF0C;&#x8BF4;&#x660E;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x4E0D;&#x518D;&#x7B49;&#x5F85;&#x4E86;&#xFF08;&#x5C31;&#x662F;&#x53D6;&#x6D88;&#x4E86;&#xFF09;&#xFF0C;&#x9700;&#x8981;&#x53D6;&#x6D88;&#x8FDE;&#x63A5;</span>
                    t.nextWaiter = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// &#x65AD;&#x5F00;&#x8BE5;&#x8282;&#x70B9;&#x4E0E;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x5173;&#x8054;&#xFF0C;</span>
                    <span class="hljs-keyword">if</span> (trail == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// &#x5982;&#x679C;&#x73B0;&#x5728;&#x5269;&#x4F59;&#x8282;&#x70B9;link&#x4E3A;&#x7A7A;&#xFF0C;&#x8BF4;&#x660E;&#x73B0;&#x5728;&#x8FD8;&#x6CA1;&#x6709;&#x8282;&#x70B9;&#x7559;&#x4E0B;&#x6765;</span>
                        firstWaiter = next; <span class="hljs-comment">// &#x628A;&#x7B2C;&#x4E00;&#x4E2A;&#x7559;&#x4E0B;&#x6765;&#x7684;&#x8282;&#x70B9;&#x4F5C;&#x4E3A;firstWaiter</span>
                    <span class="hljs-keyword">else</span>
                        trail.nextWaiter = next; <span class="hljs-comment">// &#x5426;&#x5219;&#x5C31;&#x628A;&#x5F53;&#x524D;&#x8282;&#x70B9;&#xFF08;&#x51C6;&#x5907;&#x6E05;&#x7406;&#x7684;&#x8282;&#x70B9;&#xFF09;&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x52A0;&#x5165;&#x5230;&#x5269;&#x4F59;&#x8282;&#x70B9;link&#x4E2D;&#xFF08;&#x901A;&#x8FC7;trail&#x4FDD;&#x7559;&#x622A;&#x6B62;&#x5230;&#x76EE;&#x524D;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x5F15;&#x7528;&#xFF0C;&#x4F7F;&#x7528;next&#x6765;&#x6784;&#x5EFA;link&#xFF09;</span>
                    <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// &#x5982;&#x679C;&#x6CA1;&#x6709;&#x540E;&#x7EED;waiter&#x4E86;</span>
                        lastWaiter = trail; <span class="hljs-comment">// lastWaiter&#x6307;&#x5411;&#x5269;&#x4F59;&#x8282;&#x70B9;link&#x7684;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;</span>
                }
                <span class="hljs-keyword">else</span>
                    trail = t; <span class="hljs-comment">// &#x5F53;&#x524D;&#x8282;&#x70B9;&#x4E0D;&#x7528;&#x53D6;&#x6D88;&#xFF0C;link&#x6CA1;&#x53D8;&#x5316;&#xFF0C;&#x76F4;&#x63A5;&#x8BA9;trail&#x6307;&#x5411;&#x5F53;&#x524D;&#x672A;&#x53D6;&#x6D88;&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x7EE7;&#x7EED;&#x5411;&#x540E;&#x904D;&#x5386;</span>
                t = next; <span class="hljs-comment">// &#x51C6;&#x5907;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x904D;&#x5386;</span>
            }
        }

        <span class="hljs-comment">// public methods</span>
        <span class="hljs-comment">// &#x516C;&#x5171;&#x65B9;&#x6CD5;</span>

        <span class="hljs-comment">/**
         * Moves the longest-waiting thread, if one exists, from the
         * wait queue for this condition to the wait queue for the
         * owning lock.
         * &#x5982;&#x679C;&#x6709;&#x7B49;&#x5F85;&#x7EBF;&#x7A0B;&#x7684;&#x8BDD;&#xFF0C;&#x5C06;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x6700;&#x957F;&#x7684;&#x7EBF;&#x7A0B;&#x4ECE;&#x7B49;&#x5F85;condition&#x7684;&#x961F;&#x5217;&#x8F6C;&#x79FB;&#x5230;&#x7B49;&#x5F85;lock&#x7684;&#x961F;&#x5217;
         *
         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if {<span class="hljs-doctag">@link</span> #isHeldExclusively}
         *         returns {<span class="hljs-doctag">@code</span> false}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-comment">// &#x9996;&#x5148;&#x8981;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5F97;&#x6301;&#x6709;&#x9501;&#xFF08;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;true&#xFF09;</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
            Node first = firstWaiter; <span class="hljs-comment">// &#x6392;&#x5728;&#x7B2C;&#x4E00;&#x4E2A;&#x7684;&#x7EBF;&#x7A0B;&#x8282;&#x70B9;&#xFF0C;&#x5C31;&#x662F;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x6700;&#x957F;&#x7684;&#xFF08;&#x56E0;&#x4E3A;&#x5148;&#x6765;&#x5148;&#x5165;&#x961F;&#x5148;&#x7B49;&#x5F85;&#xFF09;</span>
            <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// &#x5982;&#x679C;&#x4E0A;&#x6765;&#x5C31;&#x662F;null&#xFF0C;&#x5C31;&#x4E0D;&#x8F6C;&#x79FB;&#x4E86;</span>
                doSignal(first);
        }

        <span class="hljs-comment">/**
         * Moves all threads from the wait queue for this condition to
         * the wait queue for the owning lock.
         * &#x628A;&#x6240;&#x6709;&#x7684;&#x7EBF;&#x7A0B;Node&#x4ECE;&#x7B49;&#x5F85;condition&#x7684;&#x961F;&#x5217;&#x8F6C;&#x79FB;&#x5230;&#x7B49;&#x5F85;lock&#x7684;&#x961F;&#x5217;&#x3002;
         *
         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if {<span class="hljs-doctag">@link</span> #isHeldExclusively}
         *         returns {<span class="hljs-doctag">@code</span> false}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!isHeldExclusively())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
            Node first = firstWaiter;
            <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)
                doSignalAll(first);
        }

        <span class="hljs-comment">/**
         * Implements uninterruptible condition wait.
         * &#x5B9E;&#x73B0;&#x975E;&#x4E2D;&#x65AD;&#x7684;condition&#x7B49;&#x5F85;
         *
         * &lt;ol&gt;
         * &lt;li&gt; Save lock state returned by {<span class="hljs-doctag">@link</span> #getState}.
         * &lt;li&gt; Invoke {<span class="hljs-doctag">@link</span> #release} with saved state as argument,
         *      throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled.
         * &lt;li&gt; Reacquire by invoking specialized version of
         *      {<span class="hljs-doctag">@link</span> #acquire} with saved state as argument.
         * &lt;/ol&gt;
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span> </span>{
            Node node = addConditionWaiter(); <span class="hljs-comment">// &#x5C06;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x5C01;&#x88C5;&#x6210;Node&#x6DFB;&#x52A0;&#x5230;&#x7B49;&#x5F85;condition&#x961F;&#x5217;&#x4E2D;</span>
            <span class="hljs-keyword">int</span> savedState = fullyRelease(node); <span class="hljs-comment">// &#x8FD9;&#x91CC;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x53BB;&#x91CA;&#x653E;&#x5462;&#xFF1F;&#x91CA;&#x653E;&#x4E0D;&#x6210;&#x529F;&#x8FD8;&#x4F1A;&#x76F4;&#x63A5;cancel  &#x8FD9;&#x91CC;&#x7ED3;&#x5408;&#x573A;&#x666F;&#x8BF4;&#x4E00;&#x4E0B;&#xFF0C;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x60F3;&#x8981;&#x5728;condition&#x4E0A;&#x505A;await&#x64CD;&#x4F5C;&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x4E00;&#x5B9A;&#x662F;&#x5DF2;&#x7ECF;&#x83B7;&#x53D6;&#x5230;&#x9501;&#x4E86;&#xFF0C;&#x8FD9;&#x662F;&#x7B2C;&#x4E00;&#x3002;&#x7B2C;&#x4E8C;&#xFF0C;&#x5DF2;&#x83B7;&#x53D6;&#x5230;&#x9501;&#x7684;&#x7EBF;&#x7A0B;&#x9700;&#x8981;await&#xFF0C;&#x90A3;&#x4E48;&#x5B83;&#x4E00;&#x5B9A;&#x8981;&#x91CA;&#x653E;&#x9501;&#xFF0C;&#x628A;&#x8D44;&#x6E90;&#x4EA4;&#x51FA;&#x53BB;&#xFF0C;&#x76F4;&#x5230;&#x5B83;&#x88AB;&#x5524;&#x9192;&#x8FDB;&#x884C;&#x7ADE;&#x4E89;&#x3002;</span>
            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) { <span class="hljs-comment">// &#x5224;&#x65AD;&#x5F53;&#x524D;node&#x662F;&#x5426;&#x5DF2;&#x5728;sync&#x961F;&#x5217;&#x91CC;&#xFF08;&#x5C31;&#x662F;&#x7B49;&#x5F85;lock&#x7684;&#x961F;&#x5217;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x7684;&#x8BDD;&#xFF0C;&#x5C31;&#x81EA;&#x5DF1;&#x963B;&#x585E;&#x4E86;</span>
                LockSupport.park(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">if</span> (Thread.interrupted()) <span class="hljs-comment">// &#x5373;&#x4F7F;&#x6709;&#x4E2D;&#x65AD;&#xFF0C;&#x4E5F;&#x53EA;&#x662F;&#x8BB0;&#x5F55;&#x72B6;&#x6001;&#xFF0C;&#x4E0D;&#x54CD;&#x5E94;</span>
                    interrupted = <span class="hljs-keyword">true</span>;
            }
            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="hljs-comment">// &#x80FD;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x8BF4;&#x660E;&#x5DF2;&#x7ECF;&#x5728;sync&#x961F;&#x5217;&#x91CC;&#x4E86;&#xFF0C;&#x5C1D;&#x8BD5;&#x83B7;&#x53D6;&#x9501;&#xFF0C;&#x83B7;&#x53D6;&#x5931;&#x8D25;&#x4E5F;&#x963B;&#x585E;&#x3002;&#x5982;&#x679C;&#x5728;&#x52A0;&#x5165;sync&#x961F;&#x5217;&#x65F6;&#x53D1;&#x751F;&#x4E86;&#x4E2D;&#x65AD;&#xFF0C;&#x6216;&#x8005;&#x5728;sync&#x83B7;&#x53D6;&#x9501;&#x7684;&#x65F6;&#x5019;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#xFF0C;&#x90FD;&#x4F1A;&#x91CD;&#x65B0;&#x4E2D;&#x65AD;&#x3002;</span>
                selfInterrupt();
        }

        <span class="hljs-comment">/*
         * For interruptible waits, we need to track whether to throw
         * InterruptedException, if interrupted while blocked on
         * condition, versus reinterrupt current thread, if
         * interrupted while blocked waiting to re-acquire.
         * &#x5BF9;&#x4E8E;&#x53EF;&#x4E2D;&#x65AD;&#x7684;waits&#xFF0C;&#x9700;&#x8981;&#x8DDF;&#x8E2A;&#x662F;&#x5426;&#x629B;&#x51FA;InterruptedException&#xFF0C;
         * &#x5982;&#x679C;&#x5728;condition&#x963B;&#x585E;&#x8FC7;&#x7A0B;&#x4E2D;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#xFF0C;
         * &#x76F8;&#x5BF9;&#x7684;&#x91CD;&#x65B0;&#x4E2D;&#x65AD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;
         * &#x5982;&#x679C;&#x5728;&#x7B49;&#x5F85;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x7684;&#x963B;&#x585E;&#x65F6;&#x53D1;&#x751F;&#x4E2D;&#x65AD;
         */</span>

        <span class="hljs-comment">/** Mode meaning to reinterrupt on exit from wait */</span>
        <span class="hljs-comment">// &#x5728;&#x9000;&#x51FA;&#x65F6;&#x91CD;&#x65B0;&#x4E2D;&#x65AD;</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REINTERRUPT =  <span class="hljs-number">1</span>;
        <span class="hljs-comment">/** Mode meaning to throw InterruptedException on exit from wait */</span>
        <span class="hljs-comment">// &#x5728;&#x9000;&#x51FA;&#x65F6;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THROW_IE    = -<span class="hljs-number">1</span>;

        <span class="hljs-comment">/**
         * Checks for interrupt, returning THROW_IE if interrupted
         * before signalled, REINTERRUPT if after signalled, or
         * 0 if not interrupted.
         * &#x68C0;&#x67E5;&#x4E2D;&#x65AD;
         * &#x5982;&#x679C;&#x5728;&#x83B7;&#x53D6;&#x5230;signal&#x4E4B;&#x524D;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#xFF0C;&#x8FD4;&#x56DE;THROW_IE
         * &#x5982;&#x679C;&#x5728;&#x83B7;&#x53D6;&#x5230;signal&#x4E4B;&#x540E;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#xFF0C;&#x8FD4;&#x56DE;REINTERRUPT
         * &#x6CA1;&#x6709;&#x4E2D;&#x65AD;&#x53D1;&#x751F;&#xFF0C;&#x8FD4;&#x56DE;0
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> </span>{
            <span class="hljs-keyword">return</span> Thread.interrupted() ?
                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="hljs-comment">// transferAfterCancelledWait&#x5982;&#x679C;&#x80FD;&#x6210;&#x529F;&#x5C06;ws&#x4ECE;CONDITION&#x66F4;&#x65B0;&#x6210;0&#xFF0C;&#x4F1A;&#x5C1D;&#x8BD5;&#x5C06;node&#x52A0;&#x5165;&#x5230;sync&#x961F;&#x5217;&#xFF0C;&#x8FD4;&#x56DE;true&#x8868;&#x793A;&#x88AB;signal&#x4E4B;&#x524D;&#x88AB;cancel</span>
                <span class="hljs-number">0</span>;
        }

        <span class="hljs-comment">/**
         * Throws InterruptedException, reinterrupts current thread, or
         * does nothing, depending on mode.
         * &#x6839;&#x636E;&#x6A21;&#x5F0F;&#xFF0C;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;&#xFF0C;&#x6216;&#x8005;&#x91CD;&#x65B0;&#x4E2D;&#x65AD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#xFF0C;&#x6216;&#x8005;&#x5565;&#x4E5F;&#x4E0D;&#x505A;
         *
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interruptMode)</span>
            <span class="hljs-keyword">throws</span> InterruptedException </span>{
            <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)
                selfInterrupt();
        }

        <span class="hljs-comment">/**
         * Implements interruptible condition wait.
         * &#x5B9E;&#x73B0;&#x53EF;&#x4E2D;&#x65AD;condition&#x7B49;&#x5F85;
         *
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {<span class="hljs-doctag">@link</span> #getState}.
         * &lt;li&gt; Invoke {<span class="hljs-doctag">@link</span> #release} with saved state as argument,
         *      throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled or interrupted.
         * &lt;li&gt; Reacquire by invoking specialized version of
         *      {<span class="hljs-doctag">@link</span> #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * 1&#x3001;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;
         * 2&#x3001;&#x4FDD;&#x5B58;&#x7531;getState&#x8FD4;&#x56DE;&#x7684;&#x9501;&#x7684;state&#x503C;&#x3002;
         * 3&#x3001;&#x8C03;&#x7528;release&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#xFF0C;&#x5982;&#x679C;release&#x5931;&#x8D25;&#xFF0C;&#x629B;&#x51FA;IllegalMonitorStateException&#x5F02;&#x5E38;&#x3002;&#xFF08;&#x8BF4;&#x660E;&#x8BE5;&#x7EBF;&#x7A0B;&#x7684;&#x64CD;&#x4F5C;&#x975E;&#x6CD5;&#xFF0C;&#x7C7B;&#x4F3C;&#x4E8E;Ojbect&#x4E0A;&#x7684;wait&#x4E0E;notify&#xFF09;
         * 4&#x3001;&#x963B;&#x585E;&#xFF0C;&#x76F4;&#x5230;&#x88AB;&#x5524;&#x9192;&#x6216;&#x8005;&#x88AB;&#x4E2D;&#x65AD;
         * 5&#x3001;&#x901A;&#x8FC7;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#xFF0C;&#x8C03;&#x7528;&#x7279;&#x6B8A;&#x7248;&#x672C;&#x7684;acquire&#x65B9;&#x6CD5;&#xFF0C;&#x6765;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x3002;
         * 6&#x3001;&#x5982;&#x679C;&#x5728;&#x7B2C;4&#x6B65;&#x963B;&#x585E;&#x65F6;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;&#x3002;
         *
         * &lt;/ol&gt;
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{
            <span class="hljs-keyword">if</span> (Thread.interrupted())                                           <span class="hljs-comment">// 0&#x3001;&#x4E0A;&#x6765;&#x5148;&#x770B;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x4E2D;&#x65AD;&#x4E86;&#xFF0C;&#x76F4;&#x63A5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
            Node node = addConditionWaiter();                                   <span class="hljs-comment">// 1&#x3001;&#x5C06;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x52A0;&#x5165;&#x5230;Condition&#x961F;&#x5217;&#x4E2D;&#x3002;&#x4E0E;&#x4E0D;&#x53EF;&#x4E2D;&#x65AD;&#x7684;await&#x4E00;&#x6837;</span>
            <span class="hljs-keyword">int</span> savedState = fullyRelease(node);                                <span class="hljs-comment">// 2&#x3001;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x653E;&#x5F03;&#x5BF9;&#x9501;&#x7684;&#x7ADE;&#x4E89;&#xFF0C;&#x91CA;&#x653E;&#x8D44;&#x6E90;&#x5524;&#x9192;&#x540E;&#x7EE7;&#x8FDB;&#x884C;&#x9501;&#x83B7;&#x53D6;</span>
            <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;                                              <span class="hljs-comment">// </span>
            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) {                                      <span class="hljs-comment">// 3&#x3001;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;node&#x662F;&#x5426;&#x5728;sync&#x961F;&#x5217;&#x91CC;</span>
                LockSupport.park(<span class="hljs-keyword">this</span>);                                         <span class="hljs-comment">// 4&#x3001;&#x5982;&#x679C;&#x4E0D;&#x5728;sync&#x961F;&#x5217;&#xFF0C;&#x8BF4;&#x660E;&#x6CA1;&#x6709;&#x6EE1;&#x8DB3;&#x7684;Condition&#xFF0C;&#x8FDB;&#x884C;park</span>
                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)    <span class="hljs-comment">// 5&#x3001;&#x68C0;&#x67E5;&#x5728;wait&#x65F6;&#x53D1;&#x751F;&#x7684;&#x4E2D;&#x65AD;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x4E2D;&#x65AD;&#xFF0C;&#x8FD4;&#x56DE;0&#xFF0C;&#x5F53;&#x8FD4;&#x56DE;&#x503C;!=0&#x65F6;&#xFF0C;&#x8DF3;&#x51FA;&#x5FAA;&#x73AF;&#x7B49;&#x5F85;</span>
                    <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)    <span class="hljs-comment">// 6&#x3001;&#x8C03;&#x7528;&#x4E0D;&#x53EF;&#x4E2D;&#x65AD;&#x7684;acquireQueued&#x65B9;&#x6CD5;&#x7ADE;&#x4E89;&#xFF0C;&#x7ADE;&#x4E89;&#x6210;&#x529F;&#x8FD4;&#x56DE;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#x3002;&#x5982;&#x679C;&#x7ADE;&#x4E89;&#x65F6;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#xFF0C;&#x5E76;&#x4E14;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x4E3A;THROW_IE&#xFF08;&#x5728;&#x83B7;&#x53D6;&#x5230;&#x4FE1;&#x53F7;&#x4E4B;&#x524D;&#x5C31;&#x88AB;&#x4E2D;&#x65AD;&#x4E86;&#xFF09;</span>
                interruptMode = REINTERRUPT;                                     <span class="hljs-comment">// 7&#x3001;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x6539;&#x4E3A;REINTERRUPT&#xFF08;&#x5728;&#x83B7;&#x53D6;&#x4FE1;&#x53F7;&#x4E4B;&#x540E;&#x88AB;&#x4E2D;&#x65AD;&#xFF09;</span>
            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled               // 8&#x3001;&#x5982;&#x679C;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;nextWaiter&#x4E0D;&#x4E3A;null&#xFF0C;&#x4ECE;CONDITION&#x961F;&#x5217;&#x7684;firstWaiter&#x5F00;&#x59CB;&#x6E05;&#x7406;&#x4E00;&#x904D;&#x975E;CONDITION&#x72B6;&#x6001;&#x7684;&#x8282;&#x70B9;</span>
                unlinkCancelledWaiters();
            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)                                              <span class="hljs-comment">// 9&#x3001;&#x5982;&#x679C;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#x4E0D;&#x662F;0&#xFF08;&#x610F;&#x5473;&#x7740;&#x53D1;&#x751F;&#x8FC7;&#x4E2D;&#x65AD;&#xFF09;&#xFF0C;&#x6309;&#x7167;&#x4E2D;&#x65AD;&#x6A21;&#x5F0F;&#xFF0C;&#x8C03;&#x7528;reportInterruptAfterWait&#x65B9;&#x6CD5;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x6216;&#x8005;&#x6062;&#x590D;&#x4E2D;&#x65AD;&#x72B6;&#x6001;&#xFF08;&#x5C31;&#x662F;&#x91CD;&#x65B0;&#x5C06;&#x4E2D;&#x65AD;&#x6807;&#x8BC6;&#x4F4D;&#x7F6E;&#x4E3A;&#x4E2D;&#x65AD;&#xFF09;</span>
                reportInterruptAfterWait(interruptMode);
        }

        <span class="hljs-comment">/**
         * Implements timed condition wait.
         * &#x5B9E;&#x73B0;&#x8D85;&#x65F6;condition&#x7B49;&#x5F85;
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {<span class="hljs-doctag">@link</span> #getState}.
         * &lt;li&gt; Invoke {<span class="hljs-doctag">@link</span> #release} with saved state as argument,
         *      throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled, interrupted, or timed out.
         * &lt;li&gt; Reacquire by invoking specialized version of
         *      {<span class="hljs-doctag">@link</span> #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * 1&#x3001;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;InterruptedException&#x3002;
         * 2&#x3001;&#x4FDD;&#x5B58;getState&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x7684;state&#x503C;&#x3002;
         * 3&#x3001;&#x8C03;&#x7528;release&#x65B9;&#x6CD5;&#xFF0C;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x3002;&#x5982;&#x679C;&#x8C03;&#x7528;&#x5931;&#x8D25;&#xFF0C;&#x629B;&#x51FA;IllegalMonitorStateException&#x3002;
         * 4&#x3001;&#x963B;&#x585E;&#xFF0C;&#x76F4;&#x5230;&#x88AB;&#x5524;&#x9192;&#xFF0C;&#x6216;&#x8005;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x6216;&#x8005;&#x8D85;&#x65F6;&#x3002;
         * 5&#x3001;&#x901A;&#x8FC7;&#x5E26;&#x7740;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x8C03;&#x7528;&#x7279;&#x6B8A;&#x7248;&#x672C;&#x7684;acquire&#x65B9;&#x6CD5;&#xFF0C;&#x6765;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x3002;
         * 6&#x3001;&#x5982;&#x679C;&#x5728;&#x6B65;&#x9AA4;4&#x963B;&#x585E;&#x65F6;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;&#x3002;
         *
         * &lt;/ol&gt;
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span>
                <span class="hljs-keyword">throws</span> InterruptedException </span>{
            <span class="hljs-keyword">if</span> (Thread.interrupted())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
            Node node = addConditionWaiter();
            <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;
            <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) {
                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) {
                    transferAfterCancelledWait(node); <span class="hljs-comment">// &#x5982;&#x679C;&#x8D85;&#x65F6;&#x65F6;&#x95F4;&lt;=0&#xFF0C;&#x8C03;&#x7528;transferAfterCancelledWait&#x65B9;&#x6CD5;&#x5C1D;&#x8BD5;&#x8FDB;&#x884C;&#x8BE5;node&#x5165;sync&#x961F;&#x5217;&#x3002;</span>
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold) <span class="hljs-comment">// &#x5982;&#x679C;&#x5269;&#x4F59;&#x7684;&#x8D85;&#x65F6;&#x65F6;&#x95F4;&#x6BD4;&#x81EA;&#x65CB;&#x7684;&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#x9608;&#x503C;&#x9AD8;&#xFF0C;&#x90A3;&#x4E48;&#x76F4;&#x63A5;park</span>
                    LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);
                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>) <span class="hljs-comment">// &#x68C0;&#x67E5;&#x662F;&#x5426;&#x53D1;&#x751F;&#x8FC7;&#x4E2D;&#x65AD;&#xFF0C;&#x5982;&#x679C;&#x6709;&#xFF0C;&#x8DF3;&#x51FA;&#x5FAA;&#x73AF;</span>
                    <span class="hljs-keyword">break</span>;
                nanosTimeout = deadline - System.nanoTime();
            }
            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)
                unlinkCancelledWaiters();
            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
                reportInterruptAfterWait(interruptMode);
            <span class="hljs-keyword">return</span> deadline - System.nanoTime(); <span class="hljs-comment">// &#x8FD4;&#x56DE;&#x5269;&#x4F59;&#x7684;&#x7B49;&#x5F85;&#x7EB3;&#x79D2;&#x6570;</span>
        }

        <span class="hljs-comment">/**
         * Implements absolute timed condition wait.
         * &#x5B9E;&#x73B0;&#x7EDD;&#x5BF9;&#x5B9A;&#x65F6;condition&#x7B49;&#x5F85;&#x3002;
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {<span class="hljs-doctag">@link</span> #getState}.
         * &lt;li&gt; Invoke {<span class="hljs-doctag">@link</span> #release} with saved state as argument,
         *      throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled, interrupted, or timed out.
         * &lt;li&gt; Reacquire by invoking specialized version of
         *      {<span class="hljs-doctag">@link</span> #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.
         * 1&#x3001;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;InterruptedException&#x3002;
         * 2&#x3001;&#x4FDD;&#x5B58;getState&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x7684;state&#x503C;&#x3002;
         * 3&#x3001;&#x8C03;&#x7528;release&#x65B9;&#x6CD5;&#xFF0C;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x3002;&#x5982;&#x679C;&#x8C03;&#x7528;&#x5931;&#x8D25;&#xFF0C;&#x629B;&#x51FA;IllegalMonitorStateException&#x3002;
         * 4&#x3001;&#x963B;&#x585E;&#xFF0C;&#x76F4;&#x5230;&#x88AB;&#x5524;&#x9192;&#xFF0C;&#x6216;&#x8005;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x6216;&#x8005;&#x8D85;&#x65F6;&#x3002;
         * 5&#x3001;&#x901A;&#x8FC7;&#x5E26;&#x7740;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x8C03;&#x7528;&#x7279;&#x6B8A;&#x7248;&#x672C;&#x7684;acquire&#x65B9;&#x6CD5;&#xFF0C;&#x6765;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x3002;
         * 6&#x3001;&#x5982;&#x679C;&#x5728;&#x6B65;&#x9AA4;4&#x963B;&#x585E;&#x65F6;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;&#x3002;
         * 7&#x3001;&#x5982;&#x679C;&#x5728;&#x6B65;&#x9AA4;4&#x8D85;&#x65F6;&#x4E86;&#xFF0C;&#x8FD4;&#x56DE;false&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE;true&#x3002;         
         * &lt;/ol&gt;
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span>
                <span class="hljs-keyword">throws</span> InterruptedException </span>{
            <span class="hljs-keyword">long</span> abstime = deadline.getTime();
            <span class="hljs-keyword">if</span> (Thread.interrupted())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
            Node node = addConditionWaiter();
            <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
            <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) {
                <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; abstime) {
                    timedout = transferAfterCancelledWait(node); <span class="hljs-comment">// transferAfterCancelledWait&#x5982;&#x679C;&#x5728;&#x4FE1;&#x53F7;&#x4E4B;&#x524D;&#x53D6;&#x6D88;&#x4E86;wait&#xFF0C;&#x8FD4;&#x56DE;true&#xFF08;&#x8D85;&#x65F6;&#x4E86;&#x8FD4;&#x56DE;true&#xFF09;</span>
                    <span class="hljs-keyword">break</span>;
                }
                LockSupport.parkUntil(<span class="hljs-keyword">this</span>, abstime);
                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)
                unlinkCancelledWaiters();
            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
                reportInterruptAfterWait(interruptMode);
            <span class="hljs-keyword">return</span> !timedout; <span class="hljs-comment">// &#x8D85;&#x65F6;&#x4E86;&#x8FD4;&#x56DE;false&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE;true</span>
        }

        <span class="hljs-comment">/**
         * Implements timed condition wait.
         * &#x5B9E;&#x73B0;&#x8D85;&#x65F6;condition&#x7B49;&#x5F85;
         * &lt;ol&gt;
         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
         * &lt;li&gt; Save lock state returned by {<span class="hljs-doctag">@link</span> #getState}.
         * &lt;li&gt; Invoke {<span class="hljs-doctag">@link</span> #release} with saved state as argument,
         *      throwing IllegalMonitorStateException if it fails.
         * &lt;li&gt; Block until signalled, interrupted, or timed out.
         * &lt;li&gt; Reacquire by invoking specialized version of
         *      {<span class="hljs-doctag">@link</span> #acquire} with saved state as argument.
         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
         * &lt;li&gt; If timed out while blocked in step 4, return false, else true.
         * 1&#x3001;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;InterruptedException&#x3002;
         * 2&#x3001;&#x4FDD;&#x5B58;getState&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x7684;state&#x503C;&#x3002;
         * 3&#x3001;&#x8C03;&#x7528;release&#x65B9;&#x6CD5;&#xFF0C;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x4F5C;&#x4E3A;&#x53C2;&#x6570;&#x3002;&#x5982;&#x679C;&#x8C03;&#x7528;&#x5931;&#x8D25;&#xFF0C;&#x629B;&#x51FA;IllegalMonitorStateException&#x3002;
         * 4&#x3001;&#x963B;&#x585E;&#xFF0C;&#x76F4;&#x5230;&#x88AB;&#x5524;&#x9192;&#xFF0C;&#x6216;&#x8005;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x6216;&#x8005;&#x8D85;&#x65F6;&#x3002;
         * 5&#x3001;&#x901A;&#x8FC7;&#x5E26;&#x7740;&#x4FDD;&#x5B58;&#x7684;state&#x503C;&#x8C03;&#x7528;&#x7279;&#x6B8A;&#x7248;&#x672C;&#x7684;acquire&#x65B9;&#x6CD5;&#xFF0C;&#x6765;&#x91CD;&#x65B0;&#x83B7;&#x53D6;&#x3002;
         * 6&#x3001;&#x5982;&#x679C;&#x5728;&#x6B65;&#x9AA4;4&#x963B;&#x585E;&#x65F6;&#x88AB;&#x4E2D;&#x65AD;&#xFF0C;&#x629B;&#x51FA;&#x4E2D;&#x65AD;&#x5F02;&#x5E38;&#x3002;
         * 7&#x3001;&#x5982;&#x679C;&#x5728;&#x6B65;&#x9AA4;4&#x8D85;&#x65F6;&#x4E86;&#xFF0C;&#x8FD4;&#x56DE;false&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE;true&#x3002;
         * &lt;/ol&gt;
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span>
                <span class="hljs-keyword">throws</span> InterruptedException </span>{
            <span class="hljs-keyword">long</span> nanosTimeout = unit.toNanos(time);
            <span class="hljs-keyword">if</span> (Thread.interrupted())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();
            Node node = addConditionWaiter();
            <span class="hljs-keyword">int</span> savedState = fullyRelease(node);
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deadline = System.nanoTime() + nanosTimeout;
            <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) {
                <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) {
                    timedout = transferAfterCancelledWait(node);
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)
                    LockSupport.parkNanos(<span class="hljs-keyword">this</span>, nanosTimeout);
                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)
                    <span class="hljs-keyword">break</span>;
                nanosTimeout = deadline - System.nanoTime();
            }
            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>)
                unlinkCancelledWaiters();
            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)
                reportInterruptAfterWait(interruptMode);
            <span class="hljs-keyword">return</span> !timedout;
        }

        <span class="hljs-comment">//  support for instrumentation</span>

        <span class="hljs-comment">/**
         * Returns true if this condition was created by the given
         * synchronization object.
         * &#x5982;&#x679C;&#x8BE5;condition&#x662F;&#x901A;&#x8FC7;&#x7ED9;&#x5B9A;&#x7684;&#x540C;&#x6B65;&#x5668;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x8FD4;&#x56DE;true
         *
         * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if owned
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOwnedBy</span><span class="hljs-params">(AbstractQueuedSynchronizer sync)</span> </span>{
            <span class="hljs-keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="hljs-keyword">this</span>;
        }

        <span class="hljs-comment">/**
         * Queries whether any threads are waiting on this condition.
         * Implements {<span class="hljs-doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.
         * &#x67E5;&#x8BE2;&#x662F;&#x5426;&#x5728;&#x8BE5;condition&#x4E0A;&#x6709;&#x7EBF;&#x7A0B;&#x5728;&#x7B49;&#x5F85;&#x3002;
         *
         * <span class="hljs-doctag">@return</span> {<span class="hljs-doctag">@code</span> true} if there are any waiting threads
         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if {<span class="hljs-doctag">@link</span> #isHeldExclusively}
         *         returns {<span class="hljs-doctag">@code</span> false}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasWaiters</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!isHeldExclusively()) <span class="hljs-comment">// &#x5982;&#x679C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6CA1;&#x6709;&#x72EC;&#x5360;&#x9501;&#xFF0C;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x662F;&#x9700;&#x8981;&#x72EC;&#x5360;&#x9501;&#x81EA;&#x5DF1;&#x5B9E;&#x73B0;&#x7684;&#x4E09;&#x4E2A;&#x65B9;&#x6CD5;&#x4E4B;&#x4E00;&#x3002;</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
            <span class="hljs-keyword">for</span> (Node w = firstWaiter; w != <span class="hljs-keyword">null</span>; w = w.nextWaiter) { <span class="hljs-comment">// &#x4ECE;&#x7B2C;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x8282;&#x70B9;&#x5F00;&#x59CB;&#x627E;&#xFF0C;&#x5982;&#x679C;&#x6709;waitStatus&#x662F;CONDITION&#x7684;&#xFF0C;&#x8868;&#x793A;&#x5728;&#x7B49;&#x5F85;&#x6761;&#x4EF6;&#xFF0C;&#x8FD4;&#x56DE;true</span>
                <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION) <span class="hljs-comment">// &#xFF08;&#x5728;CONDITION&#x961F;&#x5217;&#x4E0A;&#x7684;&#xFF0C;ws&#x53EA;&#x6709;CONDITION&#x8DDF;CANCEL&#x72B6;&#x6001;&#x4E48;&#xFF1F;&#xFF09;</span>
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }

        <span class="hljs-comment">/**
         * Returns an estimate of the number of threads waiting on
         * this condition.
         * Implements {<span class="hljs-doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.
         * &#x8FD4;&#x56DE;&#x9884;&#x4F30;&#x7684;&#x5728;&#x8BE5;condition&#x4E0A;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x6570;
         * AbstractQueuedSynchronizer&#x7684;getWaitQueueLength(ConditionObject)&#x65B9;&#x6CD5;&#x4F1A;&#x8C03;&#x7528;
         *
         * <span class="hljs-doctag">@return</span> the estimated number of waiting threads
         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if {<span class="hljs-doctag">@link</span> #isHeldExclusively}
         *         returns {<span class="hljs-doctag">@code</span> false}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWaitQueueLength</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!isHeldExclusively())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
            <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (Node w = firstWaiter; w != <span class="hljs-keyword">null</span>; w = w.nextWaiter) {
                <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION)
                    ++n;
            }
            <span class="hljs-keyword">return</span> n;
        }

        <span class="hljs-comment">/**
         * Returns a collection containing those threads that may be
         * waiting on this Condition.
         * Implements {<span class="hljs-doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.
         * &#x8FD4;&#x56DE;&#x5305;&#x542B;&#x53EF;&#x80FD;&#x5728;&#x8BE5;Condition&#x4E0A;&#x7B49;&#x5F85;&#x7684;&#x7EBF;&#x7A0B;&#x96C6;&#x5408;&#x3002;
         *
         * <span class="hljs-doctag">@return</span> the collection of threads
         * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if {<span class="hljs-doctag">@link</span> #isHeldExclusively}
         *         returns {<span class="hljs-doctag">@code</span> false}
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title">getWaitingThreads</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!isHeldExclusively())
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();
            ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Thread&gt;();
            <span class="hljs-keyword">for</span> (Node w = firstWaiter; w != <span class="hljs-keyword">null</span>; w = w.nextWaiter) {
                <span class="hljs-keyword">if</span> (w.waitStatus == Node.CONDITION) {
                    Thread t = w.thread;
                    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>)
                        list.add(t);
                }
            }
            <span class="hljs-keyword">return</span> list;
        }
    }

    <span class="hljs-comment">/**
     * Setup to support compareAndSet. We need to natively implement
     * this here: For the sake of permitting future enhancements, we
     * cannot explicitly subclass AtomicInteger, which would be
     * efficient and useful otherwise. So, as the lesser of evils, we
     * natively implement using hotspot intrinsics API. And while we
     * are at it, we do the same for other CASable fields (which could
     * otherwise be done with atomic field updaters).
     * &#x8BBE;&#x7F6E;&#x4EE5;&#x652F;&#x6301;CAS&#x3002;
     * &#x9700;&#x8981;&#x5728;&#x8FD9;&#x91CC;&#x8FDB;&#x884C;&#x672C;&#x5730;&#x5B9E;&#x73B0;&#xFF1A;
     * &#x4E3A;&#x4E86;&#x5141;&#x8BB8;&#x672A;&#x6765;&#x589E;&#x5F3A;&#xFF0C;&#x6211;&#x4EEC;&#x4E0D;&#x80FD;&#x663E;&#x5F0F;&#x96C6;&#x6210;AtomicInteger&#x7C7B;&#xFF0C;&#x5426;&#x5219;&#x5C31;&#x662F;&#x6709;&#x6548;&#x548C;&#x6709;&#x7528;&#x7684;&#x3002;&#xFF08;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x4E3A;&#x4E86;&#x589E;&#x5F3A;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x7528;AtomicXXX&#x64CD;&#x4F5C;&#x4E86;&#xFF09;
     * &#x6240;&#x4EE5;&#xFF0C;&#x4F5C;&#x4E3A;&#x8F83;&#x5C0F;&#x7684;&#x5F0A;&#x7AEF;&#xFF0C;&#x672C;&#x5730;&#x5B9E;&#x73B0;&#x4F7F;&#x7528;hotspot&#x5185;&#x5728;&#x51FD;&#x6570;API&#x3002;
     * &#x5F53;&#x6211;&#x4EEC;&#x8FD9;&#x6837;&#x505A;&#x65F6;&#xFF0C;&#x5BF9;&#x5176;&#x4ED6;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;CAS&#x5B57;&#x6BB5;&#x4E5F;&#x8FD9;&#x6837;&#x505A;&#xFF08;&#x5426;&#x5219;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x539F;&#x5B50;&#x5B57;&#x6BB5;&#x66F4;&#x65B0;&#x7A0B;&#x5E8F;&#x6765;&#x5B8C;&#x6210;&#xFF09;
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> stateOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> headOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> tailOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> waitStatusOffset;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> nextOffset;

    <span class="hljs-keyword">static</span> {
        <span class="hljs-keyword">try</span> {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;head&quot;</span>));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(<span class="hljs-string">&quot;waitStatus&quot;</span>));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(<span class="hljs-string">&quot;next&quot;</span>));

        } <span class="hljs-keyword">catch</span> (Exception ex) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); }
    }

    <span class="hljs-comment">/**
     * CAS head field. Used only by enq.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetHead</span><span class="hljs-params">(Node update)</span> </span>{
        <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-keyword">this</span>, headOffset, <span class="hljs-keyword">null</span>, update);
    }

    <span class="hljs-comment">/**
     * CAS tail field. Used only by enq.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> </span>{
        <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-keyword">this</span>, tailOffset, expect, update);
    }

    <span class="hljs-comment">/**
     * CAS waitStatus field of a node.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetWaitStatus</span><span class="hljs-params">(Node node,
                                                         <span class="hljs-keyword">int</span> expect,
                                                         <span class="hljs-keyword">int</span> update)</span> </span>{
        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset,
                                        expect, update);
    }

    <span class="hljs-comment">/**
     * CAS next field of a node.
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetNext</span><span class="hljs-params">(Node node,
                                                   Node expect,
                                                   Node update)</span> </span>{
        <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);
    }
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="AbstractOwnableSynchronizer.java.html" class="navigation navigation-prev " aria-label="Previous page: AbstractOwnableSynchronizer.Java">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Condition.java.html" class="navigation navigation-next " aria-label="Next page: Condition.Java">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"AbstractQueuedSynchronizer.Java","level":"1.2.3.12.2","depth":4,"next":{"title":"Condition.Java","level":"1.2.3.12.3","depth":4,"path":"Doc/util/concurrent/locks/Condition.java.md","ref":"Doc/util/concurrent/locks/Condition.java.md","articles":[]},"previous":{"title":"AbstractOwnableSynchronizer.Java","level":"1.2.3.12.1","depth":4,"path":"Doc/util/concurrent/locks/AbstractOwnableSynchronizer.java.md","ref":"Doc/util/concurrent/locks/AbstractOwnableSynchronizer.java.md","articles":[]},"dir":"ltr"},"config":{"plugins":["summary","splitter","code","-sharing","-lunr","-search","search-pro","livereload"],"styles":{"website":"styles/website.css"},"pluginsConfig":{"summary":{},"splitter":{},"code":{"copyButtons":true},"search-pro":{},"livereload":{},"highlight":{},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"莫显辉","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"zh-hans","gitbook":"*","description":"日常笔记"},"file":{"path":"Doc/util/concurrent/locks/AbstractQueuedSynchronizer.java.md","mtime":"2021-07-29T05:53:39.773Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-08-30T05:59:23.144Z"},"basePath":"../../../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../../../gitbook/gitbook.js"></script>
    <script src="../../../../gitbook/theme.js"></script>
    
        
        <script src="../../../../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../../../../gitbook/gitbook-plugin-code/plugin.js"></script>
        
    
        
        <script src="../../../../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../../../../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../../../../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../../../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

